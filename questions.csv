id,question,answer,description,category_id,difficulty_id,expected_output
1,"リスト内包表記を使って、0から10までの偶数を生成しなさい。","＜解答例＞
li = [nm for nm in range(0,11) if nm%2 == 0]
print(li)",None,2,2,
2,"数値が正の数か負の数かを判定する関数を作成しなさい。","＜解答例＞
def check_number(num):
    if num > 0:
        return ""正の数""
    elif num < 0:
        return ""負の数""
    else:
        return ""ゼロ""",None,2,2,
3,"関数 is_even_or_odd を作成してください。
この関数は、引数として受け取った数値が奇数か偶数かを判定して、以下のように出力します。


入力が偶数の場合：""{数値}は偶数です""
入力が奇数の場合：""{数値}は奇数です""","def is_even_or_odd(nm=None):

　　# 引数が空または数値でない場合
    if nm is None or not isinstance(nm, (int, float)):  
        return ""引数は数値である必要があります""
    return f""{nm}は偶数です"" if nm % 2 == 0 else f""{nm}は奇数です""",None,2,2,
5,"次の関数を完成させてください：

関数名: factorial
引数: n（非負整数）
基底条件: n == 0 または n == 1 の場合、1を返す。
再帰呼び出し: n * factorial(n - 1) を計算する。","def factorial(n):
    if n == 0 or n == 1:
        return 1
    return n* factorial(n-1)",None,2,3,
10,"リスト内の最大値を返す関数 find_max を作成してください。
引数としてリストを受け取ります。
空のリストが渡された場合は、エラーメッセージ（例: ""リストが空です""）を返してください。


print(find_max([3, 5, 7, 2, 8]))  # 出力: 8
print(find_max([-1, -3, -5]))     # 出力: -1
print(find_max([]))               # 出力: ""リストが空です""","＜解答例＞
```
def find_max(li):
    if not isinstance(li, list):
        return ""リストを入力してください""
    if li == []:
        return ""リストが空です""
    if not all(isinstance(x, (int, float)) for x in li):  # 要素が数値か確認
        return ""リストには数値のみ含めてください""
    return max(li)
```","登録する解説を入力してください",3,2,
11,"リスト内の最大値を返す関数 find_max を作成してください。
引数としてリストを受け取ります。
空のリストが渡された場合は、エラーメッセージ（例: ""リストが空です""）を返してください。


print(find_max([3, 5, 7, 2, 8]))  # 出力: 8
print(find_max([-1, -3, -5]))     # 出力: -1
print(find_max([]))               # 出力: ""リストが空です""","＜解答例＞
def find_max(li):
    if not isinstance(li, list):
        return ""リストを入力してください""
    if li == []:
        return ""リストが空です""
    if not all(isinstance(x, (int, float)) for x in li):  # 要素が数値か確認
        return ""リストには数値のみ含めてください""
    return max(li)","登録する解説を入力してください",3,3,
12,"リスト内の奇数を全て2倍にした新しいリストを返す関数 double_odds を作成してください。
引数としてリストを受け取ります。
奇数は2倍にし、偶数はそのまま残します。
空のリストが渡された場合は、空のリストを返します。



print(double_odds([1, 2, 3, 4, 5]))  # 出力: [2, 2, 6, 4, 10]
print(double_odds([6, 8, 10]))       # 出力: [6, 8, 10] (奇数がない)
print(double_odds([]))               # 出力: []","def double_odds(li=None):
    if li is None:
        return ""リストが空です""
    if not isinstance(li,list):
        return ""リストを入力してください""
    if not all(isinstance(x,(int,float))for x in li):
        return ""数値を入力してください""  
    
    #奇数を2倍にして返す
    return [n*2 if n%2 ==1 else n for n in li ]","登録する解説を入力してください",2,2,
13,"文字列内の単語数をカウントして返す関数 count_words を作成してください。
引数として1つの文字列を受け取ります。
空の文字列が渡された場合は、0を返します。
単語はスペースで区切られたものとします。



print(count_words(""This is a test""))      # 出力: 4
print(count_words(""Python programming"")) # 出力: 2
print(count_words(""""))                   # 出力: 0","＜解答例＞
def count_words(words=""""):
    if not isinstance(words, str):  # 型チェック
        return ""文字列を入力してください""
    if not words.strip():  # 空白だけの文字列も 0 として扱う
        return 0
    return len(words.split())","登録する解説を入力してください",3,2,
20,"```
x = ""10""
y = 5
z = x + str(y)
print(z)
```
上記のコードを実行すると、出力される値は？

１．15
２．105
３．TypeError
４．""105""","4. ""105""","x は文字列 ""10""、y は整数 5。str(y) によって 5 が文字列になり、文字列の連結が行われる。",1,1,
21,"```
x = 10
if x > 5:
    print(""A"")
elif x > 8:
    print(""B"")
else:
    print(""C"")
```
上記のコードを実行すると、出力される値は？

１．A
２．B
３．C
４．A B","1. A","if 文は上から順番に評価され、最初に True になった条件で処理が終わる。x > 5 が True のため ""A"" が出力され、elif は実行されない。",2,1,
22,"result = 0
for i in range(1, 6, 2):
    result += i
print(result)

 上記のコードを実行すると、出力される値は？

１．9
２．10
３．12
４．15"," 1. 9","range(1, 6, 2) は [1, 3, 5] を生成するので、1 + 3 + 5 = 9 になる。",2,2,
23,"numbers = [0, 1, 2, 3, 4]
if numbers[2] and numbers[4]:
    print(""Yes"")
else:
    print(""No"")

上記のコードを実行すると、出力される値は？

１．Yes
２．No
３．IndexError
４．TypeError"," 1. Yes","numbers[2] は 2、numbers[4] は 4。0 以外の数値は True と評価されるので if 条件は True になり ""Yes"" が出力される。",2,2,
24,"x = 5
y = 10
result = ""Even"" if (x * y) % 2 == 0 else ""Odd""
print(result)

上記のコードを実行すると、出力される値は？

１．Even
２．Odd
３．None
４．SyntaxError","1. Even","x * y = 5 * 10 = 50。50 % 2 == 0 なので True となり、""Even"" が出力される。",2,3,
25,"nums = [10, 20, 30, 40, 50]
print(nums[1:4])

上記のコードを実行すると、出力される値は？

[10, 20, 30]
[20, 30, 40]
[30, 40, 50]
IndexError","２．[20, 30, 40]","nums[1:4] の意味：
開始インデックス 1 → 20（インデックスは 0 から始まる）
終了インデックス 4（4番目の要素は含まない）

取得される範囲：nums[1]（20）, nums[2]（30）, nums[3]（40）
nums[4]（50）は含まれない

🔹 ポイント
スライスの範囲 start:end の end は含まれない！
リストのインデックスは 0 から始まる
nums[1:4] → 1番目から3番目までの要素が取得される（end のインデックスは含まれない",1,1,
26,"a, b, c = (1, 2, 3)
print(b)

上記のコードを実行すると、出力される値は？


1. 1
2. 2
3. 3
4. TypeError","2. 2","このコードでは、「タプルのアンパック」 を使っています。
アンパック（unpacking）は、タプルの各要素を 個別の変数に代入 できる便利な機能です。

＜処理の流れ＞
右辺のタプル (1, 2, 3)
→ 3つの要素（1, 2, 3）が含まれる。

左辺の a, b, c にそれぞれ代入

a = 1
b = 2 ✅ ← print(b) で 2 が出力
c = 3

＜ ポイント＞
✅ タプルのアンパックでは、左辺と右辺の要素数が一致する必要がある！
（例えば、a, b = (1, 2, 3) にすると ValueError になる）

✅ リストでも同じようにアンパック可能

x, y, z = [10, 20, 30]
print(y)  # ✅ 出力: 20

✅ 不要な変数を _ で無視できる

a, _, c = (1, 2, 3)
print(c)  # ✅ 出力: 3  （`_` の部分は無視）",1,1,
27,"data = {""name"": ""Alice"", ""age"": 25, ""city"": ""Tokyo""}
print(list(data.keys()))

 上記のコードを実行すると、出力される値は？

1. [""Alice"", 25, ""Tokyo""]
2. [""name"", ""age"", ""city""]
3. dict_keys([""name"", ""age"", ""city""])
4. (""name"", ""age"", ""city"")","2. [""name"", ""age"", ""city""]","このコードでは、辞書の キー（key） を取得するために .keys() メソッド を使っています。

辞書 data には次のキーと値がある

{
    ""name"": ""Alice"",
    ""age"": 25,
    ""city"": ""Tokyo""
}

.keys() を使うと、辞書のキーだけを取得
list() でリストに変換

dict_keys は リストのように扱える けど、明示的に list() に変換するとリストとして出力される。

＜関連知識＞

値を取得したい場合
list(data.values())  # ➝ ['Alice', 25, 'Tokyo']

キーと値のペアを取得
list(data.items())  # ➝ [('name', 'Alice'), ('age', 25), ('city', 'Tokyo')]",10,1,
28,"x = 0
while x < 5:
    if x == 3:
        break
    x += 1
print(x)

上記のコードを実行すると、出力される値は？

1️⃣ 3
2️⃣ 4
3️⃣ 5
4️⃣ 6","1️⃣ 3","🔹 while ループの動作
このコードでは、x = 0 から始まり、x < 5 の間 while ループが繰り返されます。

x は 0 から始まり、毎回 x += 1 されていきます。
しかし、x == 3 になった時点で break が実行され、ループが強制終了します。

🔹 ループの流れ
ループ回数	x の値	if x == 3 の判定	break 実行
1回目	0 → 1	False	続行
2回目	1 → 2	False	続行
3回目	2 → 3	**True**	**ループ終了**

ループが終了した後、print(x) が実行されるので、 最終的に 3 が出力されます。",2,2,
29,"fruits = [""apple"", ""banana"", ""cherry""]
for index, fruit in enumerate(fruits, start=1):
    print(index, fruit)
上記のコードを実行すると、出力される内容は？

1️⃣
0 apple
1 banana
2 cherry

2️⃣
1 apple
2 banana
3 cherry

3️⃣
apple 1
banana 2
cherry 3

4️⃣ 
エラーが発生する
","正解は 2️⃣","✅ ポイント
・ enumerate() を使うと、リストの要素とインデックスを同時に取得できる
・ デフォルトのインデックスは 0 から始まるが、start=1 を指定すると 1 から開始する
・ Python では for ループでリストを回す際に enumerate() を使うと可読性が上がる",2,2,
30,"numbers = [1, 2, 3, 4, 5]
squared = [x**2 for x in numbers if x % 2 == 0]
print(squared)

上記のコードを実行すると、出力されるリストは？
1️⃣ [1, 4, 9, 16, 25]
2️⃣ [4, 16]
3️⃣ [2, 4]
4️⃣ [1, 9, 25]","2️⃣ [4, 16]","🔹 リスト内包表記の動作
リスト内包表記（List Comprehension）は、リストを簡潔に作成する方法です。

🔹このコードを分解すると、次のようになります。
squared = [x**2 for x in numbers if x % 2 == 0]
x**2 → x の 2乗 を計算
for x in numbers → numbers の各要素 x を順番に処理
if x % 2 == 0 → 偶数 (x % 2 == 0) の場合のみ 2乗をリストに追加

✅ ポイント
1️⃣ リスト内包表記は、[処理 for 変数 in イテラブル if 条件] の形を取る
2️⃣ if 条件を追加すると、特定の要素だけをリストに含めることができる
3️⃣ x**2 で平方（2乗）を計算することで、偶数の平方リストを作成した",2,3,
31,"names = [""Alice"", ""Bob"", ""Charlie""]
scores = [85, 92, 78]
for name, score in zip(names, scores):
    print(f""{name}: {score}"")

上記のコードを実行すると、出力される内容は？

1️⃣
Alice: 85
Bob: 92
Charlie: 78

2️⃣
Alice: 85
Bob: 92
Charlie: 78
None: None

3️⃣
Alice Bob Charlie: 85 92 78

4️⃣ エラーが発生する","1️⃣
Alice: 85
Bob: 92
Charlie: 78","🔹 zip() 関数の動作
zip() 関数は、複数のリスト（イテラブル）を同時にループするための関数 です。
このコードでは、names と scores の対応する要素を ペアとして取得 します。
したがって、正解は 1️⃣ です！ 

✅ ポイント
1️⃣ zip() を使うと、複数のリストを同時にループできる
2️⃣ リストの要素数が異なる場合、短い方の要素数に合わせてループが終了する
3️⃣ f""{変数}: {変数}"" を使うと、フォーマットされた文字列を作成できる",3,3,
32,"set1 = {1, 2, 3, 4}
set2 = {3, 4, 5, 6}
result = set1 & set2
print(result)

 上記のコードを実行すると、出力される内容は？
1️⃣ {1, 2, 3, 4, 5, 6}
2️⃣ {3, 4}
3️⃣ {1, 2, 5, 6}
4️⃣ TypeError が発生する","2️⃣ {3, 4}","🔹 set（集合）とは？
Python の set 型（集合）は、重複しない要素を持つデータ構造 で、数学の集合演算を行うことができます。
🔹 & 演算子（積集合）
set1 & set2 は 「積集合（共通部分）」 を求める演算です。
両方の集合に含まれる要素だけが残ります。

したがって、正解は 2️⃣ {3, 4} です！

✅ ポイント
1️⃣ set1 & set2 は「共通部分（積集合）」を求める
2️⃣ set1 | set2（和集合）を使うと、全要素の重複を除いて結合できる
3️⃣ set1 - set2（差集合）を使うと、set1 にあって set2 にない要素が得られる",3,3,
33,"data = {""name"": ""Alice"", ""age"": 25}
key = ""gender""
value = data.get(key, ""unknown"")
print(value)

上記のコードを実行すると、出力される内容は？
1️⃣ ""gender""
2️⃣ ""unknown""
3️⃣ None
4️⃣ KeyError が発生する","2️⃣ ""unknown""","🔹 dict.get(key, default) の動作
dict.get(key, default) は、辞書 dict から指定した key の値を取得するメソッドです。

・指定した key が辞書に 存在する場合 → その値を返す
・存在しない場合 → default の値を返す（指定しなければ None を返す）

🔹 コードの動作
１．data は {""name"": ""Alice"", ""age"": 25} の辞書
２．key = ""gender"" は、辞書 data に 存在しないキー
３．data.get(key, ""unknown"") を実行
４．""gender"" キーが辞書にないため、デフォルト値 ""unknown"" が返る
５．出力: ""unknown""",10,3,
34,"try:
    result = 10 / 0
except ZeroDivisionError:
    print(""Error: Division by zero"")
else:
    print(""Success:"", result)

上記のコードを実行すると、出力される内容は？

1️⃣
Success: 0
2️⃣
Error: Division by zero
3️⃣
ZeroDivisionError: division by zero
4️⃣ 
エラーが発生せず、何も出力されない","2️⃣　Error: Division by zero","🔹 try-except の動作
Python の try-except 構文は エラー（例外）をキャッチしてプログラムのクラッシュを防ぐ ために使われます。

🔹 コードの動作
try ブロック内で 10 / 0 を計算しようとする
ゼロ除算 (ZeroDivisionError) が発生！
except ZeroDivisionError: によってキャッチされる
print(""Error: Division by zero"") が実行される
else ブロックは実行されない（try 内でエラーが起こった場合、else はスキップ）
よって、正解は 2️⃣ です！",7,3,
35,"multiply = lambda x, y: x * y
result = multiply(3, 4)
print(result)

上記のコードを実行すると、出力される値は？
1️⃣ 7
2️⃣ 12
3️⃣ 34
4️⃣ TypeError が発生する","2️⃣ 12","🔹 lambda 関数とは？
Python の lambda 関数（無名関数）は、関数を簡潔に定義できる 特殊な書き方です。
通常の def で書く関数を、1行でシンプルに表現 できます。

multiply = lambda x, y: x * y
これは、次の def を使った関数と同じ意味になります。
def multiply(x, y):
    return x * y

🔹 コードの動作
１．lambda x, y: x * y という 無名関数 を作成し、それを multiply に代入
２．multiply(3, 4) を実行
３．3 * 4 = 12 を計算
４．print(result) により 12 が出力される

✅ ポイント
1️⃣ lambda 関数は、一時的に簡単な関数を作りたいときに便利
2️⃣ lambda x, y: x * y のように : の後に返り値を書く
3️⃣ 関数オブジェクトとして lambda を変数に代入すれば、普通の関数のように使える",3,3,
36,"data = [(""Alice"", 25), (""Bob"", 20), (""Charlie"", 30)]
data.sort(key=lambda x: x[1])
print(data)

上記のコードを実行すると、出力されるリストは？
1️⃣ [(""Alice"", 25), (""Bob"", 20), (""Charlie"", 30)]
2️⃣ [(""Charlie"", 30), (""Alice"", 25), (""Bob"", 20)]
3️⃣ [(""Bob"", 20), (""Alice"", 25), (""Charlie"", 30)]
4️⃣ TypeError が発生する","3️⃣ [(""Bob"", 20), (""Alice"", 25), (""Charlie"", 30)]","🔹 sort() メソッドの動作
sort() メソッドは、リストの要素を並び替える メソッドです。
key 引数に lambda x: x[1] を指定すると、各タプルの 2 番目の要素（年齢） を基準にソートされます。

✅ ポイント
1️⃣ sort() はリストの要素を並び替えるメソッド（破壊的変更を行う）
2️⃣ key=lambda x: x[1] は「各要素（タプル）の 2 番目の値（年齢）」でソートすることを意味する
3️⃣ リストはデフォルトで昇順（小さい値→大きい値）に並び替えられる
4️⃣ 降順（大きい値→小さい値）にする場合は、sort(..., reverse=True) を使う",10,3,
37,"keys = [""name"", ""age"", ""city""]
values = [""Alice"", 25, ""New York""]
data = {k: v for k, v in zip(keys, values)}
print(data)

 上記のコードを実行すると、出力される辞書は？
1️⃣ {""name"": ""Alice"", ""age"": 25, ""city"": ""New York""}
2️⃣ {""Alice"": ""name"", 25: ""age"", ""New York"": ""city""}
3️⃣ [(""name"", ""Alice""), (""age"", 25), (""city"", ""New York"")]
4️⃣ TypeError が発生する","1️⃣ {""name"": ""Alice"", ""age"": 25, ""city"": ""New York""}","🔹 辞書の内包表記とは？
Python では 辞書（dict）を内包表記 を使って簡潔に作成できます。

{key: value for key, value in zip(keys, values)}
これは zip(keys, values) で 2つのリストをペアにして辞書を作成 する方法です。

🔹 コードの動作
１．zip(keys, values) の結果
[(""name"", ""Alice""), (""age"", 25), (""city"", ""New York"")]

２．辞書の内包表記で辞書を作成
{
    ""name"": ""Alice"",
    ""age"": 25,
    ""city"": ""New York""
}

３．最終的な data の内容
{""name"": ""Alice"", ""age"": 25, ""city"": ""New York""}

🔹 実行結果
{'name': 'Alice', 'age': 25, 'city': 'New York'}

よって、正解は 1️⃣

✅ ポイント
１． zip(keys, values) を使うと、2つのリストを辞書のキーと値に変換できる
２．辞書の内包表記 {k: v for k, v in zip(keys, values)} でシンプルに辞書を作成できる
３． リストの長さが違う場合、zip() は短い方の長さに合わせる（余った要素は無視される）",10,3,
38,"numbers = [1, 2, 3, 4, 5]
squared = list(map(lambda x: x ** 2, numbers))
print(squared)

上記のコードを実行すると、出力されるリストは？
1️⃣ [1, 4, 9, 16, 25]
2️⃣ [2, 4, 6, 8, 10]
3️⃣ [1, 2, 3, 4, 5]
4️⃣ TypeError が発生する","1️⃣ [1, 4, 9, 16, 25]","🔹 map() 関数とは？
map() 関数は、リストやタプルの 各要素に関数を適用 し、新しいイテラブル（map オブジェクト）を返します。
書式は次のとおりです：map(関数, イテラブル)
ポイント：
第1引数: 適用する関数（ここでは lambda x: x ** 2）
第2引数: 処理対象となるイテラブル（リスト、タプルなど）

🔹 コードの動作
１．numbers = [1, 2, 3, 4, 5]
２．map(lambda x: x ** 2, numbers) を実行
　各要素 x に x ** 2 を適用
　計算結果: [1, 4, 9, 16, 25]
３．map() の戻り値は map オブジェクトなので、list() でリストに変換
４．最終的なリストの内容
　[1, 4, 9, 16, 25]",3,3,
39,"numbers = [10, 15, 20, 25, 30]
filtered = list(filter(lambda x: x % 2 == 0, numbers))
print(filtered)

上記のコードを実行すると、出力されるリストは？
1️⃣ [10, 20, 30]
2️⃣ [15, 25]
3️⃣ [10, 15, 20, 25, 30]
4️⃣ TypeError が発生する","1️⃣ [10, 20, 30]","🔹 filter() 関数とは？
filter() 関数は、リストやタプルの 各要素に関数を適用し、True を返した要素のみを残す 関数です。
書式は次のとおりです：filter(関数, イテラブル)
ポイント：
・第1引数: True または False を返す関数（ここでは lambda x: x % 2 == 0）
・第2引数: 処理対象となるイテラブル（リスト、タプルなど）
・戻り値は filter オブジェクトなので、list() でリストに変換するのが一般的

🔹 コードの動作
１．numbers = [10, 15, 20, 25, 30]
２．filter(lambda x: x % 2 == 0, numbers) を実行
３．各要素 x を x % 2 == 0 でチェックし、True のものだけ残す
　判定結果:
　　10 % 2 == 0 ✅ (残る)
　　15 % 2 == 0 ❌ (削除)
　　20 % 2 == 0 ✅ (残る)
　　25 % 2 == 0 ❌ (削除)
　　30 % 2 == 0 ✅ (残る)
４．最終的なリストの内容
　[10, 20, 30]
よって、正解は 1️⃣

✅ ポイント
１． filter() は、特定の条件を満たす要素だけを抽出するときに便利！
２． lambda x: x % 2 == 0 のように True/False を返す関数を使う
３． 戻り値は filter オブジェクトなので、list() でリストに変換するのが一般的",3,3,
40,"set1 = {1, 2, 3, 4, 5}
set2 = {4, 5, 6, 7, 8}
result = set1 | set2
print(result)

上記のコードを実行すると、出力される内容は？
1️⃣ {1, 2, 3, 4, 5, 6, 7, 8}
2️⃣ {4, 5}
3️⃣ {6, 7, 8}
4️⃣ TypeError が発生する","1️⃣ {1, 2, 3, 4, 5, 6, 7, 8}","🔹 set（集合）とは？
Python の set 型（集合）は、重複しない要素を持つデータ構造 で、数学の集合演算を行うことができます。

🔹 | 演算子（和集合）
set1 | set2 は、「和集合」 を求める演算です。
両方の集合の要素をすべて含み、重複は削除される のが特徴です。

🔹 コードの動作
１．set1 の要素 → {1, 2, 3, 4, 5}
２．set2 の要素 → {4, 5, 6, 7, 8}
３．set1 | set2（和集合）
・両方の集合のすべての要素を含む
・重複する 4, 5 は 1 回だけ含まれる
・最終的な集合の内容
　{1, 2, 3, 4, 5, 6, 7, 8}

✅ ポイント
１． set1 | set2 は「和集合（union）」を求める演算子
２． 和集合は、両方の集合の要素をすべて含むが、重複は排除される
３． set1.union(set2) も同じ意味（| は union() の省略形）",3,3,
41,"a = [1, 2, 3]
b = a
print(a is b)

上記のコードを実行すると、出力される値は？
1️⃣ True
2️⃣ False
3️⃣ None
4️⃣ TypeError が発生する","1️⃣ True","🔹 is 演算子とは？
is 演算子は、2つの変数が同じオブジェクトを参照しているかどうか を判定する演算子です。

a == b → 値 が等しいかを判定（内容が同じかどうか）
a is b → オブジェクトID が同じかを判定（同じメモリを指しているかどうか）

🔹 コードの動作
１．a = [1, 2, 3] により、リスト [1, 2, 3] が作成される
２．b = a により、b は a と同じオブジェクトを指す
３．a is b を評価すると、True になる

🔹 is と == の違い
x = [1, 2, 3]
y = [1, 2, 3]

print(x == y)  # ✅ True（リストの内容が同じ）
print(x is y)  # ❌ False（別のオブジェクト）

✅ ポイント
✔️ is はオブジェクトID（メモリアドレス）を比較する
✔️ == はオブジェクトの値を比較する
✔️ リストや辞書のようなミュータブル（変更可能）なデータ型は、コピーすると別オブジェクトになることに注意！
📌 例えば：
a = [1, 2, 3]
b = a  # `a` と `b` は同じオブジェクト

c = a[:]  # `a` のコピー（新しいリスト）
print(a is c)  # False（新しいオブジェクト）
print(a == c)  # True（内容は同じ）

",1,3,
42,"numbers = [1, 2, 3, 4, 5]
print(3 in numbers)

上記のコードを実行すると、出力される値は？
1️⃣ True
2️⃣ False
3️⃣ None
4️⃣ TypeError が発生する","1️⃣ True","
正解です！🎉

🔹 in 演算子とは？
Python の in 演算子は、リスト・タプル・辞書・セットなどのデータ型に、特定の要素が含まれているかを判定する 演算子です。

書式：　値 in コレクション  
　　　（ 値がコレクション内に含まれている場合 True、そうでなければ False）

🔹 コードの動作
１．numbers は [1, 2, 3, 4, 5] のリスト
２．3 in numbers を評価
３．リストに 3 が含まれているので True

🔹 in 演算子の応用
📌 辞書で使う場合（キーを検索）
data = {""name"": ""Alice"", ""age"": 25}
print(""name"" in data)  # ✅ True（キーが存在する）
print(25 in data)      # ❌ False（値は検索対象にならない）

📌 集合（set）で使う場合
unique_numbers = {10, 20, 30, 40}
print(20 in unique_numbers)  # ✅ True
print(50 in unique_numbers)  # ❌ False
✅ リストやタプルより set の方が in 演算子の検索速度が速い！（ハッシュテーブルを使用）

✅ ポイント
✔️ in 演算子は、リスト・タプル・辞書・セットなどで使える
✔️ リスト内の要素が存在するかを in で判定すると True / False が返る
✔️ 辞書では in は「キー」の存在を確認する（値は対象外）
",1,2,
43,"numbers = [1, 2, 2, 3, 4, 2, 5]
print(numbers.count(2))

上記のコードを実行すると、出力される値は？
1️⃣ 1
2️⃣ 2
3️⃣ 3
4️⃣ TypeError が発生する","3️⃣ 3","🔹 count() メソッドとは？
count() メソッドは、リストの中に指定した要素がいくつ含まれているかを数える メソッドです。

書式：リスト.count(検索する要素)
　　・指定した 要素がリストの中に何回登場するか を返す
　　・存在しない場合は 0 を返す

🔹 コードの動作
１．numbers は [1, 2, 2, 3, 4, 2, 5]
２．numbers.count(2) を実行
　　・2 はリスト内に 3回 出現している
３．最終的な出力
　　3
✅ ポイント
✔️ count() を使うと、リスト内の特定の要素の出現回数を簡単に取得できる
✔️ 存在しない要素を検索すると 0 が返る（エラーにはならない）
✔️ リスト内に何回特定の要素が登場するかを知りたいときに便利！",10,2,
44,"list1 = [1, 2, 3]
list2 = [4, 5, 6]
list1.extend(list2)
print(list1)

上記のコードを実行すると、出力されるリストは？
1️⃣ [1, 2, 3, [4, 5, 6]]
2️⃣ [1, 2, 3, 4, 5, 6]
3️⃣ [4, 5, 6, 1, 2, 3]
4️⃣ TypeError が発生する","2️⃣ [1, 2, 3, 4, 5, 6]","🔹 extend() メソッドとは？
extend() メソッドは、リストの末尾に別のリストの要素を追加する メソッドです。
append() とは異なり、リストの中身を展開して追加する のが特徴です。

書式：リスト1.extend(リスト2)
　　・リスト1 の末尾に リスト2 の要素が展開されて追加される
　　・リスト1 自体が変更される（破壊的変更）

🔹 コードの動作
１．list1 = [1, 2, 3]
２．list2 = [4, 5, 6]
３．list1.extend(list2) を実行
・list1 の末尾に list2 の 中身（要素） を追加
・結果: [1, 2, 3, 4, 5, 6]
４．最終的なリストの内容
　　[1, 2, 3, 4, 5, 6]

✅ ポイント
✔️ extend() は、リストの要素を展開して追加するメソッド
✔️ 元のリスト (list1) が変更される（破壊的変更）
✔️ append() との違いを理解することが重要！

📌 append() との違い
list1.append(list2)  # list2 全体が 1 つの要素として追加される
print(list1)  # ❌ [1, 2, 3, [4, 5, 6]]

list1 = [1, 2, 3]
list1.extend(list2)  # list2 の要素が展開されて追加される
print(list1)  # ✅ [1, 2, 3, 4, 5, 6]

✅ リストを結合する場合は extend() を使うのがベスト！
",10,2,
45,"numbers = [5, 2, 9, 1, 5, 6]
sorted_numbers = sorted(numbers)
print(sorted_numbers)

 上記のコードを実行すると、出力されるリストは？
1️⃣ [5, 2, 9, 1, 5, 6]
2️⃣ [9, 6, 5, 5, 2, 1]
3️⃣ [1, 2, 5, 5, 6, 9]
4️⃣ TypeError が発生する","3️⃣ [1, 2, 5, 5, 6, 9]","🔹 sorted() 関数とは？
sorted() 関数は、リストやタプルなどのイテラブルを並び替えて新しいリストを作成する関数です。
sort() メソッドと違い、元のリストを変更せず、新しいリストを返す のが特徴です。

🔹 コードの動作
１．numbers = [5, 2, 9, 1, 5, 6]
２．sorted(numbers) を実行
　・リストの要素が 昇順（小さい順） にソートされる
　・結果: [1, 2, 5, 5, 6, 9]
３．最終的なリストの内容
　[1, 2, 5, 5, 6, 9]

✅ ポイント
✔️ sorted() は、新しいソート済みリストを返す（元のリストは変更しない）
✔️ sort() メソッドとの違いを理解することが重要！
✔️ 降順（大きい順）にしたい場合は sorted(numbers, reverse=True) を使う

📌 sort() メソッドとの違い
◆sorted() は新しいリストを返す（元のリストは変更されない）

numbers = [5, 2, 9, 1, 5, 6]
sorted_numbers = sorted(numbers)
print(sorted_numbers)  # ✅ [1, 2, 5, 5, 6, 9]
print(numbers)  # ✅ [5, 2, 9, 1, 5, 6] （元のリストは変更なし）

◆sort() は元のリストを直接変更する

numbers.sort()
print(numbers)  # ✅ [1, 2, 5, 5, 6, 9] （元のリストが変更される）

✅ 元のリストを保持したい場合は sorted() を使う！",10,3,
46,"list1 = [""a"", ""b"", ""c""]
list2 = [1, 2, 3]
result = list(zip(list1, list2))
print(result)

上記のコードを実行すると、出力されるリストは？
1️⃣ [[""a"", 1], [""b"", 2], [""c"", 3]]
2️⃣ [(""a"", 1), (""b"", 2), (""c"", 3)]
3️⃣ [(""a"", ""b"", ""c""), (1, 2, 3)]
4️⃣ TypeError が発生する","2️⃣ [(""a"", 1), (""b"", 2), (""c"", 3)]","🔹 zip() 関数とは？
zip() 関数は、複数のリスト（イテラブル）を対応する要素ごとにペアにしてまとめる 関数です。

書式：zip(イテラブル1, イテラブル2, ...)
　　・同じインデックスの要素をペアにする
　　・戻り値は zip オブジェクト（イテレータ）なので、list() でリスト化することが多い
　　・対応する要素がなくなった時点で終了（長さが異なる場合、短い方に合わせる）

🔹 コードの動作
１．list1 = [""a"", ""b"", ""c""]
２．list2 = [1, 2, 3]
３．zip(list1, list2) により、対応する要素をタプルにまとめる
・(""a"", 1)
・(""b"", 2)
・(""c"", 3)
４．最終的なリストの内容
　　[(""a"", 1), (""b"", 2), (""c"", 3)]

✅ ポイント
✔️ zip() は、リストの対応する要素をタプルにまとめる
✔️ zip() の戻り値は zip オブジェクトなので、list() や tuple() で明示的に変換するのが一般的
✔️ リストの長さが異なる場合、短い方に合わせる（余った要素は無視される）

📌 リストの長さが異なる場合
list1 = [""a"", ""b"", ""c"", ""d""]
list2 = [1, 2]
result = list(zip(list1, list2))
print(result)  # [('a', 1), ('b', 2)]  ← 'c' と 'd' は無視される

📌 タプルではなくリストのリストにする場合
list1 = [""a"", ""b"", ""c""]
list2 = [1, 2, 3]
result = [list(pair) for pair in zip(list1, list2)]
print(result)  # [['a', 1], ['b', 2], ['c', 3]]

✅ データのペアリングや辞書の作成に便利！",10,3,
47,"data = {""name"": ""Alice"", ""age"": 25, ""city"": ""New York""}
for key, value in data.items():
    print(f""{key}: {value}"")

上記のコードを実行すると、出力される内容は？
1️⃣
name: Alice
age: 25
city: New York

2️⃣
(""name"", ""Alice"")
(""age"", 25)
(""city"", ""New York"")

3️⃣
[""name"", ""Alice""]
[""age"", 25]
[""city"", ""New York""]

4️⃣ TypeError が発生する","1️⃣
name: Alice
age: 25
city: New York","🔹 items() メソッドとは？
辞書の .items() メソッドは、キーと値のペアをタプルの形で返す メソッドです。
書式：辞書.items() 　　 # (キー, 値) のタプルを取得

🔹 コードの動作
１．data.items() を使うことで、辞書のキーと値のペアを タプルの形 で取得
・[(""name"", ""Alice""), (""age"", 25), (""city"", ""New York"")]
・for key, value in data.items(): で 各ペアを分解 し、変数 key と value に代入
２．print(f""{key}: {value}"") により、次のように出力される
３．name: Alice
　　age: 25
　　city: New York

✅ ポイント
✔️ items() はキーと値のペアをタプルで返す
✔️ for key, value in 辞書.items(): で、キーと値を分けて受け取れる
✔️ 辞書をループするときは .items() を使うと、キーと値を簡単に扱える

📌 辞書のループ方法
data = {""name"": ""Alice"", ""age"": 25, ""city"": ""New York""}

# キーだけを取得
for key in data.keys():
    print(key)

# 値だけを取得
for value in data.values():
    print(value)

# キーと値の両方を取得
for key, value in data.items():
    print(f""{key}: {value}"")

✅ 辞書をループするとき .items() を使うと、キーと値を分けて受け取れるので便利！",10,3,
48,"fruits = [""apple"", ""banana"", ""cherry""]
for index, fruit in enumerate(fruits, start=1):
    print(index, fruit)

上記のコードを実行すると、出力される内容は？
1️⃣
0 apple
1 banana
2 cherry

2️⃣
1 apple
2 banana
3 cherry

3️⃣
apple 1
banana 2
cherry 3

4️⃣ TypeError が発生する","2️⃣
1 apple
2 banana
3 cherry","🔹 enumerate() 関数とは？
enumerate() 関数は、リストの要素とそのインデックスを同時に取得 できる関数です。
普通の for ループでは 値 だけを取得しますが、enumerate() を使うと インデックス付き でループができます。

🔹 コードの動作
１．fruits = [""apple"", ""banana"", ""cherry""]
２．enumerate(fruits, start=1) により、インデックスを 1 から開始 する
３．for index, fruit in enumerate(fruits, start=1): で
　・index = 1, fruit = ""apple""
　・index = 2, fruit = ""banana""
　・index = 3, fruit = ""cherry""
４．print(index, fruit) により、次のように出力される
　1 apple
　2 banana
　3 cherry

✅ ポイント
✔️ enumerate() を使うと、リストの要素とインデックスを同時に取得できる
✔️ デフォルトではインデックスは 0 から始まるが、start= で開始番号を変更できる
✔️ リストの中身を番号付きで処理する際に便利！

📌 start= を指定しない場合（デフォルトは 0）
fruits = [""apple"", ""banana"", ""cherry""]
for index, fruit in enumerate(fruits):
    print(index, fruit)

＜実行結果＞
0 apple
1 banana
2 cherry

📌 辞書風のリストを作る場合
fruit_dict = dict(enumerate(fruits, start=1))
print(fruit_dict)

＜実行結果＞ 
{1: 'apple', 2: 'banana', 3: 'cherry'}

✅ インデックスを管理しながらループを回したいときに enumerate() は超便利！

",10,3,
49,"def add_numbers(*args):
    return sum(args)

result = add_numbers(1, 2, 3, 4, 5)
print(result)

上記のコードを実行すると、出力される値は？
1️⃣ 15
2️⃣ (1, 2, 3, 4, 5)
3️⃣ [1, 2, 3, 4, 5]
4️⃣ TypeError が発生する","1️⃣ 15","🔹 *args とは？
*args は、可変長引数 を受け取るための仕組みです。
関数に渡される 複数の引数をタプルとして受け取る ことができます。

🔹 コードの動作
１．関数 add_numbers() の定義
　・*args を使って、複数の引数をタプルとして受け取る
　・sum(args) で すべての値を合計する
２．関数の呼び出し
　　add_numbers(1, 2, 3, 4, 5)
　・args には (1, 2, 3, 4, 5) のタプルが渡される
　・sum((1, 2, 3, 4, 5)) = 15
３．最終的な出力
　15

✅ ポイント
✔️ *args を使うと、複数の引数をタプルとして受け取れる
✔️ 関数に渡す引数の数が決まっていなくても対応できる（可変長引数）
✔️ sum(args) を使うと、すべての数値を合計できる

📌 引数の数が異なる場合もOK！
print(add_numbers(10, 20))  # 30
print(add_numbers(1, 2, 3, 4, 5, 6, 7, 8, 9))  # 45

📌 *args の中身を確認する
def check_args(*args):
    print(args)

check_args(1, ""hello"", True)  

＜関数check_argsの実行結果＞
 (1, 'hello', True)  ← タプルとして受け取っている

✅ 可変長引数を使うと、柔軟な関数を作れる！",3,3,
50,"def print_info(**kwargs):
    for key, value in kwargs.items():
        print(f""{key}: {value}"")

print_info(name=""Alice"", age=25, city=""New York"")

上記のコードを実行すると、出力される内容は？

1️⃣
('name', 'Alice')
('age', 25)
('city', 'New York')

2️⃣
name: Alice
age: 25
city: New York

3️⃣
['name', 'Alice']
['age', 25]
['city', 'New York']

4️⃣ TypeError が発生する","2️⃣
name: Alice
age: 25
city: New York","🔹 **kwargs とは？
**kwargs は、可変長のキーワード引数（名前付き引数）を受け取るための仕組み です。
関数に渡される 複数のキーワード引数を辞書（dict）として受け取る ことができます。

🔹 コードの動作
１．関数 print_info() の定義
・**kwargs を使って、複数のキーワード引数を辞書として受け取る
・kwargs.items() を使って、キーと値を取得
・print(f""{key}: {value}"") で、key: value の形式で出力
２．関数の呼び出し
　print_info(name=""Alice"", age=25, city=""New York"")
・kwargs には {""name"": ""Alice"", ""age"": 25, ""city"": ""New York""} の辞書が渡される
・ループで各ペアを取り出して出力
３．最終的な出力
　name: Alice
　age: 25
　city: New York

✅ ポイント
✔️ **kwargs を使うと、可変長のキーワード引数を辞書として受け取れる
✔️ for key, value in kwargs.items() でキーと値を分けてループできる
✔️ 辞書の .items() メソッドと相性が良い！

📌 引数の数が異なる場合もOK！
print_info(name=""Bob"", country=""Japan"")
# 出力:
# name: Bob
# country: Japan

📌 *args と **kwargs を組み合わせる
def test_function(*args, **kwargs):
    print(""位置引数:"", args)
    print(""キーワード引数:"", kwargs)

test_function(1, 2, 3, name=""Charlie"", age=30)
# 出力:
# 位置引数: (1, 2, 3)
# キーワード引数: {'name': 'Charlie', 'age': 30}
✅ 柔軟な関数を作るときに **kwargs は超便利！",3,3,
51,"data = {""name"": ""Alice"", ""age"": 25}
value = data.setdefault(""city"", ""New York"")
print(data)

 上記のコードを実行すると、出力される辞書は？
1️⃣ {""name"": ""Alice"", ""age"": 25}
2️⃣ {""name"": ""Alice"", ""age"": 25, ""city"": ""New York""}
3️⃣ {""name"": ""Alice"", ""age"": 25, ""city"": None}
4️⃣ TypeError が発生する","2️⃣ {""name"": ""Alice"", ""age"": 25, ""city"": ""New York""}","🔹 setdefault() メソッドとは？
setdefault() は、辞書に指定したキーが存在しない場合、そのキーを追加し、指定したデフォルト値を設定する メソッドです。もしキーがすでに存在する場合は、そのままの値を返します。

書式：　辞書.setdefault(キー, デフォルト値)
　　・キーが辞書にない場合 → キーを追加し、デフォルト値をセット
　　・キーがすでにある場合 → 何も変更せず、そのキーの値を返す

✅ ポイント
✔️ setdefault(キー, 値) は、キーがなければ追加、あれば何もしない
✔️ 辞書に値を安全に追加するのに便利（キーがあるか確認しなくてよい）
✔️ 辞書にキーがすでにある場合は、元の値をそのまま返す

📌 キーがすでに存在する場合
data = {""name"": ""Alice"", ""age"": 25, ""city"": ""Tokyo""}
value = data.setdefault(""city"", ""New York"")
print(data)  # {""name"": ""Alice"", ""age"": 25, ""city"": ""Tokyo""}  ← 変更なし
print(value)  # ""Tokyo""  ← 既存の値をそのまま返す

📌 通常の辞書更新（setdefault() なし）との違い
# setdefault() を使わない場合
if ""city"" not in data:
    data[""city""] = ""New York""

# これと同じ処理を 1 行で書ける
data.setdefault(""city"", ""New York"")

✅ setdefault() を使うと、値の有無をチェックしなくても安全に辞書を更新できる！",10,3,
52,"words = [""Hello"", ""World"", ""!""]
result = "" "".join(words)
print(result)

上記のコードを実行すると、出力される文字列は？
1️⃣ ""Hello World !""
2️⃣ [""Hello"", ""World"", ""!""]
3️⃣ ""HelloWorld!""
4️⃣ TypeError が発生する","1️⃣ ""Hello World !""","🔹 join() メソッドとは？
join() メソッドは、リストやタプルの要素を特定の文字列で結合して、1つの文字列を作成する メソッドです。

書式：""区切り文字"".join(イテラブル)
　　・リストの各要素を ""区切り文字"" で結合する
　　・join() に渡すリストの要素はすべて文字列である必要がある（数値を含む場合はエラー）

✅ ポイント
✔️ join() は、リストの要素を1つの文字列に結合する
✔️ join() の前にある文字列（"" "" など）が区切り文字として使われる
✔️ リスト内の要素はすべて文字列である必要がある（数値が含まれるとエラー）

📌 異なる区切り文字を使う例
words = [""apple"", ""banana"", ""cherry""]

print("", "".join(words))  # ""apple, banana, cherry""
print("" - "".join(words))  # ""apple - banana - cherry""
print("""".join(words))  # ""applebananacherry""

📌 数値を含むとエラーになる
numbers = [1, 2, 3]
print(""-"".join(numbers))  # ❌ TypeError

✅ 数値がある場合は str() に変換すればOK
print(""-"".join(map(str, numbers)))  # ""1-2-3""

✅ 文字列のリストを結合する際は join() を使うのがベスト！",10,3,
53,"text = ""Hello, World!""
result = text.startswith(""Hello"")
print(result)

上記のコードを実行すると、出力される値は？
1️⃣ True
2️⃣ False
3️⃣ ""Hello""
4️⃣ TypeError が発生する","1️⃣ True","🔹 startswith() メソッドとは？
startswith() メソッドは、文字列が特定の文字列で始まっているかを判定するメソッド です。
結果は True または False になります。

書式：文字列.startswith(検索文字列)
　・検索文字列で始まっていれば True を返す
　・そうでなければ False を返す
　・オプションで開始位置 (start) と終了位置 (end) を指定できる

✅ ポイント
✔️ startswith() は、文字列が特定の単語で始まるかを判定する
✔️ 大文字・小文字の区別に注意！（""hello"" は False になる）
✔️ 開始位置・終了位置 (start, end) を指定すると、文字列の一部で判定できる

📌 start と end を指定する例
start は 0 から数える（ゼロインデックス） ので、例えば ""Hello, World!""[7] は ""W"" になります。

text = ""Hello, World!""

# 7文字目（インデックス7）以降で ""World"" から始まるか判定
print(text.startswith(""World"", 7))  # ✅ True（text[7] は ""W""）

# 7文字目以降で ""Hello"" から始まるか判定
print(text.startswith(""Hello"", 7))  # ❌ False（text[7] は ""W"" なので違う）

# 7文字目から12文字目（""World"" の範囲）で ""World"" から始まるか判定
print(text.startswith(""World"", 7, 12))  # ✅ True

# 7文字目から12文字目で ""Hello"" から始まるか判定
print(text.startswith(""Hello"", 7, 12))  # ❌ False（範囲に ""Hello"" がない）


📌 大文字・小文字の違いに注意
print(""Hello"".startswith(""hello""))  # ❌ False（大文字・小文字は区別される）
print(""Hello"".lower().startswith(""hello""))  # ✅ True（すべて小文字に変換）

✅ 文字列の判定を行うときに startswith() は便利！",1,2,
54,"text = ""  Hello, World!  ""
result = text.strip()
print(result)

上記のコードを実行すると、出力される文字列は？
1️⃣ "" Hello, World! ""
2️⃣ ""Hello, World!""
3️⃣ ""Hello, World! ""
4️⃣ TypeError が発生する","2️⃣ ""Hello, World!""","🔹 strip() メソッドとは？
strip() メソッドは、文字列の前後にある不要な空白や指定した文字を削除する メソッドです。
（デフォルトでは 前後のスペース、タブ、改行を削除 します。）

書式：

文字列.strip()  # 文字列の前後の空白を削除
文字列.strip(削除したい文字列)  # 指定した文字を前後から削除
strip()（引数なし） → 文字列の 前後の空白を削除
strip(削除したい文字列) → 指定した文字を削除

✅ ポイント
✔️ strip() は、文字列の前後にある不要な空白や改行を削除する
✔️ 文字列の中央のスペースはそのまま保持される
✔️ lstrip()（左側だけ削除）、rstrip()（右側だけ削除）もある

📌 左右どちらかの空白だけ削除したい場合
text = ""  Hello, World!  ""

print(text.lstrip())  # ""Hello, World!  ""  ← 左の空白だけ削除
print(text.rstrip())  # ""  Hello, World!""  ← 右の空白だけ削除

📌 特定の文字を削除したい場合
text = ""###Hello, World!###""
print(text.strip(""#""))  # ""Hello, World!""  ← #　を前後から削除

✅ 前後の不要な空白や文字を削除するときに strip() は便利！",1,2,
55,"text = ""Hello, World!""
result = text.replace(""World"", ""Python"")
print(result)

 上記のコードを実行すると、出力される文字列は？
1️⃣ ""Hello, World!""
2️⃣ ""Hello, Python!""
3️⃣ ""Hello, !""
4️⃣ TypeError が発生する","2️⃣ ""Hello, Python!""","🔹 replace() メソッドとは？
replace() メソッドは、文字列内の特定の部分を別の文字列に置き換える メソッドです。

書式：文字列.replace(置き換え対象の文字列, 置き換える文字列)
　・最初の引数 → 置き換えたい文字列
　・二番目の引数 → 置き換える文字列
　・元の文字列は変更されない（replace() は 新しい文字列を返す

✅ ポイント
✔️ replace() は、文字列の一部を新しい文字列に置き換える
✔️ 元の文字列 (text) は変更されず、新しい文字列が返る
✔️ 存在しない文字列を置き換えようとすると、元の文字列がそのまま返る

📌 部分置換の例
text = ""banana""
new_text = text.replace(""na"", ""xy"")
print(new_text)  # ""baxyxy""

📌 置換回数を指定する（最大 n 回だけ置換）
text = ""apple apple apple""
print(text.replace(""apple"", ""banana"", 2))  # ""banana banana apple""

✅ 文字列を編集するときに replace() はとても便利！",1,2,
56,"text = ""apple,banana,cherry""
result = text.split("","")
print(result)

上記のコードを実行すると、出力されるリストは？
1️⃣ [""apple,banana,cherry""]
2️⃣ [""apple"", ""banana"", ""cherry""]
3️⃣ (""apple"", ""banana"", ""cherry"")
4️⃣ TypeError が発生する","2️⃣ [""apple"", ""banana"", ""cherry""]","🔹 split() メソッドとは？
split() メソッドは、文字列を特定の区切り文字で分割し、リストとして返す メソッドです

書式：文字列.split(区切り文字)
　・区切り文字を基準に文字列を分割
　・結果はリストとして返される
　・デフォルトでは空白（"" ""）で分割

✅ ポイント
✔️ split(区切り文字) を使うと、文字列をリストに変換できる
✔️ デフォルト（split() のみ）では空白 "" "" で分割される
✔️ リストの要素は文字列として保持される（int にはならない）

📌 デフォルトの split()（空白で分割）
text = ""Hello World Python""
print(text.split())  # ['Hello', 'World', 'Python']

📌 改行 \n で分割
text = ""apple\nbanana\ncherry""
print(text.split(""\n""))  # ['apple', 'banana', 'cherry']

📌 最大 n 回だけ分割
text = ""one,two,three,four""
print(text.split("","", 2))  # ['one', 'two', 'three,four']

✅ 文字列を分割するときに split() は超便利！

",1,2,
57,"text1 = ""12345""
text2 = ""123abc""
print(text1.isdigit(), text2.isdigit())

上記のコードを実行すると、出力される値は？
1️⃣ True True
2️⃣ True False
3️⃣ False True
4️⃣ TypeError が発生する","2️⃣ True False","🔹 isdigit() メソッドとは？
isdigit() メソッドは、文字列がすべて数字（0～9）で構成されているかを判定する メソッドです。

書式：文字列.isdigit()
　・文字列がすべて数字なら True を返す
　・数字以外の文字（アルファベット、空白、記号など）が含まれると False を返す
　・-123 のような負の数は False（- が数字ではないため）
　・小数 (""12.3"") も False（. が数字ではないため）

✅ ポイント
✔️ isdigit() は、文字列がすべて数字で構成されているか判定する
✔️ 負の数（""-123""）や小数（""12.3""）は False になる
✔️ isnumeric() との違いも理解しておくとよい

📌 負の数や小数は False
print(""-123"".isdigit())  # ❌ False（`-` が数字ではない）
print(""12.3"".isdigit())  # ❌ False（`.` が数字ではない）

📌 isnumeric() との違い
print(""123"".isnumeric())  # ✅ True
print(""Ⅷ"".isnumeric())  # ✅ True（ローマ数字も `True`）
print(""12.3"".isnumeric())  # ❌ False（小数点があると `False`）
print(""-123"".isnumeric())　# ❌ False（負の数があると `False`）

✅ 整数のみを判定するなら isdigit()、ローマ数字なども含めるなら isnumeric() を使う！",1,2,
58,"text = ""42""
result = text.zfill(5)
print(result)

上記のコードを実行すると、出力される文字列は？
1️⃣ ""00042""
2️⃣ ""42000""
3️⃣ "" 42""
4️⃣ TypeError が発生する","1️⃣ ""00042""","🔹 zfill() メソッドとは？
zfill() メソッドは、指定した桁数になるように、文字列の先頭に 0 を埋める メソッドです。

書式：文字列.zfill(桁数)
・文字列の長さが 桁数 未満の場合 → 先頭に 0 を追加 して 桁数 になるようにする
・文字列の長さが 桁数 以上の場合 → 変更なし（そのまま）
・符号（+ や -）がある場合は、符号の後ろに 0 を追加 する

✅ ポイント
✔️ zfill(桁数) は、文字列を指定の長さにするため、左側に 0 を埋める
✔️ 元の文字列の長さが 桁数 以上の場合はそのまま変わらない
✔️ 符号（+ や -）がある場合は、符号の後に 0 を追加

📌 元の文字列がすでに長い場合
print(""123456"".zfill(5))  # ""123456""（元の長さが 5 以上なので変化なし）

📌 符号付きの数値
print(""+42"".zfill(5))  # ""+0042""
print(""-42"".zfill(5))  # ""-0042""

✅ 数値を桁そろえしたいときに zfill() は便利！",1,2,
59,"text = ""Hello""
result = text.ljust(10, ""-"")
print(result)

上記のコードを実行すると、出力される文字列は？
1️⃣ ""Hello-----""
2️⃣ ""-----Hello""
3️⃣ ""Hello ""
4️⃣ TypeError が発生する","1️⃣ ""Hello-----""","🔹 ljust() メソッドとは？
ljust() メソッドは、指定した幅になるように、文字列の右側に任意の文字を埋める メソッドです。

書式：文字列.ljust(幅, 埋める文字)
　・幅 → 文字列の最小長（この長さになるまで埋める）
　・埋める文字（省略可能） → 右側に追加する文字（デフォルトは "" ""（スペース））
　・元の文字列の長さが 幅 以上の場合は変更なし

✅ ポイント
✔️ ljust(幅, 埋める文字) は、指定の長さになるまで右側を埋める
✔️ デフォルトではスペース "" "" を埋める（ljust(10) は ""Hello     ""）
✔️ 既に 幅 以上の文字列には影響なし

📌 デフォルトの ljust()（スペースで埋める）
print(""Hello"".ljust(10))  # ""Hello     ""

📌 すでに長さが 幅 以上の場合
print(""Hello, World!"".ljust(10, ""-""))  # ""Hello, World!""（変更なし）

📌 右寄せ（rjust()）との比較
print(""Hello"".rjust(10, ""-""))  # ""-----Hello""

✅ 左揃えしたいときに ljust() は便利！",1,2,
60,"text = ""Python""
result = text.rjust(10, ""*"")
print(result)

上記のコードを実行すると、出力される文字列は？
1️⃣ ""Python****""
2️⃣ ""****Python""
3️⃣ ""Python ""
4️⃣ TypeError が発生する","2️⃣ ""****Python""","🔹 rjust() メソッドとは？
rjust() メソッドは、指定した幅になるように、文字列の左側に任意の文字を埋める メソッドです。

書式：文字列.rjust(幅, 埋める文字)
　・幅 → 文字列の最小長（この長さになるまで埋める）
　・埋める文字（省略可能） → 左側に追加する文字（デフォルトは "" ""（スペース））
　・元の文字列の長さが 幅 以上の場合は変更なし

✅ ポイント
✔️ rjust(幅, 埋める文字) は、指定の長さになるまで左側を埋める
✔️ デフォルトではスペース "" "" を埋める（rjust(10) は "" Python""）
✔️ 既に 幅 以上の文字列には影響なし

📌 デフォルトの rjust()（スペースで埋める）
print(""Python"".rjust(10))  # ""    Python""

📌 すでに長さが 幅 以上の場合
print(""Hello, World!"".rjust(10, ""-""))  # ""Hello, World!""（変更なし）

📌 左寄せ（ljust()）との比較
print(""Python"".ljust(10, ""*""))  # ""Python****""

✅ 右揃えしたいときに rjust() は便利！",1,2,
61,"text = ""Python""
result = text.center(10, ""-"")
print(result)

 上記のコードを実行すると、出力される文字列は？
1️⃣ ""-Python---""
2️⃣ ""--Python--""
3️⃣ ""---Python-""
4️⃣ TypeError が発生する","2️⃣ ""--Python--""","🔹 center() メソッドとは？
center() メソッドは、指定した幅の中央に文字列を配置し、両側に指定の文字を埋める メソッドです。

書式：文字列.center(幅, 埋める文字)
　・幅 → 文字列の最小長（この長さになるまで埋める）
　・埋める文字（省略可能） → 左右に追加する文字（デフォルトは "" ""（スペース））
　・文字列が中央に配置され、左右にバランスよく埋め文字が入る
　・元の文字列の長さが 幅 以上の場合は変更なし
　・埋める文字が奇数になる場合、左側の方が1文字多くなる

✅ ポイント
✔️ center(幅, 埋める文字) は、指定の長さになるまで中央に文字列を配置し、左右を埋める
✔️ デフォルトではスペース "" "" を埋める（center(10) は "" Python ""）
✔️ 元の文字列が 幅 以上の場合は変更なし
✔️ 埋める文字の数が奇数になる場合、左側が1文字多くなる

📌 デフォルトの center()（スペースで埋める）
print(""Python"".center(10))  # ""  Python  ""

📌 すでに長さが 幅 以上の場合
print(""Hello, World!"".center(10, ""-""))  # ""Hello, World!""（変更なし）

📌 埋める文字の影響（奇数の場合）
print(""Python"".center(11, ""-""))  # ""---Python--""

✅ 中央揃えしたいときに center() は便利！



",1,2,
62,"text = ""apple-banana-cherry""
result = text.partition(""-"")
print(result)

上記のコードを実行すると、出力される値は？
1️⃣ [""apple"", ""-"", ""banana-cherry""]
2️⃣ (""apple"", ""-"", ""banana-cherry"")
3️⃣ [""apple-banana"", ""-"", ""cherry""]
4️⃣ TypeError が発生す","2️⃣ (""apple"", ""-"", ""banana-cherry"")","🔹 partition() メソッドとは？
partition() メソッドは、指定した区切り文字が最初に現れる位置で文字列を3つの部分に分割し、タプルとして返す メソッドです。

書式：
文字列.partition(区切り文字)
戻り値はタプル (前半, 区切り文字, 後半)
最初に見つかった 区切り文字 だけで分割される（2回目以降は無視）
区切り文字 が見つからない場合は、(元の文字列, '', '') を返す

✅ ポイント
✔️ partition() は、指定した区切り文字が最初に現れる位置で文字列を3つの部分に分割する
✔️ 戻り値は タプル (前半, 区切り文字, 後半)
✔️ 区切り文字が見つからない場合、(元の文字列, '', '') となる

📌 区切り文字がない場合
print(""apple banana cherry"".partition(""-""))
# ('apple banana cherry', '', '')

📌 区切り文字が複数回出現しても、最初の1回だけで分割
print(""apple-banana-cherry"".partition(""-""))
# ('apple', '-', 'banana-cherry')  ← 2回目の `-` は無視

📌 逆方向から分割したい場合は rpartition()
print(""apple-banana-cherry"".rpartition(""-""))
# ('apple-banana', '-', 'cherry')  ← 最後の `-` で分割

✅ partition() は、最初の1回だけ分割したいときに便利！",1,2,
63,"text = ""apple-banana-cherry""
result = text.rpartition(""-"")
print(result)

上記のコードを実行すると、出力される値は？
1️⃣ (""apple"", ""-"", ""banana-cherry"")
2️⃣ (""apple-banana"", ""-"", ""cherry"")
3️⃣ [""apple-banana"", ""-"", ""cherry""]
4️⃣ TypeError が発生する","2️⃣ (""apple-banana"", ""-"", ""cherry"")","✅ ポイント
✔️ rpartition() は、指定した区切り文字が最後に現れる位置で文字列を3つに分割する
✔️ 戻り値は タプル (前半, 区切り文字, 後半)
✔️ 区切り文字が見つからない場合、('', '', 元の文字列) となる

📌 区切り文字がない場合
print(""apple banana cherry"".rpartition(""-""))
# ('', '', 'apple banana cherry')

📌 区切り文字が複数回出現しても、最後の1回だけで分割
print(""apple-banana-cherry"".rpartition(""-""))
# ('apple-banana', '-', 'cherry')  ← 最後の `-` で分割

📌 partition() との違い
print(""apple-banana-cherry"".partition(""-""))
# ('apple', '-', 'banana-cherry')  ← 最初の `-` で分割

print(""apple-banana-cherry"".rpartition(""-""))
# ('apple-banana', '-', 'cherry')  ← 最後の `-` で分割

✅ rpartition() は、最後の1回だけ分割したいときに便利！",1,2,
64,"text = ""banana""
result = text.count(""a"")
print(result)

上記のコードを実行すると、出力される値は？
1️⃣ 1
2️⃣ 2
3️⃣ 3
4️⃣ TypeError が発生する","3️⃣ 3","🔹 count() メソッドとは？
count() メソッドは、文字列内に指定した部分文字列が何回出現するかを数える メソッドです。

書式：文字列.count(検索文字列, 開始位置, 終了位置)
　・検索文字列 → 数えたい文字または文字列
　・開始位置（省略可能） → ここから検索（デフォルトは 0）
　・終了位置（省略可能） → ここまで検索（デフォルトは len(文字列)）

✅ ポイント
✔️ count(検索文字列) は、文字列内の出現回数を数える
✔️ 部分文字列（複数文字）もカウントできる
✔️ 検索範囲を指定する場合は count(検索文字列, 開始, 終了) を使う

📌 部分文字列をカウント
text = ""banana banana banana""
print(text.count(""banana""))  # ✅ 3

📌 検索範囲を指定
text = ""banana""
print(text.count(""a"", 2))  # ✅ 2（インデックス2以降の ""nana"" の中の ""a"" をカウント）
print(text.count(""a"", 2, 4))  # ✅ 1（""na"" の範囲で ""a"" をカウント）

📌 存在しない文字を検索
print(""banana"".count(""z""))  # ✅ 0（存在しないので0）

✅ 文字列内の回数をカウントするときに count() は便利！",1,2,
65,"text = ""banana""
result = text.find(""na"")
print(result)

上記のコードを実行すると、出力される値は？
1️⃣ 1
2️⃣ 2
3️⃣ 3
4️⃣ TypeError が発生する","2️⃣ 2","🔹 find() メソッドとは？
find() メソッドは、指定した部分文字列が最初に出現するインデックスを返す メソッドです。

書式：文字列.find(検索文字列, 開始位置, 終了位置)
　・検索文字列 → 探したい文字や部分文字列
　・開始位置（省略可能） → どこから検索するか（デフォルトは 0）
　・終了位置（省略可能） → どこまで検索するか（デフォルトは len(文字列)）
　・見つからなかった場合は -1 を返す

✅ ポイント
✔️ find(検索文字列) は、部分文字列が最初に見つかる位置を返す
✔️ 検索範囲を指定する場合は find(検索文字列, 開始, 終了) を使う
✔️ 見つからなかった場合は -1 を返す（None ではない！）

📌 検索範囲を指定
text = ""banana""
print(text.find(""na"", 3))  # ✅ 4（インデックス3以降で検索し、次の""na""の位置を返す）

📌 存在しない文字を検索
print(""banana"".find(""z""))  # ✅ -1（見つからない場合は `-1`）

📌 index() との違い
print(""banana"".index(""na""))  # ✅ 2
print(""banana"".find(""z""))  # ✅ -1
print(""banana"".index(""z""))  # ❌ ValueError（見つからないとエラーになる）

✅ 文字列の検索には find() が便利！（index() はエラーを出すので注意）",1,2,
66,"name = ""Alice""
age = 25
result = ""Name: {}, Age: {}"".format(name, age)
print(result)

上記のコードを実行すると、出力される文字列は？
1️⃣ ""Name: Alice, Age: 25""
2️⃣ ""Name: {}, Age: {}""
3️⃣ ""Name: Alice, Age: {age}""
4️⃣ TypeError が発生する","1️⃣ ""Name: Alice, Age: 25""","🔹 format() メソッドとは？
format() メソッドは、文字列のフォーマットを指定し、変数を埋め込むことができる メソッドです。

書式：""フォーマット文字列"".format(値1, 値2, ...)
　・{} の位置に format() の引数で渡された値 が挿入される
　・複数の {} を使うと、順番に値が埋め込まれる
　・引数のインデックスや名前を指定することも可能

✅ ポイント
✔️ format() は、文字列の {} に値を埋め込むメソッド
✔️ 複数の {} を使うと、順番に値が挿入される
✔️ インデックス指定や名前付きフォーマットも可能

📌 インデックスを指定
print(""Age: {1}, Name: {0}"".format(""Alice"", 25))
# ""Age: 25, Name: Alice""

📌 名前付きフォーマット
print(""Name: {name}, Age: {age}"".format(name=""Alice"", age=25))
# ""Name: Alice, Age: 25""

📌 f-strings（Python 3.6 以降推奨）
name = ""Alice""
age = 25
print(f""Name: {name}, Age: {age}"")
# ""Name: Alice, Age: 25""

✅ format() は古いスタイルだが、f-strings（f""...""）を使うとより簡潔！",1,2,
67,"text = ""Hello, World!""
result = text.swapcase()
print(result)

上記のコードを実行すると、出力される文字列は？
1️⃣ ""HELLO, WORLD!""
2️⃣ ""hello, world!""
3️⃣ ""hELLO, wORLD!""
4️⃣ TypeError が発生する","3️⃣ ""hELLO, wORLD!""","🔹 swapcase() メソッドとは？
swapcase() メソッドは、文字列内の大文字と小文字をすべて反転（スワップ）する メソッドです。

書式：文字列.swapcase()
　・大文字 (A-Z) は小文字 (a-z) に変換される
　・小文字 (a-z) は大文字 (A-Z) に変換される
　・数字や記号はそのまま変化しない

✅ ポイント
✔️ swapcase() は、すべての大文字を小文字に、小文字を大文字に変換する
✔️ 数字や記号はそのまま変化しない
✔️ 大文字小文字を区別しない検索や比較の前処理として使える

📌 すべて大文字の文字列
print(""PYTHON"".swapcase())  # ""python""

📌 すべて小文字の文字列
print(""python"".swapcase())  # ""PYTHON""

📌 数字や記号は変化しない
print(""123_abc_DEF!"".swapcase())  # ""123_ABC_def!""

✅ 文字列の大文字小文字を入れ替えたいときに swapcase() は便利！",1,2,
68,"text = ""Python programming""
result = text.startswith(""Py"")
print(result)

上記のコードを実行すると、出力される値は？
1️⃣ True
2️⃣ False
3️⃣ ""Py""
4️⃣ TypeError が発生する","1️⃣ True","🔹 startswith() メソッドとは？
startswith() メソッドは、文字列が特定の文字列で始まっているかを判定する メソッドです。
結果は True または False になります。

書式：文字列.startswith(検索文字列, 開始位置, 終了位置)
　・検索文字列 → 文字列の最初がこの文字列と一致しているかチェック
　・開始位置（省略可能） → 検索を開始する位置（デフォルトは 0）
　・終了位置（省略可能） → 検索を終了する位置（デフォルトは len(文字列)）
　・大文字・小文字は区別される！ (""py"" では False になる)

✅ ポイント
✔️ startswith() は、文字列が指定した単語で始まるかを判定する
✔️ 大文字・小文字の違いに注意！（""py"" では False になる）
✔️ 開始位置・終了位置を指定すると、文字列の一部で判定できる

📌 start と end を指定する例
text = ""Python programming""
print(text.startswith(""programming"", 7))  # ✅ True（7文字目から検索）
print(text.startswith(""Python"", 7))  # ❌ False（7文字目は ""p""）

📌 大文字・小文字の違い
print(""Python"".startswith(""py""))  # ❌ False（大文字・小文字は区別される）
print(""Python"".lower().startswith(""py""))  # ✅ True（すべて小文字に変換）

✅ 文字列の判定を行うときに startswith() は便利！",1,2,
69,"text = ""hello_world.py""
result = text.endswith("".py"")
print(result)

上記のコードを実行すると、出力される値は？
1️⃣ True
2️⃣ False
3️⃣ "".py""
4️⃣ TypeError が発生する","1️⃣ True","🔹 endswith() メソッドとは？
endswith() メソッドは、文字列が特定の文字列で終わっているかを判定する メソッドです。
結果は True または False になります。

書式：文字列.endswith(検索文字列, 開始位置, 終了位置)
　・検索文字列 → 文字列の末尾がこの文字列と一致しているかチェック
　・開始位置（省略可能） → 検索を開始する位置（デフォルトは 0）
　・終了位置（省略可能） → 検索を終了する位置（デフォルトは len(文字列)）
　・大文字・小文字は区別される！ ("".PY"" では False になる)

✅ ポイント
✔️ endswith() は、文字列が指定した単語で終わるかを判定する
✔️ 大文字・小文字の違いに注意！（"".PY"" では False になる）
✔️ 開始位置・終了位置を指定すると、文字列の一部で判定できる

📌 start と end を指定する例
text = ""hello_world.py""
print(text.endswith(""world"", 0, 11))  # ✅ True（インデックス0-11の範囲で ""world"" で終わる）
print(text.endswith("".py"", 0, 10))  # ❌ False（10文字目までの範囲では "".py"" はない）

📌 複数のパターンを指定できる
print(""document.txt"".endswith(("".txt"", "".csv"", "".pdf"")))  # ✅ True
print(""image.jpg"".endswith(("".png"", "".gif"")))  # ❌ False

✅ ファイル拡張子のチェックや文字列の末尾判定を行うときに endswith() は便利！",1,2,
70,"text = ""hello world""
result = text.capitalize()
print(result)

上記のコードを実行すると、出力される文字列は？
1️⃣ ""Hello World""
2️⃣ ""Hello world""
3️⃣ ""HELLO WORLD""
4️⃣ TypeError が発生する","1️⃣ ""Hello World""","🔹 capitalize() メソッドとは？
capitalize() メソッドは、文字列の最初の文字を大文字にし、残りの文字をすべて小文字に変換する メソッドです。

書式：
文字列.capitalize()
最初の1文字を大文字にする
2文字目以降のアルファベットはすべて小文字に変換される
元の文字列がすべて小文字や大文字の場合も適用される

✅ ポイント
✔️ capitalize() は、最初の1文字を大文字、残りをすべて小文字にする
✔️ 単語ごとに大文字にするわけではない！（タイトルケースではない）
✔️ すべて大文字だった場合も、小文字に変換される

📌 全大文字の文字列
print(""PYTHON IS FUN"".capitalize())  
# ""Python is fun""（最初の P だけ大文字、残りは小文字）

📌 単語ごとに大文字にしたい場合は title() を使う
print(""hello world"".title())  
# ""Hello World""（各単語の最初の文字が大文字）

✅ 文章の先頭を大文字にしたいときに capitalize() は便利！",1,2,
71,"text = ""python is fun""
result = text.title()
print(result)

上記のコードを実行すると、出力される文字列は？
1️⃣ ""Python Is Fun""
2️⃣ ""Python is Fun""
3️⃣ ""PYTHON IS FUN""
4️⃣ TypeError が発生する","1️⃣ ""Python Is Fun""","🔹 title() メソッドとは？
title() メソッドは、文字列の各単語の最初の文字を大文字にし、それ以外の文字を小文字にする メソッドです。

書式：文字列.title()
　・各単語の先頭文字を大文字に変換
　・それ以外の文字は小文字になる
　・単語の区切りは、スペース・記号（- や _）で認識される

✅ ポイント
✔️ title() は、各単語の最初の文字を大文字に、それ以外を小文字にする
✔️ 単語の区切りはスペース・ハイフン (-)・アンダースコア (_) も認識される
✔️ 特殊なケースでは期待通りの動作をしない場合もある（次の例を参照）

📌 ハイフンやアンダースコアも考慮
print(""hello-world_example"".title())  
# ""Hello-World_Example""（`-` や `_` で区切られた単語の先頭が大文字になる）

📌 すでに大文字が含まれる場合
print(""python IS fun"".title())  
# ""Python Is Fun""（すべて小文字 → タイトルケース）

📌 英単語の途中に大文字がある場合、意図しない変換になることも
print(""iPhone is cool"".title())  
# ""Iphone Is Cool""（`iPhone` の `P` も小文字になってしまう）

✅ 英単語の表記が崩れる可能性があるので、title() は慎重に使う！",1,2,
72,"text1 = ""Python""
text2 = ""Python3""
print(text1.isalpha(), text2.isalpha())

上記のコードを実行すると、出力される値は？
1️⃣ True True
2️⃣ True False
3️⃣ False True
4️⃣ TypeError が発生する","2️⃣ True False","🔹 isalpha() メソッドとは？
isalpha() メソッドは、文字列がすべてアルファベット（A～Z, a～z）のみで構成されているかを判定する メソッドです。

書式：文字列.isalpha()
　・アルファベットのみ → True
　・数字、記号、空白が含まれる場合 → False

✅ ポイント
✔️ isalpha() は、文字列がすべてアルファベットなら True を返す
✔️ 数字や記号が含まれると False になる
✔️ 空文字（""""）でも False になる

📌 数字が含まれる場合
print(""hello123"".isalpha())  # ❌ False（数字がある）

📌 記号やスペースが含まれる場合
print(""hello world"".isalpha())  # ❌ False（スペースがある）
print(""hello!"".isalpha())  # ❌ False（`!` がある）

📌 すべてアルファベットなら True
print(""HelloWorld"".isalpha())  # ✅ True

✅ 英単語のバリデーション（文字だけか確認）に isalpha() は便利！
",1,2,
73,"text1 = ""12345""
text2 = ""12.34""
print(text1.isdigit(), text2.isdigit())

上記のコードを実行すると、出力される値は？
1️⃣ True True
2️⃣ True False
3️⃣ False True
4️⃣ TypeError が発生する","2️⃣ True False","🔹 isdigit() メソッドとは？
isdigit() メソッドは、文字列がすべて数字（0～9）のみで構成されているかを判定する メソッドです。

書式：文字列.isdigit()
　・整数（0～9 のみ）なら True
　・小数 (""."")、負の数 (""-"")、空白が含まれると False
　・空文字列 ("""") でも False になる

✅ ポイント
✔️ isdigit() は、整数のみで構成されているかを判定する
✔️ 小数 (""."")、負の数 (""-"")、空白 ("" "") が含まれると False
✔️ 整数のバリデーション（整数かどうかチェック）に使える

📌 小数や負の数は False
print(""-123"".isdigit())  # ❌ False（`-` が含まれる）
print(""12.3"".isdigit())  # ❌ False（`.` が含まれる）

📌 スペースが含まれている場合も False
print(""123 45"".isdigit())  # ❌ False（空白が含まれる）

📌 isnumeric() との違い
print(""123"".isnumeric())  # ✅ True
print(""Ⅷ"".isnumeric())  # ✅ True（ローマ数字も `True`）
print(""12.3"".isnumeric())  # ❌ False（小数点があると `False`）

✅ 整数のみを判定するなら isdigit()、ローマ数字なども含めるなら isnumeric() を使う！",1,2,
74,"text1 = ""   ""
text2 = "" a ""
print(text1.isspace(), text2.isspace())

上記のコードを実行すると、出力される値は？
1️⃣ True True
2️⃣ True False
3️⃣ False True
4️⃣ False False","2️⃣ True False","🔹 isspace() メソッドとは？
isspace() メソッドは、文字列がすべて空白文字（スペース、タブ、改行など）で構成されているかを判定する メソッドです。

書式：文字列.isspace()
　・すべて空白文字（"" ""、\t、\n など）なら True
　・1文字でも空白以外の文字が含まれると False
　・空文字列（""""）は False

✅ ポイント
✔️ isspace() は、文字列がすべて空白文字（スペース、タブ、改行）で構成されているか判定する
✔️ 1文字でもアルファベットや数字などが含まれると False
✔️ 空文字（""""）は False

📌 空白だけの文字列
print("" \t\n"".isspace())  # ✅ True（スペース、タブ、改行だけなので True）

📌 1文字でも空白以外がある場合
print(""  a  "".isspace())  # ❌ False（`a` がある）
print(""123"".isspace())  # ❌ False（数字がある）

📌 空文字は False
print("""".isspace())  # ❌ False（空文字は空白ではない）

✅ 文字列が空白だけかどうかを判定するときに isspace() は便利！",1,2,
75,"text1 = ""HELLO""
text2 = ""Hello""
print(text1.isupper(), text2.isupper())

上記のコードを実行すると、出力される値は？
1️⃣ True True
2️⃣ True False
3️⃣ False True
4️⃣ False False","2️⃣ True False","🔹 isupper() メソッドとは？
isupper() メソッドは、文字列がすべて大文字で構成されているかを判定する メソッドです。

書式：文字列.isupper()
　・すべてのアルファベットが大文字なら True
　・1文字でも小文字が含まれていると False
　・記号や数字は判定に影響しない
　・空文字（""""）は False

✅ ポイント
✔️ isupper() は、文字列がすべて大文字なら True を返す
✔️ 小文字が1つでも含まれると False
✔️ 記号や数字は判定に影響しない（無視される）
✔️ 空文字（""""）は False

📌 数字や記号を含んでも大文字なら True
print(""HELLO123!"".isupper())  # ✅ True（アルファベット部分はすべて大文字）

📌 1文字でも小文字があると False
print(""HELLO world"".isupper())  # ❌ False（""world"" が小文字）

📌 空文字は False
print("""".isupper())  # ❌ False（何もない）

📌 islower() との比較
print(""hello"".islower())  # ✅ True（すべて小文字）
print(""Hello"".islower())  # ❌ False（""H"" が大文字）

✅ 文字列がすべて大文字かどうかを判定するときに isupper() は便利！",1,2,
76,"text1 = ""hello""
text2 = ""Hello""
print(text1.islower(), text2.islower())

上記のコードを実行すると、出力される値は？
1️⃣ True True
2️⃣ True False
3️⃣ False True
4️⃣ False False","2️⃣ True False","🔹 islower() メソッドとは？
islower() メソッドは、文字列がすべて小文字で構成されているかを判定する メソッドです。

書式：文字列.islower()
　・すべてのアルファベットが小文字なら True
　・1文字でも大文字が含まれていると False
　・記号や数字は判定に影響しない
　・空文字（""""）は False

✅ ポイント
✔️ islower() は、文字列がすべて小文字なら True を返す
✔️ 大文字が1つでも含まれると False
✔️ 記号や数字は無視される（影響しない）
✔️ 空文字（""""）は False

📌 数字や記号を含んでも小文字なら True
print(""hello123!"".islower())  # ✅ True（アルファベット部分はすべて小文字）

📌 1文字でも大文字があると False
print(""hello World"".islower())  # ❌ False（""W"" が大文字）

📌 空文字は False
print("""".islower())  # ❌ False（何もない）

📌 isupper() との比較
print(""HELLO"".isupper())  # ✅ True（すべて大文字）
print(""Hello"".isupper())  # ❌ False（""e"" 以下が小文字）

✅ 文字列がすべて小文字かどうかを判定するときに islower() は便利！",1,2,
77,"words = [""Python"", ""is"", ""fun""]
result = "" "".join(words)
print(result)

上記のコードを実行すると、出力される文字列は？
1️⃣ ""Python is fun""
2️⃣ [""Python"", ""is"", ""fun""]
3️⃣ ""Pythonisfun""
4️⃣ TypeError が発生する","1️⃣ ""Python is fun""","🔹 join() メソッドとは？
join() メソッドは、リストやタプルの要素を1つの文字列として連結する メソッドです。

書式：""区切り文字"".join(イテラブル)
　・""区切り文字"" の部分に、各要素をつなぐ文字列を指定
　・リストやタプルなどのイテラブル（繰り返し可能なオブジェクト）を連結
　・各要素は文字列である必要がある（数値はエラーになる）

✅ ポイント
✔️ join() は、リストやタプルの要素を1つの文字列として連結する
✔️ 数値 (int) を含むリストには使えない（TypeError になる）
✔️ 空文字 """" を使うと、要素をそのまま連結できる

📌 カンマ区切りの文字列を作る
words = [""apple"", ""banana"", ""cherry""]
print("", "".join(words))  # ""apple, banana, cherry""

📌 数値を含むリストはエラー
nums = [1, 2, 3]
print("" "".join(nums))  # ❌ TypeError（数値は結合できない）

# 文字列に変換すればOK
print("" "".join(map(str, nums)))  # ✅ ""1 2 3""

📌 """" を使うとスペースなしで連結
chars = [""P"", ""y"", ""t"", ""h"", ""o"", ""n""]
print("""".join(chars))  # ""Python""

✅ リストの文字列をつなげるときに join() は便利！

",1,2,
78,"text = ""apple,banana,cherry""
result = text.split("","")
print(result)

上記のコードを実行すると、出力される値は？
1️⃣ [""apple"", ""banana"", ""cherry""]
2️⃣ (""apple"", ""banana"", ""cherry"")
3️⃣ ""apple banana cherry""
4️⃣ TypeError が発生する","1️⃣ [""apple"", ""banana"", ""cherry""]","🔹 split() メソッドとは？
split() メソッドは、文字列を指定した区切り文字で分割し、リストとして返す メソッドです。

書式：文字列.split(区切り文字, 最大分割数)
　・区切り文字 → 分割に使用する文字列（省略すると スペースで分割 する）
　・最大分割数（省略可能） → 最大で何回まで分割するか（デフォルトはすべて分割）
　・戻り値はリスト（list）

✅ ポイント
✔️ split() は、指定した区切り文字で分割し、リストとして返す
✔️ デフォルト（区切り文字なし）の場合は、スペースで分割する
✔️ 分割回数を制限する maxsplit を指定できる

📌 デフォルトではスペースで分割
print(""Hello world Python"".split())  # ✅ [""Hello"", ""world"", ""Python""]

📌 最大分割回数を指定
text = ""apple,banana,cherry,grape""
print(text.split("","", 2))  # ✅ [""apple"", ""banana"", ""cherry,grape""]

📌 存在しない区切り文字を指定すると？
print(""apple banana cherry"".split("",""))  # ✅ [""apple banana cherry""]（分割されない）

📌 複数の空白をまとめて区切る
print(""  apple   banana  cherry  "".split())  
# ✅ [""apple"", ""banana"", ""cherry""]（複数スペースは無視される）

✅ 文字列をリストに変換するときに split() は便利！",1,2,
79,"text = ""I love Python. Python is fun!""
result = text.replace(""Python"", ""Java"")
print(result)

上記のコードを実行すると、出力される値は？
1️⃣ ""I love Java. Java is fun!""
2️⃣ ""I love Java. Python is fun!""
3️⃣ ""I love Python. Java is fun!""
4️⃣ TypeError が発生する","1️⃣ ""I love Java. Java is fun!""","🔹 replace() メソッドとは？
replace() メソッドは、文字列の中の特定の文字列を、別の文字列に置き換える メソッドです。

書式：
文字列.replace(置き換え対象, 置き換え後の文字列, 置き換える回数)
置き換え対象 → 変更したい部分文字列
置き換え後の文字列 → 新しく置き換える文字列
置き換える回数（省略可能） → 何回置き換えるか指定（デフォルトはすべて置き換える）

✅ ポイント
✔️ replace() は、文字列の一部を置き換えるメソッド
✔️ デフォルトでは、すべての一致する部分を置き換える
✔️ 回数 を指定すると、指定回数分だけ置き換える

📌 特定の回数だけ置き換える
text = ""Python Python Python""
print(text.replace(""Python"", ""Java"", 2))  
# ✅ ""Java Java Python""（2回だけ置き換え）

📌 部分一致のみを置き換える
text = ""apple apple apple""
print(text.replace(""apple"", ""banana"", 1))  
# ✅ ""banana apple apple""（最初の1回だけ置き換え）

📌 存在しない文字列を置き換えてもエラーにならない
print(""hello world"".replace(""Python"", ""Java""))  
# ✅ ""hello world""（""Python"" はないので変化なし）

✅ 文字列の編集・データクレンジングに replace() は便利！",1,2,
80,"text = ""42""
result = text.rjust(5, ""0"")
print(result)

上記のコードを実行すると、出力される値は？
1️⃣ ""00042""
2️⃣ ""42 ""
3️⃣ "" 42""
4️⃣ TypeError が発生する","1️⃣ ""00042""","🔹 rjust() メソッドとは？
rjust() メソッドは、文字列を指定した幅に右寄せし、必要な場合は左側を指定した文字で埋める メソッドです。

書式：文字列.rjust(幅, 文字)
　・幅 → 文字列の最小の長さ（これより短い場合は左側に埋める）
　・文字（省略可能） → 埋める文字（デフォルトはスペース "" ""）
　・埋める文字は 1文字のみ指定可能（2文字以上指定すると TypeError）

実は 先頭を 0 で埋める なら zfill() を使うのが一般的！
✅ 数値の0埋めには zfill() を使うのがベスト！",1,2,
81,"result = divmod(17, 5)
print(result)

上記のコードを実行すると、出力される値は？
1️⃣ (3, 2)
2️⃣ (3.4, 2)
3️⃣ (3, 2.0)
4️⃣ TypeError が発生する","1️⃣ (3, 2)","🔹 divmod() 関数とは？
divmod() は、整数の「商」と「余り」を同時に取得できる関数 です。

書式：divmod(被除数, 除数)
　・被除数 ÷ 除数 の 商（整数部分）と 余り を タプル (商, 余り) で返す
　・//（整数除算）と %（剰余演算）の両方をまとめて計算
　・浮動小数点数 float でも使用可能（ただし結果も float になる）

✅ divmod() のポイント
✔️ 整数（int）同士なら (商, 余り) のタプルを返す
✔️ 浮動小数点数（float）を使うと 商 も float になる
✔️ // と % を同時に計算するので、計算効率が良い

📌 通常の商 (//) と余り (%) を使った計算
a, b = 17, 5
print(a // b, a % b)  # ✅ 3 2
print(divmod(a, b))   # ✅ (3, 2)

📌 浮動小数点数を使う
print(divmod(17.5, 4))  # ✅ (4.0, 1.5)（商も `float` になる）

📌 ゼロ除算はエラー
print(divmod(10, 0))  # ❌ ZeroDivisionError（0 で割ることはできない）

✅ 商と余りを同時に求めるとき divmod() は便利！",1,2,
82,"a = 6  # 0b0110
b = 3  # 0b0011
result = a & b
print(result)

上記のコードを実行すると、出力される値は？
1️⃣ 6
2️⃣ 3
3️⃣ 2 
4️⃣ TypeError が発生する","3️⃣ 2 ","🔹 &（ビット単位の AND 演算）とは？
ビット単位の AND 演算は、2つの数値の各ビットごとに、両方が 1 の場合のみ 1 を返す 演算です。

🔹 コードの動作
a = 6  # 0b0110
b = 3  # 0b0011
result = a & b
print(result)

📌 2進数で表すと
  0110  (6)
& 0011  (3)
------------
  0010  (2)

👉 共通して 1 なのは 2番目のビットだけ！
➡ 結果は 0b0010（= 2） になる！

✅ ビット演算のポイント
✔️ &（AND） → 両方のビットが 1 のときだけ 1
✔️ |（OR） → どちらかのビットが 1 のとき 1
✔️ ^（XOR） → どちらか一方が 1 のとき 1（両方 1 のとき 0）
✔️ ~（NOT） → ビットを反転する（補数演算）

📌 他のビット演算例
print(6 | 3)  # ✅ 0b0111（7） → OR演算
print(6 ^ 3)  # ✅ 0b0101（5） → XOR演算
print(~6)     # ✅ -7（NOT演算：1の補数）

✅ ビット演算は、ビットマスクや低レベルの処理でよく使われる！
",1,2,
83,"a = 5  # 0b0101
b = 3  # 0b0011
result = a | b
print(result)

上記のコードを実行すると、出力される値は？
1️⃣ 0b0111（7）
2️⃣ 0b0011（3）
3️⃣ 0b0101（5）
4️⃣ TypeError が発生する","1️⃣ 0b0111（7）","🔹 |（ビット単位 OR 演算）とは？
ビット単位の OR（|） 演算は、
👉 「どちらかのビットが 1 の場合 1」になる演算 です！

🔹 コードの動作
a = 5  # 0b0101
b = 3  # 0b0011
result = a | b
print(result)

📌 10進数 → 2進数 に変換
  0101  (5)
| 0011  (3)
------------
  0111  (7)
👉 どちらかが 1 なら 1 になる！

✅ |（OR 演算）のポイント
✔️ どちらかのビットが 1 なら 1 になる（ビットを立てる）
✔️ フラグの設定や、特定のビットを ON にするのに便利！
✔️ ネットワーク設定や権限管理などでよく使われる！

📌 フラグ設定に応用
READ  = 0b100  # 4
WRITE = 0b010  # 2
EXEC  = 0b001  # 1

user_permission = READ | WRITE  # ✅ 0b110（読取 + 書込 許可）
print(bin(user_permission))  # ✅ 0b110

✅ 特定のビットを「ON」にする用途に便利！

",1,2,
84,"a = 5  # 0b0101
b = 3  # 0b0011
result = a ^ b
print(result)

上記のコードを実行すると、出力される値は？
1️⃣ 0b0111（7）
2️⃣ 0b0011（3）
3️⃣ 0b0101（5）
4️⃣ 0b0110（6） ","4️⃣ 0b0110（6） ","🔹 ^（ビット XOR 演算）とは？
XOR（^）演算 は、
👉 「どちらか一方が 1 のとき 1、両方 0 または 1 のとき 0」になる演算 です！

🔹 コードの動作
  0101  (5)
^ 0011  (3)
------------
  0110  (6)
👉 どちらか一方が 1 のとき 1 になる！

✅ ^（XOR 演算）のポイント
✔️ 「どちらか一方が 1 のときだけ 1」になる
✔️ 同じ値を XOR すると 0 になる（暗号技術やチェックサムで利用）
✔️ 特定のビットを反転させるために使われる

📌 値の入れ替え（スワップ）に使う
a = 5
b = 3

a = a ^ b
b = a ^ b
a = a ^ b

print(a, b)  # ✅ 3, 5（入れ替わる）

📌 同じ値を 2回 XOR すると元に戻る
x = 7
key = 42

encrypted = x ^ key  # 暗号化
decrypted = encrypted ^ key  # 復号（元に戻る）

print(decrypted)  # ✅ 7

✅ XOR は、暗号技術やデータのハッシュ化に使われることが多い！",1,2,
85,"a = 5  # 0b0101
result = ~a
print(result)

上記のコードを実行すると、出力される値は？
1️⃣ 0b1010（10）
2️⃣ 0b1011（11）
3️⃣ 0b1111（-6）
4️⃣ 0b1010（-6）
","4️⃣ 0b1010（-6）","🔹 ~（ビット単位 NOT 演算）とは？
ビット単位の NOT（~） 演算は、
👉 「すべてのビットを反転させる（0→1、1→0）」 という演算です！

📌 ~a の計算ルール
~a は、「a の 1 の補数（ビット反転）」 を求める演算
Python の整数は「2の補数」形式 で表現されるので、~a は -(a+1) になる！

✅ ~（NOT 演算）のポイント
✔️ ビットをすべて反転させる（0→1、1→0）
✔️ Python では「2の補数」形式なので -(a+1) になる
✔️ マスク処理やビット演算を活用する場面で使われる

📌 負の数になる理由（2の補数の仕組み）
~5 = -(5 + 1) = -6
~10 = -(10 + 1) = -11

print(~5)  # ✅ -6
print(~10)  # ✅ -11

📌 ビット演算を使ったマスク処理
mask = 0b1111  # 4ビットマスク
value = 0b0101
print(bin(value & ~mask))  # ✅ 0b0000（すべてクリア）

✅ 負の数のビット表現を知っておくと、ビット演算の理解が深まる！

",1,2,
86,"result = int(""1010"", 2)
print(result)

上記のコードを実行すると、出力される値は？
1️⃣ 2
2️⃣ 5
3️⃣ 10
4️⃣ 1010（文字列のまま）","3️⃣ 10","📌 int() の基数変換とは？
この int() は、文字列 ""1010"" を 2進数（2）として解釈し、10進数に変換する という処理をしています！
👉 つまり、""1010""（2進数）を 10進数に変換すると 10 になる！ 

📌 int(文字列, 基数) の基本ルール
int(文字列, 基数) を使うと、さまざまな進数を 10進数に変換できる！

✅ 2進数 → 10進数
print(int(""1010"", 2))  # ✅ 10
print(int(""1111"", 2))  # ✅ 15

✅ 8進数 → 10進数
print(int(""12"", 8))  # ✅ 10（8進数の ""12"" は、10進数で 10）

✅ 16進数 → 10進数
print(int(""A"", 16))  # ✅ 10（16進数の ""A"" は 10）
print(int(""FF"", 16))  # ✅ 255

✅ 基数 36 まで対応可能！
print(int(""Z"", 36))  # ✅ 35（""Z"" は 36進数で 35）
print(int(""10"", 36))  # ✅ 36（""10"" は 36進数で 36）

📌 int() の便利な使い方
🔹 0b をつけなくても 2進数を変換できる
print(int(""1101"", 2))  # ✅ 13

🔹 int() を使って、10進数 → 他の進数に変換
num = int(""42"")  # 文字列 ""42"" を 10進数の 42 に変換
print(bin(num))  # ✅ ""0b101010""（2進数）
print(oct(num))  # ✅ ""0o52""（8進数）
print(hex(num))  # ✅ ""0x2a""（16進数）

🔹 int() を使って、ユーザー入力を数値に変換
binary_input = input(""2進数を入力してください: "")  # 例: ""1010""
decimal_value = int(binary_input, 2)
print(decimal_value)  # ✅ 10

📌 まとめ
✅ int(文字列, 基数) を使うと、他の進数から10進数に変換できる！
✅ int(""1010"", 2) は 2進数 ""1010"" を 10進数に変換 → 10 になる！
✅ bin(), oct(), hex() を使うと、10進数を別の進数に変換できる！",1,2,
87,"print(bool(""False""))

上記のコードを実行すると、出力される値は？
1️⃣ False
2️⃣ True
3️⃣ ""False""（文字列のまま）
4️⃣ None","2️⃣ True","🔹 bool() とは？
bool() は、値を True または False に変換する関数 です！
Python では、以下のようなルールで値が True か False に変換されます。

📌 bool() の基本ルール
✅ 「空でない値」は True になる！
✅ 「空の値・0・None」は False になる！

📌 bool() の判定例
print(bool(1))        # ✅ True
print(bool(0))        # ✅ False
print(bool(""Hello""))  # ✅ True（空でない文字列）
print(bool(""""))       # ✅ False（空文字列）
print(bool(None))     # ✅ False
print(bool([]))       # ✅ False（空リスト）
print(bool([0]))      # ✅ True（リストに要素があれば True）

📌 コードの動作
print(bool(""False""))
👉 ""False"" は「空でない文字列」なので True になる！

📌 よくある勘違い
""False"" という 「文字列」 は False ではなく、単なる文字データ。
Python の bool() は 「文字列が空かどうか」で判定する ので、 ""False"" でも True になる！

✅ bool() のポイント
✔ 「空でない文字列」は True（たとえ ""False"" でも！）
✔ 数値 0 や None、空のリスト・タプル・辞書は False
✔ リストや辞書に要素が入っていれば True

📌 bool() を使った条件分岐
name = ""Alice""
if name:
    print(""名前があります！"")  # ✅ 出力される
else:
    print(""名前がありません！"")

✅ if name: は bool(name) == True と同じ意味！",1,1,
88,"print(bool([]))

上記のコードを実行すると、出力される値は？
1️⃣ True
2️⃣ False
3️⃣ []（リストのまま）
4️⃣ None","2️⃣ False","🔹 bool() の基本ルール
bool() は、引数の値を True または False に変換する関数 です。
Python では、以下のようなルールで True か False が決まります。

✅ 「空でない値」は True になる！
✅ 「空の値・0・None」は False になる！

📌 コードの動作
print(bool([]))
👉　[]（空リスト）は「空の値」とみなされるので False になる！
📌 よくある勘違い
print(bool([0]))  # ✅ True（リストに `0` があっても、空ではないので True）
👉 リスト自体が空 ([]) なら False だが、要素が1つでも入っていれば True！

✅ bool() のポイント
✔ 空リスト [] は False になる！
✔ リストに何か入っていれば True（たとえ 0 だけでも！）
✔ 同じルールで、空の辞書 {} や空のタプル () も False！

📌 例: bool() を使った条件分岐
items = []
if items:
    print(""リストに要素があります！"")
else:
    print(""リストは空です！"")  # ✅ 出力される
✅ if items: は bool(items) == True と同じ意味！

",1,1,
89,"print(bool(0.0))

上記のコードを実行すると、出力される値は？
1️⃣ True
2️⃣ False
3️⃣ 0.0（浮動小数点のまま）
4️⃣ None","2️⃣ False","🔹 bool() の基本ルール
bool() は、引数の値を True または False に変換する関数 です。
Python では、以下のようなルールで True か False が決まります。

✅ 「空でない値」は True になる！
✅ 「空の値・0・None」は False になる！

📌 コードの動作
print(bool(0.0))
👉 0.0 は 0（ゼロ）と同じ扱いなので、False になる！

📌 よくある勘違い
print(bool(0.1))  # ✅ True（0以外の数値はすべて True）
print(bool(-0.1)) # ✅ True（負の数でも 0 以外なら True）
👉 0.0 だけが False になる！

✅ bool() のポイント
✔ 0 や 0.0 は False になる！
✔ 0 以外の数値（正数・負数）は True！
✔ 空の値 (None, [], {}, """") も False になる！

📌 例: bool() を使った条件分岐
value = 0.0
if value:
    print(""値があります！"")
else:
    print(""値はゼロです！"")  # ✅ 出力される

✅ if value: は bool(value) == True と同じ意味",1,1,
90,"print(bool(None))

上記のコードを実行すると、出力される値は？
1️⃣ True
2️⃣ False
3️⃣ ""None""（文字列のまま）
4️⃣ 0","2️⃣ False","🔹 bool() の基本ルール
Python の bool() は、引数の値を True または False に変換する関数 です。
✅ 「空でない値」は True になる！
✅ 「空の値・0・None」は False になる！

📌 コードの動作
python
コピーする
編集する
print(bool(None))
👉 None は「値が存在しない」ことを意味する特殊なオブジェクトなので、False になる！

📌 よくある勘違い
print(bool(""None""))  # ✅ True（文字列 ""None"" は空ではないので True）
print(bool(0))       # ✅ False（ゼロは False）
👉 None そのものは False だが、 ""None"" という文字列は True になる！

✅ bool() のポイント
✔ None は False になる！
✔ None は Python の「値がない」ことを示す特別なオブジェクト！
✔ 文字列 ""None"" や 0 以外の数値は True になる！

📌 例: bool() を使った条件分岐
value = None
if value:
    print(""値があります！"")
else:
    print(""値がありません！"")  # ✅ 出力される

✅ if value: は bool(value) == True と同じ意味！",1,1,
91,"num = 42
text = str(num)
print(text)

上記のコードを実行すると、出力される値は？
1️⃣ 42（整数のまま）
2️⃣ ""42""（文字列に変換）
3️⃣ Error（エラーが発生する）
4️⃣ None","2️⃣ ""42""（文字列に変換）","🔹 str() とは？
str() は、引数の値を 文字列（str 型）に変換する関数 です！
✅ 数値 → 文字列に変換できる
✅ リストや辞書などのデータ構造も文字列にできる

✅ str() のポイント
✔ 数値を文字列に変換できる！
✔ リストや辞書も str() を使えば文字列にできる！

📌 例: str() を使った文字列結合
age = 25
message = ""私は "" + str(age) + "" 歳です。""
print(message)  # ✅ ""私は 25 歳です。""

👉 str() を使わないと、数値と文字列を + で連結できない！",1,1,
92,"text = ""123""
num = int(text)
print(num)

上記のコードを実行すると、出力される値は？
1️⃣ 123（整数に変換）
2️⃣ ""123""（文字列のまま）
3️⃣ Error（エラーが発生する）
4️⃣ None","1️⃣ 123（整数に変換","🔹 int() とは？
int() は、引数の値を 整数（int 型）に変換する関数 です！
✅ 文字列で表された数値を整数に変換できる！
✅ 浮動小数点や2進数・16進数の文字列も変換できる！

✅ int() のポイント
✔ ""123"" のような数値の文字列を整数に変換できる！
✔ 小数 (""12.3"") は int() で変換できずエラーが出る！
✔ int(""1010"", 2) のように基数を指定すれば、2進数や16進数も変換可能！

📌 例: int() を使った型変換
# 数値の文字列を整数に変換
num = int(""42"")
print(num)  # ✅ 42（整数）

# 2進数の文字列を整数に変換
binary_num = int(""1010"", 2)
print(binary_num)  # ✅ 10（10進数）

# 16進数の文字列を整数に変換
hex_num = int(""A"", 16)
print(hex_num)  # ✅ 10（10進数）

👉 int() は基数（2進数, 8進数, 16進数）を指定して変換できる！",1,1,
93,"text = ""3.14""
num = float(text)
print(num)

上記のコードを実行すると、出力される値は？
1️⃣ 3.14（浮動小数点数に変換）
2️⃣ ""3.14""（文字列のまま）
3️⃣ Error（エラーが発生する）
4️⃣ None","1️⃣ 3.14（浮動小数点数に変換）","🔹 float() とは？
float() は、引数の値を 浮動小数点数（float 型）に変換する関数 です！
✅ 文字列の数値 ""3.14"" を float に変換できる！
✅ 整数も float に変換すると .0 が付く！
✅ 指数表記 (""1e3"") も float に変換可能！

✅ float() のポイント
✔ ""3.14"" のような数値の文字列を float に変換できる！
✔ 整数も float にすると 10 → 10.0 のように変換される！
✔ 指数表記 ""1e3""（1000）も float() で変換可能！
✔ float(""abc"") のような数値以外の文字列はエラーになる！

📌 例: float() を使った型変換
# 整数を浮動小数点数に変換
num = float(10)
print(num)  # ✅ 10.0（浮動小数点数）

# 文字列の小数を変換
decimal = float(""2.718"")
print(decimal)  # ✅ 2.718

# 指数表記の文字列を変換
scientific = float(""1e3"")
print(scientific)  # ✅ 1000.0
👉float() を使うと、数値の文字列を計算に使える形に変換できる！",1,1,
94,"text = ""hello""
result = list(text)
print(result)

上記のコードを実行すると、出力される値は？
1️⃣ [""hello""]（文字列を1つの要素としてリストに変換）
2️⃣ ['h', 'e', 'l', 'l', 'o']（文字列を文字ごとに分割してリスト化）
3️⃣ Error（エラーが発生する）
4️⃣ None","2️⃣ ['h', 'e', 'l', 'l', 'o']（文字列を文字ごとに分割してリスト化）","🔹 list() とは？
list() は、引数の値を リスト（list 型）に変換する関数 です！
✅ 文字列を list() に渡すと、1文字ずつ分割してリスト化される！
✅ タプルや辞書のキーも list() でリスト化できる！
✅ 文字列全体を1つの要素にするには、split() を使う！

✅ list() のポイント
✔ 文字列は list() で1文字ずつのリストになる！
✔ タプルを list() にすると、リストに変換される！
✔ 辞書を list() にすると、キーのリストが得られる！
✔ 文字列を単語単位でリスト化したい場合は split() を使う！

📌 例: list() を使った型変換
# 文字列をリスト化（1文字ずつ分割）
print(list(""Python""))  # ✅ ['P', 'y', 't', 'h', 'o', 'n']

# タプルをリストに変換
print(list((1, 2, 3)))  # ✅ [1, 2, 3]

# 辞書のキーをリスト化
print(list({""a"": 1, ""b"": 2, ""c"": 3}))  # ✅ ['a', 'b', 'c']

# 文字列を単語単位でリスト化
print(""Hello world"".split())  # ✅ ['Hello', 'world']
👉 split() を使うと、文字列を単語単位でリストにできる！",1,1,
95,"items = [1, 2, 3]
result = tuple(items)
print(result)

上記のコードを実行すると、出力される値は？
1️⃣ [1, 2, 3]（リストのまま）
2️⃣ (1, 2, 3)（リストをタプルに変換）
3️⃣ Error（エラーが発生する）
4️⃣ {1, 2, 3}（セットに変換される）","2️⃣ (1, 2, 3)（リストをタプルに変換）","🔹 tuple() とは？
tuple() は、引数の値を タプル（tuple 型）に変換する関数 です！
✅ リストをタプルに変換できる！
✅ 文字列を tuple() にすると、1文字ずつのタプルになる！
✅ 辞書を tuple() にすると、キーのタプルが得られる！

✅ tuple() のポイント
✔ リストを tuple() にすると、タプルに変換できる！
✔ 文字列を tuple() にすると、1文字ずつのタプルになる！
✔ 辞書を tuple() にすると、キーのタプルが得られる！
✔ タプルは変更不可（イミュータブル）なので、安全にデータを保持できる！

📌 例: tuple() を使った型変換
# 文字列をタプルに変換（1文字ずつ分割）
print(tuple(""Python""))  # ✅ ('P', 'y', 't', 'h', 'o', 'n')

# リストをタプルに変換
print(tuple([10, 20, 30]))  # ✅ (10, 20, 30)

# 辞書のキーをタプルに変換
print(tuple({""a"": 1, ""b"": 2, ""c"": 3}))  # ✅ ('a', 'b', 'c')
👉タプルは変更できない（イミュータブル）ので、安全なデータの保持に使われる！",1,1,
96,"items = [1, 2, 2, 3, 3, 3]
result = set(items)
print(result)

上記のコードを実行すると、出力される値は？
1️⃣ [1, 2, 2, 3, 3, 3]（リストのまま）
2️⃣ {1, 2, 3}（重複を削除してセットに変換）
3️⃣ Error（エラーが発生する）
4️⃣ (1, 2, 3)（タプルに変換される）","2️⃣ {1, 2, 3}（重複を削除してセットに変換）","🔹 set() とは？
set() は、引数の値を セット（set 型）に変換する関数 です！
✅ リストやタプルからセットを作ると、重複が削除される！
✅ 集合演算（union, intersection, difference など）に便利！
✅ セットは順序を持たないため、出力の並び順は保証されない！

✅ set() のポイント
✔ リストやタプルを set() にすると、重複が削除される！
✔ セットは順序を保持しない！（出力の順番はランダムになる）
✔ 集合演算（和集合・積集合・差集合）を使える！
✔ 重複を除外したい場合に set() が便利！

📌 例: set() を使った型変換と集合演算
# リストをセットに変換（重複が削除される）
print(set([1, 2, 2, 3, 3, 3]))  # ✅ {1, 2, 3}

# 文字列をセットに変換（重複を削除）
print(set(""banana""))  # ✅ {'b', 'a', 'n'}

# 集合演算
A = {1, 2, 3}
B = {3, 4, 5}
print(A | B)  # ✅ {1, 2, 3, 4, 5}（和集合）
print(A & B)  # ✅ {3}（積集合）
print(A - B)  # ✅ {1, 2}（差集合）
👉 set() を使うと、リストの重複削除や集合演算が簡単にできる！",1,1,
97,"items = [(""a"", 1), (""b"", 2), (""c"", 3)]
result = dict(items)
print(result)

上記のコードを実行すると、出力される値は？
1️⃣ [""a"", 1, ""b"", 2, ""c"", 3]（リストのまま）
2️⃣ {1: ""a"", 2: ""b"", 3: ""c""}（キーと値を逆にした辞書）
3️⃣ {""a"": 1, ""b"": 2, ""c"": 3}（リストのペアを辞書に変換）
4️⃣ Error（エラーが発生する）","3️⃣ {""a"": 1, ""b"": 2, ""c"": 3}（リストのペアを辞書に変換）","🔹 dict() とは？
dict() は、引数の値を 辞書（dict 型）に変換する関数 です！
✅ キーと値のペア（タプルのリストなど）を辞書に変換できる！
✅ セットやリストから辞書を作ることはできない（キーと値のペアが必要）！

✅ dict() のポイント
✔ キーと値のペア（タプルやリスト）から辞書を作れる！
✔ キーが重複すると、後の値が上書きされる！
✔ zip() と組み合わせると、2つのリストから辞書を作れる！

📌 例: dict() を使った型変換
# タプルのリストを辞書に変換
print(dict([(""x"", 10), (""y"", 20)]))  # ✅ {'x': 10, 'y': 20}

# `zip()` を使って辞書を作成
keys = [""name"", ""age"", ""city""]
values = [""Alice"", 25, ""New York""]
print(dict(zip(keys, values)))  # ✅ {'name': 'Alice', 'age': 25, 'city': 'New York'}

# キーが重複すると後の値が優先される
print(dict([(""a"", 1), (""a"", 2)]))  # ✅ {'a': 2}（2が上書きされる）
👉 dict() を使うと、リストやタプルから簡単に辞書が作れる！",1,1,
98,"keys = [""name"", ""age"", ""city""]
values = [""Alice"", 25, ""New York""]
result = dict(zip(keys, values))
print(result)

 上記のコードを実行すると、出力される値は？
1️⃣ {""name"": ""Alice"", ""age"": 25, ""city"": ""New York""}（キーと値を対応させた辞書）
2️⃣ [(""name"", ""Alice""), (""age"", 25), (""city"", ""New York"")]（リストのまま）
3️⃣ Error（エラーが発生する）
4️⃣ None","1️⃣ {""name"": ""Alice"", ""age"": 25, ""city"": ""New York""}（キーと値を対応させた辞書）","🔹 zip() とは？
zip() は、複数のリストやタプルを ペア（タプルのリスト）に変換する関数 です！
✅ zip() を dict() に渡すと、2つのリストをキーと値のペアとして辞書に変換できる！
✅ キーと値の数が異なると、短い方に合わせてペアが作られる！

✅ zip() + dict() のポイント
✔ 2つのリストをキーと値の辞書に変換できる！
✔ キーと値のリストの長さが異なると、短い方に合わせられる！
✔ 辞書の作成やデータのマッピングに便利！

📌 例: zip() を使った辞書の作成
# 2つのリストを辞書に変換
keys = [""x"", ""y"", ""z""]
values = [10, 20, 30]
print(dict(zip(keys, values)))  # ✅ {'x': 10, 'y': 20, 'z': 30}

# 長さが違う場合（短い方に合わせる）
keys = [""a"", ""b"", ""c""]
values = [1, 2]
print(dict(zip(keys, values)))  # ✅ {'a': 1, 'b': 2}（'c' は無視される）

👉 zip() を使うと、2つのリストを簡単に辞書に変換できる！",1,1,
99,"fruits = [""apple"", ""banana"", ""cherry""]
for index, fruit in enumerate(fruits):
    print(index, fruit)

上記のコードを実行すると、出力される値は？
1️⃣
apple 0
banana 1
cherry 2

2️⃣
0 apple
1 banana
2 cherry

3️⃣
['apple', 'banana', 'cherry']

4️⃣
Error","
2️⃣
0 apple
1 banana
2 cherry","🔹 enumerate() とは？
enumerate() は、リストやタプルなどの 要素にインデックス（番号）を付けてくれる関数 です！
✅ ループの中でインデックス（数値）と要素を同時に取得できる！
✅ デフォルトでは 0 から開始されるが、start を指定して変更できる！

✅ enumerate() のポイント
✔ リストの各要素にインデックスを付けてループ処理ができる！
✔ start を指定すれば、インデックスの開始番号を変更できる！
✔ リストの要素とインデックスを同時に扱うのに便利！

📌 例: enumerate() を使った処理
# インデックス付きでループ
fruits = [""apple"", ""banana"", ""cherry""]
for i, fruit in enumerate(fruits):
    print(f""{i}: {fruit}"")

# インデックスを 1 から始める
for i, fruit in enumerate(fruits, start=1):
    print(f""{i}: {fruit}"")  
# ✅ 1: apple
# ✅ 2: banana
# ✅ 3: cherry

👉 enumerate() を使うと、リストのインデックスを手動で管理する必要がなくなる！",1,1,
100,"numbers = [3, 7, 2, 9, 5]
result = max(numbers)
print(result)

上記のコードを実行すると、出力される値は？
1️⃣ 2（リスト内の最小値）
2️⃣ 9（リスト内の最大値）
3️⃣ [3, 7, 2, 9, 5]（リストのまま）
4️⃣ Error（エラーが発生する）","2️⃣ 9（リスト内の最大値）","🔹 max() とは？
max() は、リストやタプルなどの イテラブル（繰り返し可能なデータ）の中で最大値を返す関数 です！
✅ 数値のリストなら、最も大きい数を返す！
✅ 文字列のリストなら、アルファベット順で最後の単語を返す！
✅ 辞書の場合は、キーの最大値を返す！

✅ max() のポイント
✔ リストやタプルの最大値を取得できる！
✔ 文字列リストでは、アルファベット順で最大の単語を返す！
✔ 辞書では、キーの最大値を返す！（max(dict.keys()) のように指定可）
✔ min() を使えば、最小値を取得できる！

📌 例: max() を使った処理
# 数値リストの最大値
print(max([10, 20, 5, 8]))  # ✅ 20

# 文字列リストの最大値（アルファベット順）
print(max([""apple"", ""banana"", ""cherry""]))  # ✅ ""cherry""（最後の単語）

# タプルの最大値
print(max((100, 50, 75)))  # ✅ 100

# 辞書のキーの最大値
data = {1: ""one"", 2: ""two"", 3: ""three""}
print(max(data))  # ✅ 3（辞書のキーの最大値）

# min() を使って最小値を取得
print(min([10, 20, 5, 8]))  # ✅ 5

👉max() を使うと、リスト・タプル・文字列の最大値を簡単に取得できる！",1,1,
101,"numbers = [8, 4, 1, 7, 3]
result = min(numbers)
print(result)

上記のコードを実行すると、出力される値は？
1️⃣ 8（リスト内の最大値）
2️⃣ 1（リスト内の最小値）
3️⃣ [8, 4, 1, 7, 3]（リストのまま）
4️⃣ Error（エラーが発生する）","2️⃣ 1（リスト内の最小値）","🔹 min() とは？
min() は、リストやタプルなどの イテラブル（繰り返し可能なデータ）の中で最小値を返す関数 です！
✅ 数値のリストなら、最も小さい数を返す！
✅ 文字列のリストなら、アルファベット順で最初の単語を返す！
✅ 辞書の場合は、キーの最小値を返す！

✅ min() のポイント
✔ リストやタプルの最小値を取得できる！
✔ 文字列リストでは、アルファベット順で最初の単語を返す！
✔ 辞書では、キーの最小値を返す！（min(dict.keys()) のように指定可）
✔ max() を使えば、最大値を取得できる！

📌 例: min() を使った処理
# 数値リストの最小値
print(min([10, 20, 5, 8]))  # ✅ 5

# 文字列リストの最小値（アルファベット順）
print(min([""apple"", ""banana"", ""cherry""]))  # ✅ ""apple""（最初の単語）

# タプルの最小値
print(min((100, 50, 75)))  # ✅ 50

# 辞書のキーの最小値
data = {1: ""one"", 2: ""two"", 3: ""three""}
print(min(data))  # ✅ 1（辞書のキーの最小値）

# max() を使って最大値を取得
print(max([10, 20, 5, 8]))  # ✅ 20
👉 min() を使うと、リスト・タプル・文字列の最小値を簡単に取得できる！",1,1,
102,"numbers = [4, 7, 1, 8, 3]
result = sum(numbers)
print(result)

上記のコードを実行すると、出力される値は？
1️⃣ 23（リストの合計値）
2️⃣ 8（リスト内の最大値）
3️⃣ [4, 7, 1, 8, 3]（リストのまま）
4️⃣ Error（エラーが発生する）","1️⃣ 23（リストの合計値）","🔹 sum() とは？
sum() は、リストやタプルなどの 数値の合計を求める関数 です！
✅ 数値のリスト・タプルの合計を計算できる！
✅ オプションで「初期値」を指定すると、そこから合計が始まる！
✅ 文字列や辞書に使うとエラーが発生する！

✅ sum() のポイント
✔ 数値のリスト・タプルの合計を計算できる！
✔ 初期値を指定すると、その値を基準に加算される！
✔ リスト内に str（文字列）が含まれるとエラーになる！

📌 例: sum() を使った計算
# リストの合計
print(sum([10, 20, 30]))  # ✅ 60

# タプルの合計
print(sum((5, 15, 25)))  # ✅ 45

# 初期値を指定（合計に 100 を足す）
print(sum([1, 2, 3], 100))  # ✅ 106

# 空のリストを合計（デフォルトで 0）
print(sum([]))  # ✅ 0

# 文字列が混ざるとエラーになる
# print(sum([1, ""2"", 3]))  # ❌ TypeError
📌 sum() は数値のリスト・タプルの合計を簡単に求められる！",1,1,
103,"items = [""apple"", ""banana"", ""cherry""]
result = len(items)
print(result)

 上記のコードを実行すると、出力される値は？
1️⃣ 2（リストのインデックスの最大値）
2️⃣ 3（リストの要素数）
3️⃣ [""apple"", ""banana"", ""cherry""]（リストのまま）
4️⃣ Error（エラーが発生する）","2️⃣ 3（リストの要素数）","🔹 len() とは？
len() は、リストやタプル、文字列などの 要素の個数（長さ）を取得する関数 です！
✅ リスト・タプル・辞書・集合の要素数を取得できる！
✅ 文字列に対して使うと、文字数（長さ）を取得できる！
✅ 辞書に使うと、キーの数を取得できる！

✅ len() のポイント
✔ リストの要素数を取得できる！
✔ 文字列では「文字数（長さ）」を取得できる！
✔ 辞書では「キーの数」を取得できる！
✔ 空のリストや辞書の長さは 0！

📌 例: len() を使った処理
# リストの要素数を取得
print(len([10, 20, 30, 40]))  # ✅ 4

# 文字列の長さを取得
print(len(""Hello, World!""))  # ✅ 13（スペースや記号もカウントされる）

# タプルの要素数を取得
print(len((100, 200, 300)))  # ✅ 3

# 辞書のキーの数を取得
data = {""a"": 1, ""b"": 2, ""c"": 3}
print(len(data))  # ✅ 3（キーの数）

# 空のリストの長さ
print(len([]))  # ✅ 0

👉 len() を使うと、データの要素数を簡単に取得できる！",1,1,
104,"numbers = list(range(1, 6))
print(numbers)

上記のコードを実行すると、出力される値は？
1️⃣ [1, 2, 3, 4, 5, 6]（1から6までのリスト）
2️⃣ [1, 2, 3, 4, 5]（1から5までのリスト）
3️⃣ [0, 1, 2, 3, 4, 5]（0から5までのリスト）
4️⃣ Error（エラーが発生する）","2️⃣ [1, 2, 3, 4, 5]（1から5までのリスト）","🔹 range() とは？
range() は、連続した数値の 範囲（整数のシーケンス）を生成する関数 です！
✅ range(start, stop) は start から stop-1 までの整数を生成する！
✅ リストとして使いたい場合は list(range()) で変換する！
✅ range(start, stop, step) のようにステップ（増減値）を指定できる！

✅ range() のポイント
✔ range(start, stop) は start から stop-1 までの整数を生成！
✔ リストとして使うには list(range()) に変換！
✔ range(start, stop, step) で増減値を指定可能！
✔ デフォルトの start は 0、デフォルトの step は 1！

📌 例: range() を使ったリストの作成

# 0から4までのリストを作成
print(list(range(5)))  # ✅ [0, 1, 2, 3, 4]

# 1から10まで（step=2）のリストを作成
print(list(range(1, 10, 2)))  # ✅ [1, 3, 5, 7, 9]

# 負のステップ（10から1まで逆順）
print(list(range(10, 0, -2)))  # ✅ [10, 8, 6, 4, 2]

# 空の range（開始値が終了値を超えている場合）
print(list(range(5, 1)))  # ✅ []

👉 range() は連続した数値のリストを簡単に作成できる！",1,1,
105,"words = [""Hello"", ""Python"", ""World""]
result = "" "".join(words)
print(result)

上記のコードを実行すると、出力される値は？
1️⃣ ""HelloPythonWorld""（空白なしで結合）
2️⃣ [""Hello"", ""Python"", ""World""]（リストのまま）
3️⃣ ""Hello Python World""（空白で区切って結合）
4️⃣ Error（エラーが発生する）","3️⃣ ""Hello Python World""（空白で区切って結合）","🔹 join() とは？
join() は、リストやタプルの文字列要素を結合して、1つの文字列を作成するメソッド です！
✅ ""区切り文字"".join(リスト) の形で使用する！
✅ リストの各要素を指定した区切り文字で結合する！
✅ 文字列のリストでのみ使用でき、数値のリストには使えない！

✅ join() のポイント
✔ リストの要素を1つの文字列に結合できる！
✔ 区切り文字（デリミタ）を自由に指定可能！
✔ 数値リストには直接使えない（数値は str() に変換が必要）！

📌 例: join() を使った文字列の結合
# カンマで区切る
words = [""apple"", ""banana"", ""cherry""]
print("", "".join(words))  # ✅ ""apple, banana, cherry""

# 改行で区切る
print(""\n"".join(words))
# ✅ 出力:
# apple
# banana
# cherry

# `-` で区切る
print(""-"".join(words))  # ✅ ""apple-banana-cherry""

# 数値のリストは `join()` できない（エラー）
numbers = [1, 2, 3]
# print("", "".join(numbers))  # ❌ TypeError（数値は直接結合できない）

# 数値を文字列に変換して結合
print("", "".join(map(str, numbers)))  # ✅ ""1, 2, 3""
👉join() を使うと、リストの文字列要素を簡単に結合できる！",1,1,
106,"numbers = {1, 2, 3}
numbers.add(4)
print(numbers)

上記のコードを実行すると、出力される値は？
1️⃣ {1, 2, 3}（セットのまま変更なし）
2️⃣ {1, 2, 3, 4}（新しい要素が追加される）
3️⃣ [1, 2, 3, 4]（リストとして出力される）
4️⃣ Error（エラーが発生する）","2️⃣ {1, 2, 3, 4}（新しい要素が追加される）","🔹 set.add() とは？
set.add() は、セット（set 型）に新しい要素を追加するメソッド です！
✅ セットに指定した要素を追加する！
✅ 追加する要素がすでにセット内にある場合、何も起こらない（重複は許されない）！
✅ セットは順序を持たないため、出力順は保証されない！

✅ set.add() のポイント
✔ セットに新しい要素を追加できる！
✔ 追加する要素がすでに存在する場合は無視される！
✔ セットは順序を保持しないため、出力の順番は保証されない！

📌 例: set.add() の動作
# セットに要素を追加
numbers = {10, 20, 30}
numbers.add(40)
print(numbers)  # ✅ {10, 20, 30, 40}（順番は保証されない）

# すでに存在する要素を追加しても変化なし
numbers.add(20)
print(numbers)  # ✅ {10, 20, 30, 40}（20 はすでにあるので変化なし）

# 文字列のセットに要素を追加
words = {""apple"", ""banana""}
words.add(""cherry"")
print(words)  # ✅ {'apple', 'banana', 'cherry'}

👉 set.add() を使うと、セットに効率的に新しい要素を追加できる！

",1,1,
107,"numbers = {1, 2, 3, 4, 5}
numbers.remove(3)
print(numbers)

上記のコードを実行すると、出力される値は？
1️⃣ {1, 2, 3, 4, 5}（セットのまま変更なし）
2️⃣ {1, 2, 4, 5}（指定した要素が削除される）
3️⃣ [1, 2, 4, 5]（リストとして出力される）
4️⃣ Error（エラーが発生する）","2️⃣ {1, 2, 4, 5}（指定した要素が削除される）","🔹 set.remove() とは？
set.remove() は、セット（set 型）から指定した要素を削除するメソッド です！
✅ セット内に指定した要素があれば削除される！
✅ セットに存在しない要素を削除しようとすると KeyError が発生する！
✅ 削除後もセットは順序を持たないため、出力順は保証されない！

✅ set.remove() のポイント
✔ セット内の特定の要素を削除できる！
✔ 存在しない要素を削除しようとすると KeyError が発生する！
✔ エラーを避ける場合は discard() を使うと安全！
✔ セットは順序を保持しないため、出力の順番はランダム！

📌 例: set.remove() の動作
# セットの要素を削除
numbers = {10, 20, 30, 40}
numbers.remove(20)
print(numbers)  # ✅ {10, 30, 40}（順番は保証されない）

# 存在しない要素を削除しようとするとエラー
# numbers.remove(50)  # ❌ KeyError: 50（エラー発生）

📌 存在しない要素を削除する可能性がある場合は discard() を使うと良い！
# `discard()` を使うとエラーを回避できる
numbers.discard(50)  # ✅ エラーなし
print(numbers)  # ✅ {10, 30, 40}

👉 remove() は 要素が存在しないと KeyError が発生する ため、安全な削除には discard() を使うと良い！
",1,1,
108,"numbers = {10, 20, 30, 40}
removed_item = numbers.pop()
print(removed_item)
print(numbers)

上記のコードを実行すると、出力される値は？
1️⃣ 10（セットの最小値が削除される）
2️⃣ 40（セットの最大値が削除される）
3️⃣ 削除される値は不定だが、セットの中の1つの要素が削除される
4️⃣ Error（エラーが発生する","3️⃣ 削除される値は不定だが、セットの中の1つの要素が削除される","実は…set.pop() は「最大値」ではなく「どれが削除されるか 不定」です！ 🔥
なので、正解は 3️⃣（削除される値は不定） です！ 🎯

📝 set.pop() の動作
✔ set.pop() は、セット内の要素を1つ削除し、その値を返す
✔ セットは順序を保持しない（無秩序） ため、削除される要素は決まっていない！
✔ リストの .pop() のように「最後の要素を削除」するわけではない！
✔ セットが空の場合、KeyError が発生する！

✅ set.pop() のポイント
✔ セットの要素をランダムに1つ削除する！（どの要素かは保証されない）
✔ リストの pop() のように「末尾の要素を削除する」わけではない！
✔ セットが空の状態で pop() を実行すると KeyError が発生する！

📌 set.pop() の挙動を確かめる
# 何度か実行すると、異なる要素が削除される可能性がある
numbers = {10, 20, 30, 40}
print(numbers.pop())  # ✅ 例えば 30
print(numbers.pop())  # ✅ 例えば 10
print(numbers.pop())  # ✅ 例えば 40
print(numbers.pop())  # ✅ 例えば 20
# numbers.pop()  # ❌ KeyError（セットが空だとエラー）
👉 セットの要素が削除される順番は決まっていないため、常に結果が変わる可能性がある！",1,1,
109,"A = {1, 2, 3}
B = {3, 4, 5}
result = A.union(B)
print(result)

上記のコードを実行すると、出力される値は？
1️⃣ {1, 2, 3, 4, 5}（両方の集合の和集合）
2️⃣ {3}（共通部分のみ）
3️⃣ {(1, 2, 3), (3, 4, 5)}（タプルの集合）
4️⃣ Error（エラーが発生する）","1️⃣ {1, 2, 3, 4, 5}（両方の集合の和集合）","🔹 set.union() とは？
union() は、2つ以上のセットを結合して「和集合」を作るメソッド です！
✅ A.union(B) は、A と B の要素をすべて含む新しいセットを作成！
✅ 重複する要素は1回しか含まれない！
✅ 演算子 |（パイプ）を使って A | B でも同じ結果が得られる！

✅ set.union() のポイント
✔ A.union(B) は A と B の和集合を作成！
✔ 重複する要素は1回しか含まれない！
✔ A | B という演算子でも和集合を求められる！

📌 例: union() を使った集合の結合
# 和集合の作成（`union()` メソッド）
A = {10, 20, 30}
B = {30, 40, 50}
print(A.union(B))  # ✅ {10, 20, 30, 40, 50}

# `|` 演算子で和集合を求める
print(A | B)  # ✅ {10, 20, 30, 40, 50}

# 複数の集合を結合
C = {50, 60, 70}
print(A.union(B, C))  # ✅ {10, 20, 30, 40, 50, 60, 70}

# 空集合との和集合
print(A.union(set()))  # ✅ {10, 20, 30}（変更なし）

👉union() を使うと、複数のセットを簡単に結合できる！",1,1,
110,"A = {1, 2, 3}
B = {3, 4, 5}
result = A.union(B)
print(result)

上記のコードを実行すると、出力される値は？
1️⃣ {1, 2, 3, 4, 5}（両方の集合の和集合）
2️⃣ {3}（共通部分のみ）
3️⃣ {(1, 2, 3), (3, 4, 5)}（タプルの集合）
4️⃣ Error（エラーが発生する）","1️⃣ {1, 2, 3, 4, 5}（両方の集合の和集合）","🔹 set.union() とは？
union() は、2つ以上のセットを結合して「和集合」を作るメソッド です！
✅ A.union(B) は、A と B の要素をすべて含む新しいセットを作成！
✅ 重複する要素は1回しか含まれない！
✅ 演算子 |（パイプ）を使って A | B でも同じ結果が得られる

✅ set.union() のポイント
✔ A.union(B) は A と B の和集合を作成！
✔ 重複する要素は1回しか含まれない！
✔ A | B という演算子でも和集合を求められる！

📌 例: union() を使った集合の結合
# 和集合の作成（`union()` メソッド）
A = {10, 20, 30}
B = {30, 40, 50}
print(A.union(B))  # ✅ {10, 20, 30, 40, 50}

# `|` 演算子で和集合を求める
print(A | B)  # ✅ {10, 20, 30, 40, 50}

# 複数の集合を結合
C = {50, 60, 70}
print(A.union(B, C))  # ✅ {10, 20, 30, 40, 50, 60, 70}

# 空集合との和集合
print(A.union(set()))  # ✅ {10, 20, 30}（変更なし）

👉 union() を使うと、複数のセットを簡単に結合できる！",1,1,
111,"A = {1, 2, 3, 4}
B = {3, 4, 5, 6}
result = A.intersection(B)
print(result)

上記のコードを実行すると、出力される値は？
1️⃣ {1, 2, 3, 4, 5, 6}（両方の集合の和集合）
2️⃣ {3, 4}（両方の集合に共通する要素のみ）
3️⃣ {(1, 2, 3, 4), (3, 4, 5, 6)}（タプルの集合）
4️⃣ Error（エラーが発生する）","2️⃣ {3, 4}（両方の集合に共通する要素のみ）","🔹 set.intersection() とは？
intersection() は、2つ以上のセットの「共通部分」（積集合）を求めるメソッド です！
✅ A.intersection(B) は、A と B の両方に含まれる要素だけを抽出！
✅ A & B のように & 演算子を使っても同じ結果が得られる！
✅ 共通する要素がない場合は、空のセット {} が返る！

✅ set.intersection() のポイント
✔ A.intersection(B) は A と B の共通部分を取得！
✔ 共通する要素がない場合、空のセット {} が返る！
✔ A & B のように & 演算子を使ってもOK！
✔ 複数のセットの共通部分も求められる！

📌 例: intersection() を使った共通部分の取得
# 2つのセットの共通部分
A = {10, 20, 30, 40}
B = {30, 40, 50, 60}
print(A.intersection(B))  # ✅ {30, 40}

# `&` 演算子で共通部分を求める
print(A & B)  # ✅ {30, 40}

# 3つのセットの共通部分
C = {40, 50, 60, 70}
print(A.intersection(B, C))  # ✅ {40}（全ての集合に共通する要素）

# 共通する要素がない場合
X = {1, 2, 3}
Y = {4, 5, 6}
print(X.intersection(Y))  # ✅ set()（空のセット）

👉intersection() を使うと、セットの共通部分を簡単に取得できる！",1,1,
112,"A = {1, 2, 3, 4}
B = {3, 4, 5, 6}
result = A.difference(B)
print(result)

上記のコードを実行すると、出力される値は？
1️⃣ {1, 2}（A にのみ含まれる要素）
2️⃣ {5, 6}（B にのみ含まれる要素）
3️⃣ {1, 2, 5, 6}（共通しない要素すべて）
4️⃣ Error（エラーが発生する）","1️⃣ {1, 2}（A にのみ含まれる要素）","🔹 set.difference() とは？
difference() は、あるセットから別のセットの要素を取り除き、残った要素を取得するメソッド です！
✅ A.difference(B) は、「A に含まれるが、B には含まれない要素」を取得！
✅ 演算子 - を使って A - B と書くこともできる！
✅ B に含まれる要素はすべて取り除かれる！

✅ set.difference() のポイント
✔ A.difference(B) は A から B に含まれる要素を取り除く！
✔ 演算子 - を使って A - B と書くこともできる！
✔ A.difference(B, C) のように、複数のセットの要素を一度に除外できる！

📌 例: difference() を使った差集合の取得
# A から B の要素を取り除く
A = {10, 20, 30, 40}
B = {30, 40, 50, 60}
print(A.difference(B))  # ✅ {10, 20}

# `-` 演算子で差集合を求める
print(A - B)  # ✅ {10, 20}

# 3つのセットの差集合
C = {20, 50, 60}
print(A.difference(B, C))  # ✅ {10}（A から B と C の要素をすべて除く）

# B から A の要素を取り除く
print(B.difference(A))  # ✅ {50, 60}（B にのみ含まれる要素）

# 完全に重なった場合は空のセット
X = {1, 2, 3}
Y = {1, 2, 3}
print(X.difference(Y))  # ✅ set()（空のセット）

👉 difference() を使うと、セットの「片方にのみ含まれる要素」を簡単に取得できる！",1,1,
113,"A = {1, 2, 3, 4}
B = {3, 4, 5, 6}
result = A.symmetric_difference(B)
print(result)

 上記のコードを実行すると、出力される値は？
1️⃣ {1, 2}（A にのみ含まれる要素）
2️⃣ {5, 6}（B にのみ含まれる要素）
3️⃣ {1, 2, 5, 6}（共通部分を除いた要素すべて）
4️⃣ Error（エラーが発生する）","3️⃣ {1, 2, 5, 6}（共通部分を除いた要素すべて）","🔹 set.symmetric_difference() とは？
symmetric_difference() は、2つのセットの「共通部分を除いた要素」を取得するメソッド です！
✅ A.symmetric_difference(B) は A または B のどちらか一方に含まれる要素のみを取得する！
✅ 共通する要素は含まれない！
✅ 演算子 ^ を使って A ^ B と書くこともできる！

✅ set.symmetric_difference() のポイント
✔ A.symmetric_difference(B) は A と B の一方にのみ含まれる要素を取得！
✔ 共通する要素は取り除かれる！
✔ 演算子 ^ を使って A ^ B と書くこともできる！
✔ 3つ以上の集合には直接適用できない（reduce() を使う必要あり）！

📌 例: symmetric_difference() を使った対称差の取得
# A と B の対称差
A = {10, 20, 30, 40}
B = {30, 40, 50, 60}
print(A.symmetric_difference(B))  # ✅ {10, 20, 50, 60}

# `^` 演算子で対称差を求める
print(A ^ B)  # ✅ {10, 20, 50, 60}

# 完全に一致する場合は空のセット
X = {1, 2, 3}
Y = {1, 2, 3}
print(X.symmetric_difference(Y))  # ✅ set()（空のセット）

# 3つ以上の集合の対称差を求める（reduce を使用）
from functools import reduce
C = {20, 60, 70}
result = reduce(set.symmetric_difference, [A, B, C])
print(result)  # ✅ {10, 50, 70}
📌 symmetric_difference() を使うと、2つのセットの「どちらかにしかない要素」を簡単に取得できる！",1,1,
114,"fruits = {""apple"", ""banana"", ""cherry""}
print(""banana"" in fruits)

上記のコードを実行すると、出力される値は？
1️⃣ True（banana はセットに含まれる）
2️⃣ False（banana はセットに含まれない）
3️⃣ Error（エラーが発生する）
4️⃣ None（banana の存在を確認できない）","1️⃣ True（banana はセットに含まれる）","🔹 in 演算子とは？
in 演算子は、リスト・セット・辞書・文字列などの「イテラブル（繰り返し可能なデータ）」の中に特定の要素が含まれているかを確認する のに使います！
✅ 要素が存在する場合は True を返す！
✅ 要素が存在しない場合は False を返す！
✅ セットはハッシュテーブルを使っているため、in の検索が非常に高速！

✅ in のポイント
✔ リスト・セット・タプル・辞書・文字列に対して使える！
✔ セット (set) はハッシュテーブル構造なので、in の検索がリストより高速！
✔ 辞書（dict）ではキーの存在を確認する！

📌 例: in を使った要素の存在確認
# リストでの存在確認
numbers = [10, 20, 30, 40]
print(20 in numbers)  # ✅ True（リストに 20 がある）

# セットでの存在確認（リストより高速）
fruits = {""apple"", ""banana"", ""cherry""}
print(""banana"" in fruits)  # ✅ True
print(""grape"" in fruits)   # ✅ False（セットに ""grape"" はない）

# 辞書でのキーの存在確認
person = {""name"": ""Alice"", ""age"": 25}
print(""name"" in person)  # ✅ True（キー ""name"" がある）
print(""Alice"" in person)  # ❌ False（値はチェックされない）

# 文字列の部分一致確認
sentence = ""Python is fun!""
print(""Python"" in sentence)  # ✅ True
print(""java"" in sentence)    # ✅ False（大文字小文字も区別される）

👉 in を使うと、データ構造の中に特定の値があるかを簡単に確認できる！",1,1,
115,"names = [""Alice"", ""Bob"", ""Charlie""]
ages = [25, 30, 35]

result = list(zip(names, ages))
print(result)

上記のコードを実行すると、出力される値は？
1️⃣ [(""Alice"", 25), (""Bob"", 30), (""Charlie"", 35)]（対応する要素をタプルにまとめる）
2️⃣ [""Alice"", ""Bob"", ""Charlie"", 25, 30, 35]（リストを結合する）
3️⃣ {""Alice"": 25, ""Bob"": 30, ""Charlie"": 35}（辞書を作成する）
4️⃣ Error（エラーが発生する）","1️⃣ [(""Alice"", 25), (""Bob"", 30), (""Charlie"", 35)]（対応する要素をタプルにまとめる）","🔹 zip() とは？
zip() は、複数のリストやタプルを対応する要素ごとにペア（タプル）にまとめる関数 です！
✅ zip(A, B) は A[i] と B[i] をペアにしてタプルのリストを作成！
✅ list(zip(A, B)) のように list() でリスト化すると、結果を明示的に取得できる！
✅ 入力リストの長さが異なる場合、短い方の要素数に合わせて処理される！

✅ zip() のポイント
✔ 複数のリストを要素ごとに対応させたタプルのリストを作成！
✔ リストの長さが異なる場合、短い方の要素数に合わせてペアが作られる！
✔ dict(zip(A, B)) を使えば辞書として変換可能！
✔ リストが空の場合、空のリストが返る！

📌 例: zip() を使った組み合わせ
# 2つのリストを zip() で結合
names = [""Alice"", ""Bob"", ""Charlie""]
ages = [25, 30, 35]
print(list(zip(names, ages)))  
# ✅ [('Alice', 25), ('Bob', 30), ('Charlie', 35)]

# 長さが異なる場合（短い方に合わせる）
names = [""Alice"", ""Bob""]
ages = [25, 30, 35]
print(list(zip(names, ages)))  
# ✅ [('Alice', 25), ('Bob', 30)]（""Charlie"" は無視される）

# 3つのリストを zip() で結合
cities = [""New York"", ""Los Angeles"", ""Chicago""]
print(list(zip(names, ages, cities)))  
# ✅ [('Alice', 25, 'New York'), ('Bob', 30, 'Los Angeles')]

# zip() を使って辞書を作成
print(dict(zip(names, ages)))  
# ✅ {'Alice': 25, 'Bob': 30}（辞書に変換）

👉 zip() を使うと、複数のリストを効率的に組み合わせることができる！",1,1,
116,"values = [True, True, False]
result = all(values)
print(result)

上記のコードを実行すると、出力される値は？
1️⃣ True（リスト内のすべての要素が True）
2️⃣ False（リスト内に False が含まれる）
3️⃣ [True, True, False]（リストのまま出力される）
4️⃣ Error（エラーが発生する）","2️⃣ False（リスト内に False が含まれる）","🔹 all() とは？
all() は、リスト・タプル・セットなどのすべての要素が True かどうかを判定する組み込み関数 です！
✅ リスト内のすべての要素が True の場合に True を返す！
✅ 1つでも False が含まれている場合は False を返す！
✅ 空のリスト [] やタプル () を渡すと True を返す！（特殊な挙動）

✅ all() のポイント
✔ リストやタプルのすべての要素が True なら True を返す！
✔ 1つでも False があると False を返す！
✔ 空のリスト・タプルを渡すと True を返す！（Pythonの仕様）
✔ all() はブール値だけでなく、数値・文字列・オブジェクトにも適用可能！

📌 例: all() を使ったリストの評価
# すべてが True の場合
print(all([True, True, True]))  # ✅ True

# 1つでも False がある場合
print(all([True, False, True]))  # ✅ False

# 空のリストやタプル（特殊な挙動）
print(all([]))  # ✅ True（空は True とみなされる）

# 数値リストの場合（0 以外は True）
print(all([1, 2, 3, 4]))  # ✅ True
print(all([1, 0, 3]))  # ✅ False（0 は False 扱い）

# 文字列リスト（空文字は False 扱い）
print(all([""Python"", ""Java"", """"]))  # ✅ False（"""" は False）
print(all([""Hello"", ""World""]))  # ✅ True

👉all() を使うと、リスト内のすべての値が有効かどうかを簡単にチェックできる！",1,1,
117,"values = [False, False, True]
result = any(values)
print(result)

上記のコードを実行すると、出力される値は？
1️⃣ True（リスト内に True が1つでも含まれる）
2️⃣ False（リスト内のすべての要素が False）
3️⃣ [False, False, True]（リストのまま出力される）
4️⃣ Error（エラーが発生する）","1️⃣ True（リスト内に True が1つでも含まれる）","🔹 any() とは？
any() は、リストやタプルの中に True の要素が1つでもあれば True を返す組み込み関数 です！
✅ リスト内のどれか1つでも True なら True を返す！
✅ すべての要素が False なら False を返す！
✅ 空のリスト [] やタプル () を渡すと False を返す！

✅ any() のポイント
✔ リストやタプルの中に True が1つでもあれば True を返す！
✔ すべて False の場合は False を返す！
✔ 空のリスト・タプルを渡すと False を返す！（Pythonの仕様）
✔ any() はブール値だけでなく、数値・文字列・オブジェクトにも適用可能！

📌 例: any() を使ったリストの評価
# 1つでも True がある場合
print(any([False, False, True]))  # ✅ True

# すべてが False の場合
print(any([False, False, False]))  # ✅ False

# 空のリストやタプル（特殊な挙動）
print(any([]))  # ✅ False（空は False とみなされる）

# 数値リストの場合（0 以外は True）
print(any([0, 0, 3, 0]))  # ✅ True（3 があるため）
print(any([0, 0, 0]))  # ✅ False（すべて 0）

# 文字列リスト（空文字は False 扱い）
print(any(["""", """", ""Hello""]))  # ✅ True（""Hello"" があるため）
print(any(["""", """", """"]))  # ✅ False（すべて空文字）
👉any() を使うと、リスト内に有効な値があるかどうかを簡単にチェックできる！",1,1,
118,"numbers = [1, 2, 3, 4, 5]
result = list(reversed(numbers))
print(result)

上記のコードを実行すると、出力される値は？
1️⃣ [5, 4, 3, 2, 1]（リストを逆順に並べ替える）
2️⃣ [1, 2, 3, 4, 5]（元のリストのまま）
3️⃣ reversed([1, 2, 3, 4, 5])（reversed オブジェクトが表示される）
4️⃣ Error（エラーが発生する","1️⃣ [5, 4, 3, 2, 1]（リストを逆順に並べ替える）","🔹 reversed() とは？
reversed() は、リストやタプルなどのイテラブル（反復可能なオブジェクト）を逆順にする組み込み関数 です！
✅ reversed(リスト) は逆順の要素を持つ reversed オブジェクト を返す！
✅ list(reversed(リスト)) でリストに変換すると、逆順のリストが得られる！
✅ 元のリストを直接変更しない！（新しいリストを作成）

✅ reversed() のポイント
✔ reversed() は元のリストを変更せず、新しい反転イテレータを作成！
✔ list(reversed(リスト)) で逆順のリストが得られる！
✔ リストの [::-1] でも同じように逆順にできる！

📌 例: reversed() を使ったリストの反転
# reversed() を使って逆順のリストを作成
numbers = [10, 20, 30, 40, 50]
print(list(reversed(numbers)))  # ✅ [50, 40, 30, 20, 10]

# reversed() のまま使うとオブジェクトになる
print(reversed(numbers))  # ✅ <reversed object at 0x...>

# for ループで reversed() を使う
for num in reversed(numbers):
    print(num)  
# ✅ 50
# ✅ 40
# ✅ 30
# ✅ 20
# ✅ 10

# 逆順にするにはスライス [::-1] でリストを逆順にする方法もある。
print(numbers[::-1])  # ✅ [50, 40, 30, 20, 10]

# タプルの逆順
tuple_values = (1, 2, 3)
print(tuple(reversed(tuple_values)))  # ✅ (3, 2, 1)
👉 reversed() を使うと、リストやタプルを簡単に逆順にできる！",1,1,
119,"x = 10
if x > 5:
    result = ""x is greater than 5""
else:
    result = ""x is less than or equal to 5""
print(result)

上記のコードを実行すると、出力される値は？
1️⃣ ""x is greater than 5""（条件が真の場合）
2️⃣ ""x is less than or equal to 5""（条件が偽の場合）
3️⃣ Error（エラーが発生する）
4️⃣ ""x is greater than or equal to 5""（条件が不明確）","1️⃣ ""x is greater than 5""（条件が真の場合）","🔹 if 文とは？
if 文は、条件に基づいて処理を分岐するための制御構文 です！

条件が真 (True) の場合 に実行されるコードブロックがあり、
条件が偽 (False) の場合 に実行されるコードブロックは else 以下に記述します。

🔹 実行結果
csharp
コピーする
x is greater than 5
✅ 正解は 1️⃣ ""x is greater than 5""（条件が真の場合）！ 🎯

✅ if 文のポイント
✔ if 文は条件が真（True）の場合に実行される！
✔ else は条件が偽（False）の場合に実行される！
✔ elif を使えば、複数の条件をチェックできる！

📌 例: if 文の使い方
# 基本的な if 文
x = 10
if x > 5:
    print(""x is greater than 5"")  # ✅ 実行される

# else を使った条件分岐
y = 2
if y > 5:
    print(""y is greater than 5"")
else:
    print(""y is less than or equal to 5"")  # ✅ 実行される

# elif を使った複数条件
z = 5
if z > 10:
    print(""z is greater than 10"")
elif z == 5:
    print(""z is equal to 5"")  # ✅ 実行される
else:
    print(""z is less than 5"")

👉if 文を使うことで、条件によって処理を分岐させることができる！",2,1,
120,"x = 15
if x > 20:
    result = ""Greater than 20""
elif x > 10:
    result = ""Greater than 10 but less than or equal to 20""
else:
    result = ""Less than or equal to 10""
print(result)

 上記のコードを実行すると、出力される値は？
1️⃣ ""Greater than 20""
2️⃣ ""Greater than 10 but less than or equal to 20""
3️⃣ ""Less than or equal to 10""
4️⃣ Error（エラーが発生する）","2️⃣ ""Greater than 10 but less than or equal to 20""","🔹 if-elif-else とは？
if-elif-else は、複数の条件を順番にチェックして、最初に真（True）になった条件のブロックを実行する制御構造 です！

if は最初の条件が真かどうかをチェック。
elif は前の条件が偽の場合にさらに別の条件をチェック。
else はすべての条件が偽の場合に実行されるデフォルトのコードブロック。

✅ if-elif-else のポイント
✔ if、elif、else は条件に応じて処理を分岐させる！
✔ elif は複数の条件をチェックしたい時に使う！
✔ すべての条件が偽の場合は else が実行される！
✔ 条件が一致した時点で、他の条件は無視される！（最初に一致したブロックのみが実行）

📌 例: if-elif-else の使い方
# 異なる条件をチェック
x = 5
if x > 10:
    print(""Greater than 10"")
elif x == 5:
    print(""Equal to 5"")  # ✅ 実行される
else:
    print(""Less than 5"")

# 条件がすべて偽の場合
y = 3
if y > 5:
    print(""Greater than 5"")
elif y == 4:
    print(""Equal to 4"")
else:
    print(""Less than 4"")  # ✅ 実行される

👉if-elif-else を使うと、複数の条件を効率的にチェックできる！",2,1,
121,"x = 0
while x < 3:
    print(x)
    x += 1

上記のコードを実行すると、出力される値は？
1️⃣ 0 1 2（0 から 2 まで出力）
2️⃣ 1 2 3（1 から 3 まで出力）
3️⃣ 0 1 2 3（0 から 3 まで出力）
4️⃣ Error（エラーが発生する）","1️⃣ 0 1 2（0 から 2 まで出力）","🔹 while ループとは？
while ループは、指定された条件が True の間、繰り返し処理を行うループ構造 です！

条件が真（True）の場合に、ループ内の処理を繰り返す！
条件が偽（False）になると、ループが終了する！

✅ while ループのポイント
✔ while は条件が真の間、繰り返し処理を行う！
✔ 条件が偽になったらループが終了！
✔ x += 1 のように、ループ内で変数を変更しないと無限ループになる！
✔ while ループの条件に注意して、適切な終了条件を設定しよう！

📌 例: while ループの使い方
# 基本的な while ループ
count = 0
while count < 5:
    print(count)
    count += 1
# ✅ 0 1 2 3 4

# 無限ループ（適切な終了条件がない場合）
# while True:  
#     print(""This will run forever!"")  # 無限ループになるので注意

# 条件が偽になるまでループ（入力を受け付ける）
while True:
    user_input = input(""Enter a number (or 'quit' to stop): "")
    if user_input == ""quit"":
        break
    print(f""You entered: {user_input}"")
👉 while ループを使うと、条件が満たされている限り繰り返し処理ができる！",2,1,
122,"fruits = [""apple"", ""banana"", ""cherry""]
for fruit in fruits:
    print(fruit)

上記のコードを実行すると、出力される値は？
1️⃣ apple banana cherry（スペース区切りで1行に表示）
2️⃣ apple, banana, cherry（カンマ区切りで表示）
3️⃣
　　apple
　　banana
　　cherry
　（1行ずつ表示）
4️⃣ Error（エラーが発生する）","3️⃣
　　apple
　　banana
　　cherry
　（1行ずつ表示）","🔹 for ループとは？
for ループは、イテラブル（反復可能なデータ構造）を反復して要素を1つずつ取り出して処理する構文 です！

リスト、タプル、文字列、辞書などに適用可能！
for ループ内では反復処理を行い、指定されたコードブロックを繰り返し実行します。

✅ for ループのポイント
✔ for ループはイテラブルオブジェクト（リスト、タプル、文字列など）の要素を順番に取り出して処理する！
✔ リストや文字列などの各要素を使って、繰り返し処理を行う！
✔ for ループの中で反復するデータにアクセスできる！

📌 例: for ループの使い方
# リストを反復処理
fruits = [""apple"", ""banana"", ""cherry""]
for fruit in fruits:
    print(fruit)  # ✅ 1行ずつ出力

# 文字列を反復処理
word = ""hello""
for letter in word:
    print(letter)  # ✅ 1文字ずつ出力

# 範囲を使って反復
for i in range(5):  
    print(i)  # ✅ 0 1 2 3 4

# 辞書のキーと値を反復処理
person = {""name"": ""Alice"", ""age"": 25}
for key, value in person.items():
    print(key, value)  # ✅ name Alice, age 25

👉 for ループを使うと、イテラブルの要素を効率的に取り出して処理することができる！",2,1,
123,"for i in range(3, 6):
    print(i)

上記のコードを実行すると、出力される値は？
1️⃣ 3 4 5（範囲内の値を1行で表示）
2️⃣ 3 4（範囲の終わりを含まない）
3️⃣ 3 4 5 6（範囲の終わりも含む）
4️⃣ Error（エラーが発生する）","1️⃣ 3 4 5（範囲内の値を1行で表示）","🔹 range() とは？
range() は、指定した範囲の整数を生成する組み込み関数 です！

range(start, stop) は、start から stop-1 までの整数を生成します。
range(start, stop, step) は、start から stop-1 まで、step の間隔で整数を生成します。
👉 stop の値は含まれない！ つまり、range(3, 6) は 3 から 5 までの数値を返します。

✅ range() のポイント
✔ range(start, stop) は start から stop-1 までの整数を返す！
✔ stop は含まれないので、range(3, 6) では 6 は含まれない！
✔ range(start, stop, step) のように、間隔（step）を指定できる！

📌 例: range() の使い方
# 基本的な範囲の指定
for i in range(3, 6):  
    print(i)  # ✅ 3 4 5

# `step` を指定して間隔を変更
for i in range(0, 10, 2):  
    print(i)  # ✅ 0 2 4 6 8

# `range()` をリストに変換
print(list(range(5)))  # ✅ [0, 1, 2, 3, 4]

# 逆順で数値を生成（`step=-1`）
for i in range(5, 0, -1):  
    print(i)  # ✅ 5 4 3 2 1

👉 range() を使うと、指定した範囲の整数を効率的に生成できる！",2,1,
124,"for i in range(5):
    if i == 3:
        break
    print(i)

上記のコードを実行すると、出力される値は？
1️⃣ 0 1 2（i == 3 の時点でループが中断）
2️⃣ 0 1 2 3（ループが最後まで実行される）
3️⃣ 0 1 2 3 4（全ての値が出力される）
4️⃣ Error（エラーが発生する）","1️⃣ 0 1 2（i == 3 の時点でループが中断）","🔹 break の使い方
break は、ループ（for や while）の実行を強制的に終了させるキーワード です！

break を使うと、ループの条件に関係なくその時点でループを抜けることができる！
ループの途中で特定の条件が満たされた場合に、ループを中断したいときに使います。

✅ break のポイント
✔ break はループを強制的に終了させる！
✔ 特定の条件が満たされた時にループを中断したい場合に便利！
✔ while や for ループの中で使用可能！

📌 例: break を使ったループの中断
# `break` を使ってループを途中で中断
for i in range(5):
    if i == 3:
        break  # 3になったらループを終了
    print(i)  # ✅ 0 1 2（3は表示されない）

# `while` ループで `break` を使う
x = 0
while x < 10:
    if x == 5:
        break  # xが5になったらループを終了
    print(x)
    x += 1  # ✅ 0 1 2 3 4（5は表示されない）
👉 break を使うと、条件に応じてループを途中で終了させることができる！",2,1,
125,"for i in range(5):
    if i == 3:
        continue
    print(i)

上記のコードを実行すると、出力される値は？
1️⃣ 0 1 2 3 4（すべての値が出力される）
2️⃣ 0 1 2 4（i == 3 の時だけスキップ）
3️⃣ 0 1 2（i == 3 の時とそれ以外の数もスキップ）
4️⃣ Error（エラーが発生する）","2️⃣ 0 1 2 4（i == 3 の時だけスキップ）","🔹 continue の使い方
continue は、ループの中で条件が真の場合に、その反復処理をスキップして次の反復に進ませるキーワード です！

continue はその後のコードを実行せず、次のループに進むために使います。
break と異なり、ループ全体を終了させるのではなく、次の繰り返しに移行します。

✅ continue のポイント
✔ continue は現在のループをスキップして次の反復に進む！
✔ 特定の条件のときだけ処理を飛ばしたい場合に便利！
✔ while や for ループ内で使用可能！

📌 例: continue を使ったループのスキップ
# `continue` を使ってループ内の特定の反復をスキップ
for i in range(5):
    if i == 3:
        continue  # 3をスキップ
    print(i)  # ✅ 0 1 2 4（3は表示されない）

# `while` ループで `continue` を使う
x = 0
while x < 5:
    x += 1
    if x == 3:
        continue  # xが3のときスキップ
    print(x)  # ✅ 1 2 4 5（3は表示されない）
👉 continue を使うことで、特定の条件に合ったループの反復をスキップすることができる！",2,1,
126,"for i in range(2):
    for j in range(3):
        print(i, j)

 上記のコードを実行すると、出力される値は？
1️⃣
0 0
0 1
0 2
1 0
1 1
1 2
（i と j の組み合わせで出力）

2️⃣
0 1
1 2
2 3
（i と j の順番で出力）

3️⃣
0 0 0
1 1 1
（i ごとにすべての j を表示）

4️⃣ Error（エラーが発生する）","1️⃣
0 0
0 1
0 2
1 0
1 1
1 2
（i と j の組み合わせで出力）","🔹 ネストされたループとは？
ネストされたループ（ループ内ループ）は、1つのループの中に別のループを配置する方法 です！

外側のループが1回実行されるごとに、内側のループがすべて繰り返し実行されます。
内側のループが終了した後に、外側のループが次の反復に進みます。

✅ ネストされたループのポイント
✔ 外側のループが1回実行されると、内側のループはすべて繰り返される！
✔ 内側のループがすべて実行された後、外側のループが次の反復に進む！
✔ ネストされたループを使うことで、複雑な処理を繰り返し行うことができる！

📌 例: ネストされたループの使い方
# 外側のループと内側のループ
for i in range(2):  # i = 0, 1
    for j in range(3):  # j = 0, 1, 2
        print(i, j)  # ✅ i と j の組み合わせ

# 二重リストを使ったループ
matrix = [[1, 2], [3, 4], [5, 6]]
for row in matrix:
    for element in row:
        print(element)  # ✅ 1 2 3 4 5 6

👉ネストされたループを使うと、複数の条件に基づいた繰り返し処理ができる！",2,1,
127,"x = 0
while x < 5:
    x += 1
    if x == 3:
        continue  # xが3のときスキップ
    print(x)

上記のコードを実行すると、出力される値は？
1️⃣ 1 2 3 4 5（5まで出力）
2️⃣ 1 2 4 5（3はスキップされる）
3️⃣ 1 2 3（3まで出力）
4️⃣ Error（エラーが発生する","2️⃣ 1 2 4 5（3はスキップされる）","🔹 continue の動きとループの終了条件
continue を使うと、その反復処理をスキップして次の反復に進む という動きになります。
この場合、x == 3 の時に continue が実行されるので、3 はスキップされ、4 と 5 が出力されることになります。
そして、x < 5 の条件が満たされなくなる（x が 5 になった時）とループが終了します。

📌 コードの動作
x = 0
while x < 5:
    x += 1  # まず x の値を 1 増やす
    if x == 3:
        continue  # x が 3 の時はスキップ
    print(x)  # 3 はスキップされ、それ以外は出力される

・最初に x = 0 からスタート。
・x += 1 で x が 1 になり、print(x) で 1 が出力。
・次に x += 1 で、x が 2 になり、print(x) で 2 が出力。
・次の　x += 1 で　x == 3 になった時、continue で print(x) をスキップ。
・その後、次の　x += 1 で x は 4 になり、print(x) で 4 が出力。
・x += 1 で　x が 5 になり、print(x) で 5 が出力されてループ終了。
🔹 実行結果
1
2
4
5
✅ 正解は 2️⃣ 1 2 4 5（3はスキップされる）！ 🎯

✅ continue とループの動きのポイント
✔ continue はループ内で現在の反復をスキップし、次の反復に進ませる！
✔ while ループの終了条件に注意して、予期せぬ動作が起こらないようにする！
✔ continue と if 条件を組み合わせて、特定の値をスキップさせることができる！

📌 例: continue を使ったループのスキップ
# `continue` を使って特定の値をスキップ
x = 0
while x < 5:
    x += 1
    if x == 3:
        continue  # 3をスキップ
    print(x)  # ✅ 1 2 4 5（3は表示されない）

# `for` ループで `continue` を使う
for i in range(5):
    if i == 2:
        continue  # 2をスキップ
    print(i)  # ✅ 0 1 3 4（2は表示されない）

👉 continue を使うと、特定の条件に基づいた反復処理をスキップすることができる！",2,1,
128,"for i in range(3):
    print(i)
else:
    print(""Loop finished"")

上記のコードを実行すると、出力される値は？
1️⃣ 0 1 2
　　Loop finished
　（ループが終了した後にメッセージが表示）
2️⃣ 0 1 2 Loop finished
　（ループが終了した後にメッセージが同じ行に表示）
3️⃣ Loop finished（ループ内は出力されない）
4️⃣ Error（エラーが発生する）","1️⃣ 0 1 2
　　Loop finished
　（ループが終了した後にメッセージが表示）","🔹 else とループの組み合わせ
else は通常、条件文（if）の後に使われますが、ループ（for や while）においても使用することができます。

👉else はループが正常に完了した場合に実行される（途中で break で中断されなかった場合）。
ループ内で break が呼ばれると else は実行されません。

✅ else とループのポイント
✔ else はループが正常に終了した場合に実行される！
✔ ループ内で break が呼ばれた場合、else は実行されない！
✔ for ループや while ループの終了後に何か処理を追加したいときに便利！

📌 例: else とループの組み合わせ
# `for` ループで `else` を使う
for i in range(3):
    print(i)
else:
    print(""Loop finished"")  # ✅ 実行される

# `while` ループで `else` を使う
x = 0
while x < 3:
    print(x)
    x += 1
else:
    print(""While loop finished"")  # ✅ 実行される

# `break` を使った例（`else` は実行されない）
for i in range(5):
    if i == 3:
        break  # 3でループを中断
else:
    print(""Loop finished"")  # ✅ 実行されない
👉 else を使うと、ループが正常に終了した後に処理を追加できる！",2,1,
129,"for i in range(1, 10, 3):
    print(i)

上記のコードを実行すると、出力される値は？
1️⃣ 1 4 7（1から始まり3つずつ増加）
2️⃣ 1 3 5 7 9（1から始まり2ずつ増加）
3️⃣ 1 2 3 4 5 6 7 8 9（1から9までのすべての数字）
4️⃣ Error（エラーが発生する）","1️⃣ 1 4 7（1から始まり3つずつ増加）","🔹 range(start, stop, step) の使い方
range() 関数は、start から stop-1 までの範囲を生成し、step によってその間隔を指定できます。

start: 開始値
stop: 終了値（stop は含まれません）
step: 増加または減少する値
この例では、range(1, 10, 3) が 1から始まり、3つずつ増加して10未満まで進む という動作になります。

✅ range() のポイント
✔ start から stop-1 までの範囲を生成！
✔ step によって間隔を指定できる！
✔ step が正なら増加、負なら減少する！

📌 例: range() の使い方
# 基本的な `range()` の使い方
for i in range(1, 5):  
    print(i)  # ✅ 1 2 3 4

# `step` を使って間隔を変更
for i in range(1, 10, 2):  
    print(i)  # ✅ 1 3 5 7 9

# 逆順にする `step = -1`
for i in range(10, 0, -2):
    print(i)  # ✅ 10 8 6 4 2

# `range()` をリストに変換
print(list(range(1, 5)))  # ✅ [1, 2, 3, 4]

👉 range() を使うことで、効率的に反復処理を行うことができる！",2,1,
130,"for i in range(5):
    if i == 3:
        break  # i が 3 になった時にループを終了
    print(i)  # i を出力
else:
    print(""Loop finished"")  # `break` によってループが終了したので実行されない

上記のコードを実行すると、出力される値は？
1️⃣ 0 1 2 3 Loop finished（ループ終了後にメッセージが表示）
2️⃣ 0 1 2（3でループが中断され、メッセージは表示されない）
3️⃣ 0 1 2 3 4（全ての値が出力される）
4️⃣ Error（エラーが発生する）","2️⃣ 0 1 2（3でループが中断され、メッセージは表示されない）","🔹 break と else の関係
break が実行されると、ループが即座に終了します。
そのため、else は **break によってループが中断されなければ実行されますが、break が呼ばれると else は無視されます。

✅ break と else のポイント
✔ break はループを途中で終了させる！
✔ else はループが正常に終了した場合に実行される！
✔ break によってループが中断された場合、else は実行されない！

📌 例: break と else の使い方
# `break` が実行された場合、`else` は実行されない
for i in range(5):
    if i == 3:
        break  # 3でループが終了
    print(i)  # i を出力
else:
    print(""Loop finished"")  # ✅ 実行されない

# `break` がない場合、`else` は実行される
for i in range(5):
    print(i)
else:
    print(""Loop finished"")  # ✅ 実行される

👉 break と else の組み合わせを理解して、ループの終了動作を制御しよう！",2,1,
131,"x = 0
while x < 5:
    print(x)
    x += 2

上記のコードを実行すると、出力される値は？
1️⃣ 0 2 4（2ずつ増加）
2️⃣ 0 1 2 3 4（1ずつ増加）
3️⃣ 1 3 5（ループが無限に続く）
4️⃣ Error（エラーが発生する）","1️⃣ 0 2 4（2ずつ増加）","🔹 while ループの動き
while ループは、指定された条件が True の間、繰り返し処理を行います。
このコードの場合、x が 0 からスタートして、x += 2 によって2ずつ増加します。

最初に x = 0 からスタートし、条件 x < 5 が真であればループが実行されます
その後、x += 2 で x が2ずつ増加します
ループは x < 5 の条件が False になるまで続きます。

✅ while ループのポイント
✔ while ループは条件が真の間、繰り返し処理を行う！
✔ x += 2 で変数 x を増加させて、次のループに進んでいく！
✔ while ループの終了条件を適切に設定しないと無限ループになってしまうので注意！

📌 例: while ループの使い方
# 1から10までの偶数を表示
x = 0
while x < 10:
    print(x)
    x += 2  # ✅ 0 2 4 6 8

# 無限ループの例（条件を適切に設定しないと無限に続く）
x = 0
while True:
    print(x)
    x += 1
    if x == 10:
        break  # ✅ 0 1 2 3 4 5 6 7 8 9（無限ループを停止）

👉 while ループを使って条件を満たす間、反復処理を行うことができる！",2,1,
132,"for i in range(0, 10, 2):
    print(i)

 上記のコードを実行すると、出力される値は？
1️⃣ 0 2 4 6 8（0から2ずつ増加）
2️⃣ 1 3 5 7 9（1から2ずつ増加）
3️⃣ 0 1 2 3 4 5 6 7 8 9（1ずつ増加）
4️⃣ Error（エラーが発生する）","1️⃣ 0 2 4 6 8（0から2ずつ増加）","🔹 range() の step を使った範囲の指定
range() 関数は、開始値から終了値未満までの範囲を生成しますが、step を使って値の増加間隔を指定することができます。

start: 範囲の開始値
stop: 範囲の終了値（stop は含まれません）
step: 増加または減少する値

✅ range() のポイント
✔ range(start, stop, step) で開始値、終了値、間隔を指定！
✔ step が正なら増加、負なら減少する！
✔ 終了値 stop は含まれない！

📌 例: range() を使った範囲の指定
# 基本的な `range()` の使い方
for i in range(0, 10, 2):  
    print(i)  # ✅ 0 2 4 6 8

# `step` を使って間隔を変更
for i in range(1, 10, 2):  
    print(i)  # ✅ 1 3 5 7 9

# 逆順にする `step = -1`
for i in range(10, 0, -2):
    print(i)  # ✅ 10 8 6 4 2

# `range()` をリストに変換
print(list(range(5)))  # ✅ [0, 1, 2, 3, 4]

👉 range() を使うことで、効率的に反復処理を行うことができる！",2,1,
133,"fruits = [""apple"", ""banana"", ""cherry""]
for i in fruits:
    print(i)

上記のコードを実行すると、出力される値は？
1️⃣ apple banana cherry（リストの要素を1行で表示）

2️⃣
apple
banana
cherry
（リストの要素を1行ずつ表示）

3️⃣ applebanana cherry（リストの要素が一部繋がって表示）

4️⃣ Error（エラーが発生する）","2️⃣
apple
banana
cherry
（リストの要素を1行ずつ表示）","🔹 for ループとリストの動き
for ループは、リストやタプルなどのイテラブル（反復可能）なオブジェクトを順番に処理するために使用します。
この場合、リスト fruits の各要素を順番に取り出して、それを print() で表示しています。

✅ for ループのポイント
✔ リストなどのイテラブルなオブジェクトを順番に処理することができる！
✔ for ループの中で各要素にアクセスして操作できる！
✔ print() で1行ずつ出力できる！

📌 例: for ループでリストを扱う
# リストの要素を1行ずつ表示
fruits = [""apple"", ""banana"", ""cherry""]
for fruit in fruits:
    print(fruit)  # ✅ apple banana cherry

# リスト内の文字列を1つずつ大文字に変換
for fruit in fruits:
    print(fruit.upper())  # ✅ APPLE BANANA CHERRY

👉for ループを使うことで、リストやタプルの各要素を効率よく処理できる！",2,1,
134,"numbers = list(range(1, 6))
for i in numbers:
    print(i * 2)

上記のコードを実行すると、出力される値は？
1️⃣ 2 4 6 8 10（1から5までの数を2倍して表示）
2️⃣ 1 2 3 4 5（1から5までの数をそのまま表示）
3️⃣ 1 2 3 4 5 6 7 8 9 10（1から10までの数をそのまま表示）
4️⃣ Error（エラーが発生する）","1️⃣ 2 4 6 8 10（1から5までの数を2倍して表示）","🔹 range() とリストを使った繰り返し処理
range() 関数は、指定した範囲内の整数を生成するために使用されます。この場合、range(1, 6) は 1 から 5 までの数を生成します（6 は含まれません）。
その後、list() を使ってその範囲をリストに変換しています。

✅ range() とループのポイント
✔ range() を使って整数の範囲を簡単に生成できる！
✔ list() を使うと、生成した範囲をリストに変換できる！
✔ for ループを使ってリストの要素を順番に処理し、任意の操作を実行できる！

📌 例: range() と for を使ったリストの処理
# range() で範囲を生成してリストに変換
numbers = list(range(1, 6))
for num in numbers:
    print(num * 2)  # ✅ 2 4 6 8 10

# 数字の累積を計算
total = 0
for num in range(1, 6):
    total += num  # 1 + 2 + 3 + 4 + 5
print(total)  # ✅ 15

👉 range() と for を使って、リストや範囲内の要素に対して様々な処理ができる！",1,1,
135,"person = {""name"": ""Alice"", ""age"": 25, ""city"": ""New York""}
for key, value in person.items():
    print(key, value)

上記のコードを実行すると、出力される値は？
1️⃣
name Alice
age 25
city New York
（辞書のキーと値を1行ずつ表示）

2️⃣
Alice 25 New York
（辞書の値を1行ずつ表示）

3️⃣
name age city
（辞書のキーを1行ずつ表示）

4️⃣ Error（エラーが発生する）","1️⃣
name Alice
age 25
city New York","🔹 items() メソッドを使った辞書の反復
items() メソッドを使うと、辞書のキーと値のペアを同時に取り出すことができます。
この場合、for key, value in person.items() は、person 辞書のすべてのキーと値を順番に取得し、key と value に代入して処理します。

✅ items() メソッドのポイント
✔ items() は辞書のキーと値をペアで取り出すために使用！
✔ for ループで辞書のすべてのペアを順番に処理できる！
✔ key, value に代入して、キーと値を同時に扱える！

📌 例: items() メソッドを使った辞書の処理

・辞書のキーと値を1行ずつ表示
person = {""name"": ""Alice"", ""age"": 25, ""city"": ""New York""}
for key, value in person.items():
    print(f""{key}: {value}"")

・ 辞書の値を変換
person = {""name"": ""Alice"", ""age"": 25}
for key, value in person.items():
    person[key] = str(value)  # 値を文字列に変換
print(person)  # ✅ {""name"": ""Alice"", ""age"": ""25""}

📌 items() メソッドを活用すると、辞書を効率よく処理できる！",2,2,
136,"numbers = [1, 2, 2, 3, 4, 4, 5]
unique_numbers = set(numbers)
print(unique_numbers)

上記のコードを実行すると、出力される値は？
1️⃣ {1, 2, 3, 4, 5}（重複を削除したセット）
2️⃣ [1, 2, 3, 4, 5]（リストのまま出力される）
3️⃣ {1, 2, 2, 3, 4, 4, 5}（重複を削除しない）
4️⃣ Error（エラーが発生する）","1️⃣ {1, 2, 3, 4, 5}（重複を削除したセット）","🔹 set() を使った重複の削除
set() は**セット（集合）**を作成するための関数で、セットは重複する要素を持たない特性があります。
そのため、リストに重複が含まれていても、set() を使うことで自動的に重複が削除され、一意な要素だけが残ります。

✅ set() のポイント
✔ set() はリストやタプルから重複を削除して一意な要素を保持する！
✔ セットの要素は順番を保持しない（順序が不定）！
✔ 集合演算（和集合、積集合、差集合など）にも利用できる！

📌 例: set() を使った重複削除

・ リストから重複を削除
numbers = [1, 2, 2, 3, 4, 4, 5]
unique_numbers = set(numbers)  
print(unique_numbers)  # ✅ {1, 2, 3, 4, 5}

・セットの集合演算
set_a = {1, 2, 3}
set_b = {2, 3, 4}
union = set_a | set_b  # 和集合
print(union)  # ✅ {1, 2, 3, 4}

intersection = set_a & set_b  # 積集合
print(intersection)  # ✅ {2, 3}

difference = set_a - set_b  # 差集合
print(difference)  # ✅ {1}

📌 set() を活用して重複削除や集合演算が簡単にできる！",1,2,
137,"for i in range(5):
    if i == 3:
        continue
    print(i)

上記のコードを実行すると、出力される値は？
1️⃣ 0 1 2 4（3はスキップされる）
2️⃣ 0 1 2 3 4（すべての値が出力される）
3️⃣ 0 1 2（3と4はスキップされる）
4️⃣ Error（エラーが発生する）","1️⃣ 0 1 2 4（3はスキップされる）","🔹 continue の使い方
continue は、ループ内で使用されると、その時点での繰り返し処理をスキップして次の反復に進むために使います。
具体的には、continue が発動した時、その後の処理（print(i)）をスキップして、次のループへ進みます。

✅ continue のポイント
✔ continue はループ内で条件に一致した場合に、その反復処理をスキップして次の反復に進む！
✔ 条件を満たさなければ通常通り処理が続く！

📌 例: continue の使い方

・ `continue` を使って特定の値をスキップ
for i in range(5):
    if i == 3:
        continue  # i が 3 のときスキップ
    print(i)  # ✅ 0 1 2 4

・`continue` を使って偶数のみ出力
for i in range(5):
    if i % 2 != 0:
        continue  # i が奇数の時はスキップ
    print(i)  # ✅ 0 2 4

📌 continue を使うことで、特定の条件で処理をスキップして、効率よく反復処理を行うことができる！",2,2,
138,"for i in range(3):
    print(i)
else:
    print(""Loop finished"")

 上記のコードを実行すると、出力される値は？
1️⃣
0
1
2
Loop finished
（for ループが正常に完了した場合）

2️⃣
0
1
2
（else のメッセージは表示されない）

3️⃣
Loop finished
（else のメッセージだけ表示）

4️⃣ Error（エラーが発生する）","1️⃣
0
1
2
Loop finished
","🔹 else と for ループの組み合わせ
for ループにおいて、else ブロックはループが正常に完了した場合に実行されます。
つまり、ループが**breakによって中断されなかった場合**、else が実行されます。

✅ else と for ループのポイント
✔ else は、for ループが正常に完了した場合にのみ実行される！
✔ break によってループが中断された場合、else は実行されない！

📌 例: else を使ったループ処理
・ `for` ループでの正常終了時に `else` が実行される
for i in range(3):
    print(i)  # ✅ 0 1 2
else:
    print(""Loop finished"")  # ✅ Loop finished

・ `break` でループが中断された場合、`else` は実行されない
for i in range(3):
    if i == 1:
        break  # `i == 1` でループが中断される
    print(i)
else:
    print(""Loop finished"")  # ✅ このメッセージは表示されない

📌 else を使うと、ループが正常に完了したかどうかに応じて異なる処理を実行できる！",2,2,
139,"x = 0
while x < 5:
    print(x)
    x += 1

上記のコードを実行すると、出力される値は？
1️⃣ 0 1 2 3 4（x が 5 未満の間、1ずつ増加）
2️⃣ 1 2 3 4 5（x が 5 以上になった時にループ終了）
3️⃣ 0 1 2 3（x が 4 のときに終了）
4️⃣ Error（エラーが発生する）","1️⃣ 0 1 2 3 4（x が 5 未満の間、1ずつ増加）","🔹 while ループの動き
while ループは、指定した条件が True の間、繰り返し処理を実行する構文です。
この場合、x < 5 の条件が True の間、x が 1ずつ増加して処理が繰り返されます。

✅ while ループのポイント
✔ while ループは、条件が True の間繰り返し処理を実行！
✔ x += 1 で x を1ずつ増加させ、条件 x < 5 を満たす限りループが続く！
✔ x の値が5を超えると、ループが終了！

📌 例: while ループを使ったカウント処理

・ `while` ループで `x` を増加させる
x = 0
while x < 5:
    print(x)  # ✅ 0 1 2 3 4
    x += 1

・ `x` を減少させる
x = 5
while x > 0:
    print(x)  # ✅ 5 4 3 2 1
    x -= 1

📌 while ループを使うと、指定した条件に基づいて繰り返し処理を行うことができる！",2,2,
140,"for i in range(5):
    if i == 3:
        break
    print(i)

 上記のコードを実行すると、出力される値は？
1️⃣ 0 1 2（i == 3 のときにループを終了）
2️⃣ 0 1 2 3 4（break がないため、すべての値が表示）
3️⃣ 0 1 2 3（break がない場合と同じ）
4️⃣ Error（エラーが発生する）","1️⃣ 0 1 2（i == 3 のときにループを終了）","🔹 break の使い方
break は、ループを途中で終了させるために使用されます。
ループ内で break が実行されると、その時点でループが終了し、残りの繰り返し処理は実行されません。

✅ break のポイント
✔ break は、ループ内で条件を満たしたときに、その時点でループを終了させる！
✔ break は通常、if 文と組み合わせて使い、特定の条件でループを早期に終了させる！

📌 例: break を使ったループの終了

・ `break` を使ってループを途中で終了
for i in range(5):
    if i == 3:
        break  # 3で終了
    print(i)  # ✅ 0 1 2

・ 条件に達したときに `break` を使う
while True:  # 無限ループ
    user_input = input(""Enter 'q' to quit: "")
    if user_input == 'q':
        break  # 'q' が入力されたらループを終了

👉 break を使うことで、ループを途中で終了させることができる！",2,2,
141,"for i in range(5):
    if i == 2:
        continue
    print(i)

 上記のコードを実行すると、出力される値は？
1️⃣ 0 1 2 3 4（すべての値が出力される）
2️⃣ 0 1 3 4（i == 2 のときだけスキップ）
3️⃣ 1 2 3 4（最初の0をスキップ）
4️⃣ Error（エラーが発生する）","2️⃣ 0 1 3 4（i == 2 のときだけスキップ）","🔹 continue の使い方
continue は、ループ内で特定の条件を満たしたとき、その反復処理をスキップして次の反復に進むために使います。
この場合、i == 2 のときに continue が発動し、print(i) の処理がスキップされます。

✅ continue のポイント
✔ continue はループ内で条件に一致した場合、その反復処理をスキップして次の反復に進む！
✔ 条件を満たさなければ通常通り処理が続く！

📌 例: continue の使い方

・ `continue` を使って特定の値をスキップ
for i in range(5):
    if i == 2:
        continue  # i が 2 のときスキップ
    print(i)  # ✅ 0 1 3 4

・ `continue` を使って偶数のみ出力
for i in range(5):
    if i % 2 != 0:
        continue  # i が奇数の時はスキップ
    print(i)  # ✅ 0 2 4

👉 continue を使うことで、特定の条件で処理をスキップして、効率よく反復処理を行うことができる！",2,2,
142,"person = {""name"": ""Alice"", ""age"": 25, ""city"": ""New York""}
for key, value in person.items():
    print(f""{key}: {value}"")

 上記のコードを実行すると、出力される値は？

1️⃣
name: Alice
age: 25
city: New York
（辞書のキーと値を1行ずつ表示）

2️⃣
Alice: 25
New York: name
（値とキーが逆に表示）

3️⃣
name age city
Alice 25 New York
（キーと値を1行ずつ表示）

4️⃣ Error（エラーが発生する）","1️⃣
name: Alice
age: 25
city: New York
（辞書のキーと値を1行ずつ表示）","🔹 辞書の items() メソッド
items() メソッドは、辞書のキーと値をペアで取得するために使用します。
このメソッドを使うと、各キーと対応する値を同時に取り出すことができます。

✅ items() メソッドのポイント
✔ items() は辞書のキーと値をペアで取り出すために使用！
✔ for ループを使って辞書のすべてのペアを順番に処理できる！
✔ key, value に代入して、キーと値を同時に扱える！

📌 例: items() メソッドを使った辞書の処理

・ 辞書のキーと値を1行ずつ表示
person = {""name"": ""Alice"", ""age"": 25, ""city"": ""New York""}
for key, value in person.items():
    print(f""{key}: {value}"")

・ 辞書の値を変換
person = {""name"": ""Alice"", ""age"": 25}
for key, value in person.items():
    person[key] = str(value)  # 値を文字列に変換
print(person)  # ✅ {""name"": ""Alice"", ""age"": ""25""}

👉 items() メソッドを活用すると、辞書を効率よく処理できる！",2,2,
143,"fruits = [""apple"", ""banana"", ""cherry""]
for i in fruits:
    if i == ""banana"":
        continue
    print(i)

上記のコードを実行すると、出力される値は？
1️⃣ apple banana cherry（すべてのフルーツが表示される）
2️⃣ apple cherry（banana はスキップされる）
3️⃣ banana（banana だけ表示される）
4️⃣ Error（エラーが発生する）","2️⃣ apple cherry（banana はスキップされる）","🔹 continue を使った要素のスキップ
continue は、ループ内で特定の条件に合致したとき、その反復をスキップし、次の反復に進むために使われます。
このコードでは、リスト fruits の中から**banana の時にcontinue が発動し、print(i) がスキップされます**。そのため、banana は表示されません。

✅ continue のポイント
✔ continue はループ内で条件を満たしたとき、その反復処理をスキップして次の反復に進む！
✔ continue は通常、if 文と組み合わせて使い、特定の条件で処理をスキップする！

📌 例: continue を使った要素のスキップ

・ `continue` を使って特定の値をスキップ
fruits = [""apple"", ""banana"", ""cherry""]
for fruit in fruits:
    if fruit == ""banana"":
        continue  # ""banana"" のときスキップ
    print(fruit)  # ✅ apple cherry

・ 偶数だけを表示
numbers = [1, 2, 3, 4, 5]
for num in numbers:
    if num % 2 != 0:
        continue  # 奇数のときスキップ
    print(num)  # ✅ 2 4
👉 continue を使うことで、特定の条件で処理をスキップして、効率よく反復処理を行うことができる！",2,2,
144,"numbers = [1, 2, 3, 4, 5]
squared_even = [x**2 for x in numbers if x % 2 == 0]
print(squared_even)

上記のコードを実行すると、出力される値は？
1️⃣ [4, 16]（偶数の平方）
2️⃣ [1, 4, 9, 16, 25]（すべての平方）
3️⃣ [2, 4, 6, 8, 10]（偶数の倍数）
4️⃣ Error（エラーが発生する）","1️⃣ [4, 16]（偶数の平方）","🔹 リスト内包表記の条件付き
リスト内包表記は、リストを生成するための簡潔な方法です。
for ループと条件を組み合わせて、リストを生成する際に条件に合致する要素のみを処理できます。
この場合、x % 2 == 0 の条件に合致する偶数のみを平方してリストに追加しています。

✅ リスト内包表記のポイント
✔ リスト内包表記で、for と条件を使って、必要な要素だけを簡単に処理できる！
✔ if の条件を使って、特定の条件に一致する要素だけを処理できる！

📌 例: リスト内包表記の条件付き

・偶数の平方のみ計算
numbers = [1, 2, 3, 4, 5]
squared_even = [x**2 for x in numbers if x % 2 == 0]
print(squared_even)  # ✅ [4, 16]

・ 奇数だけをリストにする
odd_numbers = [x for x in numbers if x % 2 != 0]
print(odd_numbers)  # ✅ [1, 3, 5]

👉 リスト内包表記を使うと、リストの作成や条件付き処理が簡潔に記述できる！",2,2,
145,"numbers = [1, 2, 3, 4, 5]
squared_numbers = list(map(lambda x: x**2, numbers))
print(squared_numbers)

上記のコードを実行すると、出力される値は？
1️⃣ [1, 4, 9, 16, 25]（各値を2乗したリスト）
2️⃣ [2, 4, 6, 8, 10]（各値を2倍したリスト）
3️⃣ [1, 2, 3, 4, 5]（元のリストのまま）
4️⃣ Error（エラーが発生する）","1️⃣ [1, 4, 9, 16, 25]（各値を2乗したリスト）","🔹 map() 関数の使い方
map() 関数は、指定した関数をリストのすべての要素に適用するための便利な関数です。
このコードでは、map() を使って、リスト numbers の各要素に対して、lambda 関数（x: x**2）を適用しています。これにより、リストの各要素が2乗された値に変換されます。

✅ map() 関数のポイント
✔ map() は、関数をリストの各要素に適用して新しいリストを生成！
✔ lambda を使って簡単に関数を定義でき、リストの操作が簡潔に行える！
✔ list() で map() の結果をリストに変換して利用する！

📌 例: map() を使ったリスト処理

・`map()` で値を2倍にする
numbers = [1, 2, 3, 4, 5]
doubled_numbers = list(map(lambda x: x*2, numbers))
print(doubled_numbers)  # ✅ [2, 4, 6, 8, 10]

・ `map()` で文字列の長さを計算
strings = [""apple"", ""banana"", ""cherry""]
lengths = list(map(len, strings))
print(lengths)  # ✅ [5, 6, 6]

👉 map() はリストを効率的に処理できる便利な関数！",2,2,
146,"fruits = [""apple"", ""banana"", ""cherry""]
for i in range(len(fruits)):
    if fruits[i] == ""banana"":
        fruits[i] = ""grape""
    print(fruits[i])

上記のコードを実行すると、出力される値は？
1️⃣
apple
grape
cherry
（banana を grape に変更）

2️⃣
apple
banana
cherry
（リストの変更なし）

3️⃣
apple
grape
grape
（banana が2回変更）

4️⃣ Error（エラーが発生する）","1️⃣
apple
grape
cherry
（banana を grape に変更）","🔹 リストの要素を変更する
このコードは、for ループを使用してリスト fruits の要素を順番にチェックし、特定の要素（""banana""）を見つけた場合にその要素を変更しています。
fruits[i] = ""grape"" で、banana を grape に変更しています。

✅ リストの要素変更のポイント
✔ リストの要素をインデックスでアクセスして変更できる！
✔ for ループとインデックスを使うことで、リストの要素を順番に変更可能！

📌 例: リスト内の特定の要素を変更

・リスト内の特定の要素を変更
fruits = [""apple"", ""banana"", ""cherry""]
for i in range(len(fruits)):
    if fruits[i] == ""banana"":
        fruits[i] = ""grape""  # banana を grape に変更
print(fruits)  # ✅ ['apple', 'grape', 'cherry']

・ 複数の要素を変更
for i in range(len(fruits)):
    if fruits[i] == ""apple"":
        fruits[i] = ""orange""  # apple を orange に変更
print(fruits)  # ✅ ['orange', 'grape', 'cherry']

👉 リストの要素を変更することで、リスト内のデータを効率よく更新できる！",2,2,
147,"numbers = [5, 2, 8, 1, 3]
sorted_numbers = sorted(numbers)
print(sorted_numbers)

 上記のコードを実行すると、出力される値は？
1️⃣ [1, 2, 3, 5, 8]（昇順に並べ替え）
2️⃣ [8, 5, 3, 2, 1]（降順に並べ替え）
3️⃣ [5, 2, 8, 1, 3]（元の順番のまま）
4️⃣ Error（エラーが発生する）","1️⃣ [1, 2, 3, 5, 8]（昇順に並べ替え）","🔹 sorted() を使ったリストの並べ替え
sorted() 関数は、リストを昇順または降順に並べ替えるために使用されます。

sorted() は元のリストを変更せず、新しいリストを返します（リスト自体を変更しない）。
並べ替えはデフォルトで昇順（小さい順）で行われます。

✅ sorted() のポイント
✔ sorted() はリストの要素を昇順に並べ替え、新しいリストを返す！
✔ 元のリストは変更されないので、元の順番を保ちたい場合に便利！
✔ 引数で reverse=True を指定すると降順に並べ替えられる！

📌 例: sorted() の使用例

・ 昇順に並べ替え
numbers = [5, 2, 8, 1, 3]
sorted_numbers = sorted(numbers)
print(sorted_numbers)  # ✅ [1, 2, 3, 5, 8]

・ 降順に並べ替え
sorted_numbers_desc = sorted(numbers, reverse=True)
print(sorted_numbers_desc)  # ✅ [8, 5, 3, 2, 1]

・ 元のリストはそのまま
print(numbers)  # ✅ [5, 2, 8, 1, 3]

👉 sorted() を使うことで、リストを並べ替えたり、元のリストを保持しつつ順序を変更することができる！",10,2,
148,"try:
    result = 10 / 0
except ZeroDivisionError:
    result = ""Cannot divide by zero""
print(result)

 上記のコードを実行すると、出力される値は？
1️⃣ Cannot divide by zero（ゼロ除算エラーを処理）
2️⃣ None（エラーが発生しない）
3️⃣ Error（エラーが発生する）
4️⃣ 10（計算結果）","1️⃣ Cannot divide by zero（ゼロ除算エラーを処理）","🔹 try と except を使ったエラーハンドリング
Pythonでは、エラーが発生する可能性のあるコードを try ブロック内に入れ、そのエラーを except ブロックでキャッチして処理することができます。
このコードでは、ゼロ除算エラー（ZeroDivisionError）が発生することを想定して、エラーメッセージを表示するようにしています。

✅ try と except のポイント
✔ try ブロックでエラーを発生させる可能性のあるコードを実行！
✔ except ブロックで特定のエラーをキャッチし、適切な処理を行う！
✔ エラーが発生しなければ、except はスキップされ、通常通り処理が進む！

📌 例: try と except を使ったエラーハンドリング

・ゼロ除算エラーを処理
try:
    num = 10 / 0
except ZeroDivisionError:
    num = ""Error: Cannot divide by zero""
print(num)  # ✅ Error: Cannot divide by zero

・ リストのインデックスエラーを処理
try:
    lst = [1, 2, 3]
    print(lst[5])  # インデックス範囲外
except IndexError:
    print(""Error: Index out of range"")  # ✅ Error: Index out of range

👉 try と except を使うことで、プログラムのエラーを優雅に処理できる！",7,1,
149,"x = 0
while True:
    print(x)
    x += 1
    if x == 3:
        break

 上記のコードを実行すると、出力される値は？
1️⃣ 0 1 2（x == 3 の時点でループ終了）
2️⃣ 0 1 2 3（x == 3 を超えてもループ続行）
3️⃣ 0 1 2 3 4（無限ループ）
4️⃣ Error（エラーが発生する）","1️⃣ 0 1 2（x == 3 の時点でループ終了）","🔹 while True と break の使い方
while True は無限ループを作るための一般的な構文です。
この場合、while ループは無限に繰り返されますが、if x == 3 の条件が満たされると、break によってループが終了します。

✅ while True と break のポイント
✔ while True は無限ループを作成し、break を使って条件に合致したらループを終了する！
✔ break を使うことで、無限ループでも途中で終了条件を設定することができる！

📌 例: while True と break の使用
・無限ループを使って一定回数だけ繰り返す
count = 0
while True:
    count += 1
    if count > 5:
        break  # count が 5 を超えたらループを終了
    print(count)  # ✅ 1 2 3 4 5

👉while True と break は、無限ループを途中で終了させたい場合に便利！",2,2,
150,"x = 0
while x < 5:
    x += 1
    if x == 4:
        break
print(x)

上記のコードを実行すると、出力される値は？
1️⃣ 4（x == 4 でループ終了）
2️⃣ 5（x == 5 でループ終了）
3️⃣ 3（x == 3 でループ終了）
4️⃣ 6（x == 6 でループ終了）","1️⃣ 4（x == 4 でループ終了）","🔹 while ループと break の動き
このコードでは、while ループが x が5未満の間実行され、x が3から4に増加した時点で**break**によってループを終了します。
その後、print(x) で最終的に x の値が出力されます。

✅ while ループと break のポイント
✔ while ループは指定された条件が True の間繰り返し実行されます。
✔ break はループ内で特定の条件が満たされたときにループを強制的に終了します。
✔ print(x) ではループが終了した後の x の値が出力されます。

📌 例: while ループと break の使用
# `x == 4` のときにループを終了
x = 0
while x < 10:
    x += 1
    if x == 4:
        break  # 4 で終了
print(x)  # ✅ 4

・数値が偶数のときにループを終了
x = 0
while x < 5:
    if x % 2 == 0:
        break  # 偶数のときに終了
    x += 1
print(x)  # ✅ 0

👉 while ループと break を使って、特定の条件でループを終了させることができる！",2,2,
151,"x = 0
while x < 5:
    x += 1
    if x == 3:
        continue
    print(x)
    if x == 4:
        break

 上記のコードを実行すると、出力される値は？
1️⃣ 1 2 4（x == 3 の時にスキップ、x == 4 でループ終了）
2️⃣ 1 2 3 4（x == 3 の時にスキップ）
3️⃣ 1 2 3（x == 4 の時にスキップ）
4️⃣ Error（エラーが発生する）","1️⃣ 1 2 4（x == 3 の時にスキップ、x == 4 でループ終了）","🔹 continue と break の使い方
このコードでは、while ループとともに、continue と break を使って処理を制御しています。

continue は、条件に合った時にその後の処理をスキップして次のループに進むために使用します。
break は、指定した条件が満たされた時にループを完全に終了させるために使用します。

✅ continue と break のポイント
✔ continue は条件を満たしたとき、残りの処理をスキップして次のイテレーションへ進む！
✔ break は条件を満たしたとき、ループを完全に終了させる！
✔ continue と break を適切に使用することで、ループの挙動を細かく制御できる！

📌 例: continue と break の使用
・`continue` と `break` を使ってループの挙動を制御
x = 0
while x < 5:
    x += 1
    if x == 3:
        continue  # 3 の時はスキップ
    print(x)  # 出力: 1 2 4 5

・ `break` を使ってループを途中で終了
y = 0
while y < 5:
    y += 1
    if y == 4:
        break  # 4 の時に終了
    print(y)  # 出力: 1 2 3

👉 continue と break を使うことで、ループ内の処理を細かく制御し、効率的なロジックが作成できる！",2,2,
152,"x = 0
while x < 5:
    print(x)
    x += 1
else:
    print(""Loop finished"")

上記のコードを実行すると、出力される値は？
1️⃣
0
1
2
3
4
Loop finished
（while ループが正常に完了した場合）

2️⃣
0
1
2
3
4
（else のメッセージは表示されない）

3️⃣
Loop finished
（else のメッセージだけ表示）

4️⃣ Error（エラーが発生する）","0
1
2
3
4
Loop finished
（while ループが正常に完了した場合）","🔹 else と while ループ
while ループは指定した条件が True の間繰り返し実行されますが、ループが正常に完了した場合、else ブロックが実行されます。
ここでは、while x < 5 の条件が満たされる間、x が0から4まで表示され、その後 else の部分で ""Loop finished"" が表示されます。

✅ else と while ループのポイント
✔ else ブロックは、while ループが正常に完了した場合にのみ実行される！
✔ ループが途中で break などで終了した場合、else は実行されない！
✔ else を使うことで、ループの完了後の処理を簡単に追加できる！

📌 例: else と while ループの使用
# 正常に完了した場合に `else` が実行される
x = 0
while x < 5:
    print(x)
    x += 1
else:
    print(""Loop finished"")  # ✅ ""Loop finished""

・ `break` でループが中断された場合は `else` は実行されない
x = 0
while x < 5:
    print(x)
    if x == 3:
        break  # x == 3 のときにループ終了
    x += 1
else:
    print(""Loop finished"")  # ここは実行されない

👉 else と while を組み合わせて、ループの終了時に行うべき処理を明示的に記述できる！

",2,2,
153,"numbers = [1, 2, 3, 4, 5]
for num in numbers:
    if num == 4:
        break
    print(num)

上記のコードを実行すると、出力される値は？
1️⃣ 1 2 3（num == 4 の時点でループ終了）
2️⃣ 1 2 3 4（num == 4 も表示）
3️⃣ 1 2 3 4 5（全ての値が表示）
4️⃣ Error（エラーが発生する）","1️⃣ 1 2 3（num == 4 の時点でループ終了）","🔹 for ループと break
for ループはリストやタプル、文字列などのシーケンスを反復処理する際に使用されます。
ここでは、リスト numbers の中を順番に処理していき、num == 4 の時点で**break**を使ってループを終了しています。

✅ for ループと break のポイント
✔ for ループはシーケンスの各要素を反復処理する際に使用する！
✔ break は条件が満たされたとき、ループを即座に終了させる！
✔ break を使うことで、特定の条件に達した時にループを終了できる！

📌 例: for ループと break の使用
・ `for` ループと `break` を使って条件でループを終了
numbers = [10, 20, 30, 40, 50]
for num in numbers:
    if num == 30:
        break  # 30 の時点でループ終了
    print(num)  # 出力: 10 20

・リスト内に特定の値があるかチェック
search_value = 3
numbers = [1, 2, 3, 4, 5]
for num in numbers:
    if num == search_value:
        print(f""{search_value} found!"")  # 出力: 3 found!
        break

👉 break を使うことで、ループの途中で条件に応じた処理を行い、効率よくループを終了できる！",2,2,
154,"numbers = [1, 2, 3, 4, 5]
for num in numbers:
    if num == 3:
        continue
    print(num)

上記のコードを実行すると、出力される値は？
1️⃣ 1 2 4 5（num == 3 の時はスキップ）
2️⃣ 1 2 3 4 5（num == 3 の時も表示）
3️⃣ 2 4 5（num == 1 の時スキップ）
4️⃣ Error（エラーが発生する）","1️⃣ 1 2 4 5（num == 3 の時はスキップ）","🔹 continue と for ループ
continue は、ループ内で特定の条件に当てはまった時、そのループのその回をスキップして次のイテレーション（繰り返し）へ進むために使用します。

このコードでは、num == 3 の時、continue を使用して 3 の出力をスキップし、その後の処理に進むようになっています。

✅ continue と for ループのポイント
✔ continue は特定の条件を満たしたとき、その回のループ処理をスキップする！
✔ for ループ内で continue を使うことで、特定の要素を除外した処理を簡単に実現できる！
✔ continue を使うと、ループ内の後続処理をスキップして次のイテレーションに進む！

📌 例: continue と for の使用
・ リスト内で奇数のみ出力
numbers = [1, 2, 3, 4, 5]
for num in numbers:
    if num % 2 == 0:
        continue  # 偶数の時はスキップ
    print(num)  # 出力: 1 3 5

・ リスト内で3の倍数のみ出力
numbers = [1, 2, 3, 4, 5, 6]
for num in numbers:
    if num % 3 != 0:
        continue  # 3の倍数以外はスキップ
    print(num)  # 出力: 3 6

👉 continue を活用することで、ループ内で特定の条件に合うものだけを処理することができる！",2,2,
155,"def greet(name):
    return f""Hello, {name}!""

result = greet(""Alice"")
print(result)

上記のコードを実行すると、出力される値は？
1️⃣ Hello, Alice!（greet() 関数が返す結果）
2️⃣ None（関数が何も返さない場合）
3️⃣ greet(""Alice"")（関数の呼び出し結果）
4️⃣ Error（エラーが発生する）","1️⃣ Hello, Alice!（greet() 関数が返す結果","🔹 関数の基本
このコードでは、greet() という関数が name を引数として受け取り、その name を使って ""Hello, {name}!"" という文字列を返しています。

✅ 関数の基本ポイント
✔ 関数は、指定した処理をまとめて再利用可能にするためのコードブロックです。
✔ 関数に引数を渡して、その引数を使った処理を行い、戻り値を返すことができます。
✔ 戻り値がある関数の場合、その結果を変数に格納したり、print() で出力したりできます。

📌 例: 関数の使用
# 簡単な挨拶関数
def greet(name):
    return f""Hi, {name}!""

# 数字を二倍にする関数
def double(number):
    return number * 2

# 複数の引数を受け取る関数
def add(a, b):
    return a + b

print(greet(""Bob""))  # 出力: Hi, Bob!
print(double(4))     # 出力: 8
print(add(3, 5))     # 出力: 8

👉 関数を使うことで、コードの再利用が簡単になり、コードがスッキリと整理されます！",3,2,
156,"以下のコードを実行すると、出力される値は？

def multiply(x, y):
    return x * y

result = multiply(3, 4)
print(result)

1️⃣ 7
2️⃣ 12
3️⃣ ""34""
4️⃣ Error（エラーが発生する","2️⃣ 12","🔹 関数の基本（引数と戻り値）
この関数 multiply(x, y) は 2つの引数 x と y を受け取り、それらを掛け算して返す関数 です。

def multiply(x, y):
    return x * y
・return は関数の処理結果を戻すために使われます。
・return x * y により、 x と y の積を関数の呼び出し元に返します

📌 ポイント
✔ 関数は return で値を返す（print() とは異なる）
✔ 引数を渡して計算を行うことができる
✔ 関数を変数に代入すると、その戻り値が変数に格納される

👉 関数を使うことで、再利用可能なコードを作成できる！ ",3,1,
157,"次のコードの出力はどうなるでしょう？ 🤔

def add(a, b=5):
    return a + b

print(add(7))

1️⃣ 7
2️⃣ 12
3️⃣ Error（エラーが発生する）
4️⃣ None","2️⃣ 12","🔹 デフォルト引数とは？
デフォルト引数とは、関数の引数にあらかじめ初期値を設定できる仕組み です。
この問題では、b=5 のように b のデフォルト値を 5 に設定 しています。

def add(a, b=5):
    return a + b

・a には 必ず 値を渡す必要があります。
・b には 値を渡さなければ、デフォルトの 5 が使用される。

🔹 コードの流れ
1️⃣ add(7) を呼び出し
2️⃣ a = 7 に設定される
3️⃣ b の値は指定されていないため、デフォルトの 5 が使われる
4️⃣ return 7 + 5 → 12 が返される
5️⃣ print(12) により、出力は 12 ✅

📌 ポイント
✔ デフォルト引数を設定すると、関数を呼び出す際に省略可能！
✔ デフォルト引数は右側の引数にのみ設定可能！（左側に設定するとエラー）

📌 例：エラーになるケース
def example(a=10, b):  # ❌ エラー！デフォルト引数は後ろに置く必要がある
    return a + b
",3,1,
158,"以下のコードを実行すると、出力される値は？

def greet(name, message=""こんにちは""):
    print(f""{message}, {name}!"")

greet(""太郎"", ""おはよう"")
greet(""花子"")

1️⃣ おはよう, 太郎! と こんにちは, 花子!
2️⃣ こんにちは, 太郎! と おはよう, 花子!
3️⃣ おはよう, 太郎! と おはよう, 花子!
4️⃣ Error（エラーが発生する）","1️⃣ おはよう, 太郎! と こんにちは, 花子!","🔹 デフォルト引数と通常の引数の組み合わせ
この関数 greet(name, message=""こんにちは"") では、
・name は 通常の引数（必須）
・message は デフォルト引数（省略可能、デフォルト値は ""こんにちは""）
✔ message を指定しない場合は、デフォルト値 ""こんにちは"" が使用されます！

🔹 コードの流れ
greet(""太郎"", ""おはよう"")
1️⃣ name = ""太郎"" に設定
2️⃣ message = ""おはよう"" に設定（指定されているためデフォルト値は使わない）
3️⃣ print(""おはよう, 太郎!"") ✅

greet(""花子"")
1️⃣ name = ""花子"" に設定
2️⃣ message は指定されていないため デフォルト値 ""こんにちは"" が使われる
3️⃣ print(""こんにちは, 花子!"") ✅

よって、出力は：

おはよう, 太郎!
こんにちは, 花子!

📌 ポイント
✔ デフォルト引数は省略できるが、通常の引数は必須！
✔ デフォルト引数を設定しておくと、関数の汎用性が向上する！
✔ デフォルト引数を持つ引数は、通常の引数の後に記述する！

📌 例：エラーになるケース
def greet(message=""こんにちは"", name):  # ❌ エラー！デフォルト引数は後ろに置く必要がある
    print(f""{message}, {name}!"")
🔸 デフォルト引数を持つ引数は、必ず通常の引数の後に記述する必要があります！",3,1,
159,"以下のコードを実行すると、出力される値は？

def total(a, *args):
    result = a
    for num in args:
        result += num
    return result

print(total(5, 10, 15))
1️⃣ 5
2️⃣ 10
3️⃣ 15
4️⃣ 30","4️⃣ 30","🔹 可変長引数 *args とは？
・　*args は、複数の引数をタプルとして受け取る ことができる特別な構文です！
・　*args を使うと、関数に渡す引数の数を可変にできる。
・　args の中身は タプルとして扱われる。

🔹 コードの流れ

def total(a, *args):
    result = a  # 最初の値 a を result にセット
    for num in args:  # *args の中身を順番に取り出して加算
        result += num
    return result

1️⃣ total(5, 10, 15) を呼び出す
a = 5
args = (10, 15) （タプルとして受け取られる）
2️⃣ ループで args の要素を result に加算
result = 5  # 初期値
result += 10  # 5 + 10 = 15
result += 15  # 15 + 15 = 30
3️⃣ return result で 30 を返す ✅

📌 ポイント
✔ *args は複数の引数をタプルとして受け取る
✔ ループを使って args の値を処理できる
✔ 最初の引数 a は必須、それ以降は *args に格納される

📌 例：引数を 1 つだけ渡した場合
print(total(5))
✅ 出力 → 5（args が空なので、計算されない）

📌 例：より多くの引数を渡した場合
print(total(2, 4, 6, 8, 10))
✅ 出力 → 2 + 4 + 6 + 8 + 10 = 30",3,2,
160,"以下のコードを実行すると、出力される値は？

def outer(x):
    def inner(y):
        return x + y
    return inner

add_five = outer(5)
print(add_five(10))

1️⃣ 5
2️⃣ 10
3️⃣ 15
4️⃣ Error（エラーが発生する）","3️⃣ 15","🔹 クロージャ（Closure）とは？
クロージャとは、関数の中で定義された関数が、外側の関数の変数を保持し続ける仕組み です。
このコードでは、inner() 関数が outer() 関数の x を保持しながら動作する ことがポイントです！

🔹 コードの流れ
def outer(x):
    def inner(y):
        return x + y
    return inner

1️⃣ outer(5) を実行
x = 5 がセットされる
inner(y) という関数が return される
add_five に inner(y) が代入される
add_five = outer(5)

✅ add_five は inner(y) の関数オブジェクトになった！
ただし、x = 5 は inner(y) の中で 記憶され続ける（= クロージャ）

🔹 次の処理
print(add_five(10))
add_five(10) は、実際には inner(10) を呼び出している
x = 5 は outer() の呼び出し時にセットされているので、

return x + y  # 5 + 10
15 を返す ✅

📌 ポイント
✔ クロージャは、外側の関数の変数を保持し続ける！
✔ outer() の戻り値は inner() の関数オブジェクト（実際の計算は inner() が呼ばれる時に行われる）
✔ 関数の中に関数を定義することで、動的に関数を作成できる！

📌 例：add_ten を作る
add_ten = outer(10)
print(add_ten(20))  # 10 + 20 = 30
✅ 出力 → 30",3,3,
161,"以下のコードを実行すると、出力される値は？

def counter():
    count = 0
    def increment():
        nonlocal count
        count += 1
        return count
    return increment

counter1 = counter()
print(counter1())
print(counter1())

1️⃣ 1 と 1
2️⃣ 1 と 2
3️⃣ 2 と 2
4️⃣ Error（エラーが発生する）","2️⃣ 1 と 2","🔹 nonlocal とは？
nonlocal は、ネストされた関数（関数の中に定義された関数）内で、外側の関数の変数を更新するために使うキーワード です！

通常、ネストされた関数の中で外側の関数の変数に代入しようとすると、新しいローカル変数が作成されてしまうため、元の変数には影響しません。
しかし、nonlocal を使うと、外側の変数を変更できるようになります！

🔹 コードの流れ
def counter():
    count = 0  # 外側の関数の変数（クロージャの一部）
    def increment():
        nonlocal count  # 外側の `count` を参照
        count += 1
        return count
    return increment  # `increment` 関数を返す

📌 counter() を実行すると、count = 0 を記憶した increment() 関数が返る！
counter1 = counter()  # `increment()` を取得（`count = 0` を記憶）
✔ counter1 は increment() の関数オブジェクトを保持
✔ count = 0 の状態を記憶

🔹 1回目の実行
print(counter1())  # `increment()` を実行
1️⃣ nonlocal count により、count = 0 を更新可能
2️⃣ count += 1 → count = 1 になる
3️⃣ return count → 出力は 1 ✅

🔹 2回目の実行
print(counter1())  # もう一度 `increment()` を実行
1️⃣ nonlocal count により、前回の count = 1 を保持
2️⃣ count += 1 → count = 2 になる
3️⃣ return count → 出力は 2 ✅

📌 ポイント
✔ クロージャを使うと、関数が外側のスコープの変数を記憶できる！
✔ nonlocal を使うと、外側の関数の変数を更新できる！
✔ counter1() を何回実行しても、count の値は保持される！

📌 もし nonlocal count を削除すると、どうなる？
def counter():
    count = 0
    def increment():
        count += 1  # `nonlocal` を指定しないと、ここでエラー！
        return count
    return increment
❌ エラー発生！ count += 1 は ローカル変数を作成しようとするが、count が未定義 のため、エラーになる。
✅ nonlocal count を使うことで、外側の count を正しく参照できる！",3,3,
162,"以下のコードを実行すると、出力される値は？

def power(n):
    return lambda x: x ** n

square = power(2)
cube = power(3)

print(square(4))
print(cube(2))

1️⃣ 16 と 8
2️⃣ 8 と 16
3️⃣ 4 と 2
4️⃣ Error（エラーが発生する）","1️⃣ 16 と 8","🔹 ラムダ関数（無名関数）とは？
lambda を使うと、名前を付けずに簡潔な関数を作成できる。

lambda x: x ** n
これは、
def some_function(x):
    return x ** n
と同じ意味になります！

🔹 コードの流れ
def power(n):
    return lambda x: x ** n

📌 power(n) を呼び出すと、lambda x: x ** n の関数オブジェクトが返る！
📌 この lambda 関数は、n を記憶（クロージャ）しながら、x を受け取って x ** n を計算する！

🔹 square と cube の作成
square = power(2)  # `n = 2` を記憶した `lambda x: x ** 2`
cube = power(3)  # `n = 3` を記憶した `lambda x: x ** 3`
✔ square(4) を実行すると 4 ** 2 = 16 ✅
✔ cube(2) を実行すると 2 ** 3 = 8 ✅

🔹 出力
print(square(4))  # 16
print(cube(2))  # 8
✅ 出力：
16
8
📌 ポイント
✔ ラムダ関数は、lambda x: x ** n のように、シンプルな処理を関数化できる！
✔ power(n) の n はクロージャとして記憶され、square() や cube() に影響を与える！
✔ 「べき乗関数」など、簡単な計算をパラメータ化するのに便利！

📌 別の例：異なるべき乗関数を作る
power_of_four = power(4)  # `lambda x: x ** 4`
print(power_of_four(2))  # 2 ** 4 = 16
✅ この方法を使えば、「2乗関数」「3乗関数」… などを簡単に作れる！",3,3,
163,"以下のコードを実行すると、出力される値は？

def make_counter():
    count = 0
    def counter():
        nonlocal count
        count += 1
        return count
    return counter

c1 = make_counter()
c2 = make_counter()

print(c1())
print(c1())
print(c2())
1️⃣ 1, 2, 1
2️⃣ 1, 1, 1
3️⃣ 1, 2, 2
4️⃣ Error（エラーが発生する）","1️⃣ 1, 2, 1","🔹 関数を返す関数（クロージャ）とは？
このコードでは、make_counter() を呼び出すたびに、新しい counter() 関数が作成される 仕組みになっています。
counter() は count という変数を nonlocal を使って保持し、更新する ようになっています。

🔹 コードの流れ
def make_counter():
    count = 0  # 関数ごとに独立した `count` を持つ
    def counter():
        nonlocal count  # `count` を更新可能にする
        count += 1
        return count
    return counter

📌 make_counter() を呼び出すと、count = 0 を記憶した counter() 関数が作られる。
📌 この counter() 関数は count の値を保持し続ける（クロージャ）。

🔹 c1 と c2 の作成
c1 = make_counter()  # `count = 0` を記憶した `counter()` が作成される
c2 = make_counter()  # 別の `count = 0` を持つ `counter()` が作成される（c1 とは独立）
✔ c1 と c2 は、別々の count を持つ！
✔ それぞれの counter() は、自分の count を記憶している！

🔹 実行の流れ
print(c1())  #  `c1` の `count` を 1 に増やす → `1` を出力
✔ c1 の count = 0 → 1
✔ return 1 ✅

print(c1())  #  `c1` の `count` を 2 に増やす → `2` を出力
✔ c1 の count = 1 → 2
✔ return 2 ✅

print(c2())  #  `c2` の `count` は独立 → `1` を出力
✔ c2 の count は 0 → 1（c1 とは別の count）
✔ return 1 ✅

🔹 出力
1
2
1

📌 ポイント
✔ make_counter() を呼び出すたびに、独立した count を持つ関数 counter() が作られる！
✔ nonlocal count を使うことで、クロージャ内で count の値を更新できる！
✔ c1 と c2 は、それぞれ別々の count を持っているため、影響を受けない！

📌 もし c2 = c1 だった場合、c2() も c1() の count を共有する！

",3,3,
164,"以下のコードを実行すると、出力される値は？

def add_prefix(prefix):
    return lambda word: f""{prefix}-{word}""

add_mr = add_prefix(""Mr"")
add_ms = add_prefix(""Ms"")

print(add_mr(""Smith""))
print(add_ms(""Johnson""))

1️⃣ ""Mr-Smith"" と ""Ms-Johnson""
2️⃣ ""Smith-Mr"" と ""Johnson-Ms""
3️⃣ ""Mr-Johnson"" と ""Ms-Smith""
4️⃣ Error（エラーが発生する）","1️⃣ ""Mr-Smith"" と ""Ms-Johnson""","🔹 ラムダ関数を使った関数の生成（クロージャ）
このコードでは、add_prefix() を呼び出すと、特定の prefix を保持するラムダ関数を作成する 仕組みになっています。

def add_prefix(prefix):
    return lambda word: f""{prefix}-{word}""
📌 add_prefix(prefix) を呼び出すと、lambda word: f""{prefix}-{word}"" という関数が返る！
📌 prefix は、クロージャの仕組みにより、ラムダ関数の内部で記憶される。

🔹 add_mr と add_ms の作成

add_mr = add_prefix(""Mr"")
add_ms = add_prefix(""Ms"")
✔ add_mr は、prefix = ""Mr"" を記憶したラムダ関数
✔ add_ms は、prefix = ""Ms"" を記憶したラムダ関数

📌 add_mr(""Smith"") を実行すると？
add_mr(""Smith"")  # ""Mr-Smith""
📌 add_ms(""Johnson"") を実行すると？
add_ms(""Johnson"")  # ""Ms-Johnson""

🔹 出力
print(add_mr(""Smith""))  # ""Mr-Smith""
print(add_ms(""Johnson""))  # ""Ms-Johnson""

✅ 最終的な出力
Mr-Smith
Ms-Johnson

📌 ポイント
✔ クロージャを使うことで、特定の値（prefix）を記憶した関数を作成できる！
✔ ラムダ関数を使うと、簡潔な関数をその場で作成できる！
✔ この方法を使えば、様々な前置詞（Mr, Ms, Dr など）を簡単に付ける関数を作成できる！

📌 別の例：異なるプレフィックスを使う
add_dr = add_prefix(""Dr"")
print(add_dr(""Brown""))  # ""Dr-Brown""

✅ これにより、異なるパターンの関数を動的に作成できる！",3,3,
165,"以下のコードを実行すると、出力される値は？

def create_multiplier(factor):
    def multiplier(n):
        return n * factor
    return multiplier

times_three = create_multiplier(3)
times_four = create_multiplier(4)

print(times_three(5))
print(times_four(2))

1️⃣ 15 と 8
2️⃣ 8 と 15
3️⃣ 5 と 2
4️⃣ Error（エラーが発生する）","1️⃣ 15 と 8","🔹 クロージャを使った関数の生成
このコードでは、create_multiplier(factor) を呼び出すと、factor を記憶した multiplier(n) 関数が作成される 仕組みになっています。

def create_multiplier(factor):
    def multiplier(n):
        return n * factor
    return multiplier

📌 create_multiplier(factor) を呼び出すと、factor を記憶した multiplier(n) 関数が返る！
📌 factor は クロージャの仕組みにより multiplier(n) 内で保持される。

🔹 times_three と times_four の作成
times_three = create_multiplier(3)  # `factor = 3` を記憶した multiplier(n) を返す
times_four = create_multiplier(4)  # `factor = 4` を記憶した multiplier(n) を返す
✔ times_three は、n * 3 を計算する関数
✔ times_four は、n * 4 を計算する関数

🔹 times_three(5) の実行
print(times_three(5))
📌 multiplier(5) を実行すると、
return 5 * 3  # 15
✅ 出力は 15

🔹 times_four(2) の実行
print(times_four(2))
📌 multiplier(2) を実行すると、
return 2 * 4  # 8
✅ 出力は 8

🔹 最終的な出力
15
8

📌 ポイント
✔ クロージャを使うと、特定の値（factor）を記憶した関数を作成できる！
✔ 動的に異なる計算（3倍する関数、4倍する関数など）を生成できる！
✔ この方法を使えば、例えば「税率を固定した計算関数」や「特定の通貨単位に変換する関数」なども作成できる！

📌 別の例：特定の税率を適用する関数を作る
def apply_tax(rate):
    return lambda price: price * (1 + rate)

vat = apply_tax(0.10)  # 消費税 10%
sales_tax = apply_tax(0.08)  # 消費税 8%

print(vat(1000))  # 1100.0
print(sales_tax(1000))  # 1080.0

✅ 異なる税率を適用する関数を動的に作成できる！",3,3,
166,"def make_power(exponent):
    return lambda base: base ** exponent

square = make_power(2)
cube = make_power(3)

print(square(3))
print(cube(2))

1️⃣ 9 と 8
2️⃣ 8 と 9
3️⃣ 3 と 2
4️⃣ Error（エラーが発生する）","1️⃣ 9 と 8","🔹 ラムダ関数を使ったクロージャ
このコードでは、make_power(exponent) を呼び出すと、exponent を記憶したラムダ関数を作成する 仕組みになっています。

def make_power(exponent):
    return lambda base: base ** exponent

📌 make_power(exponent) を呼び出すと、exponent を記憶した lambda base: base ** exponent が返る！
📌 exponent は クロージャの仕組みにより lambda base 内で保持される。

🔹 square と cube の作成
square = make_power(2)  # `exponent = 2` を記憶したラムダ関数
cube = make_power(3)  # `exponent = 3` を記憶したラムダ関数
✔ square は、base ** 2 を計算する関数
✔ cube は、base ** 3 を計算する関数

🔹 square(3) の実行
print(square(3))
📌 lambda base: base ** 2 に base = 3 を渡すと、
return 3 ** 2  # 9

✅ 出力は 9

🔹 cube(2) の実行
print(cube(2))

📌 lambda base: base ** 3 に base = 2 を渡すと、
return 2 ** 3  # 8

✅ 出力は 8

🔹 最終的な出力
9
8

📌 ポイント
✔ クロージャを使うと、特定の値（exponent）を記憶した関数を作成できる！
✔ ラムダ関数を使うと、簡潔な計算関数をその場で作成できる！
✔ この方法を使えば、「2乗関数」「3乗関数」「4乗関数」などを簡単に作れる！

📌 別の例：異なる exponent を持つ関数
fourth_power = make_power(4)
print(fourth_power(2))  # 2 ** 4 = 16

✅ 異なる exponent を適用する関数を動的に作成できる！",3,3,
167,"以下のコードを実行すると、出力される値は？

def counter(start):
    count = start
    def increment():
        nonlocal count
        count += 1
        return count
    return increment

c1 = counter(10)
c2 = counter(5)

print(c1())
print(c1())
print(c2())
print(c2())
1️⃣ 11, 12, 6, 7
2️⃣ 10, 11, 5, 6
3️⃣ 11, 11, 6, 6
4️⃣ Error（エラーが発生する）","1️⃣ 11, 12, 6, 7","🔹 クロージャと nonlocal を使ったカウンター関数
このコードでは、counter(start) を呼び出すと、count = start を記憶した increment() 関数を作成する 仕組みになっています。

def counter(start):
    count = start  # 関数ごとに独立した `count` を持つ
    def increment():
        nonlocal count  # `count` を更新可能にする
        count += 1
        return count
    return increment

📌 counter(start) を呼び出すたびに、start を持つ新しい increment() 関数が作られる！
📌 nonlocal を使うことで、ネストされた increment() 内で count を更新できる！

🔹 c1 と c2 の作成
c1 = counter(10)  # `count = 10` を記憶した `increment()` が作成される
c2 = counter(5)   # `count = 5` を記憶した `increment()` が作成される（c1 とは別）
✔ c1 と c2 は、別々の count を持つ！
✔ それぞれの increment() は、自分の count を記憶している！

🔹 実行の流れ
print(c1())  #  `c1` の `count` を 1 増やす → `11`
✔ c1 の count = 10 → 11
✔ return 11 ✅

print(c1())  #  `c1` の `count` を 1 増やす → `12`
✔ c1 の count = 11 → 12
✔ return 12 ✅

print(c2())  #  `c2` の `count` を 1 増やす → `6`
✔ c2 の count = 5 → 6（c1 とは独立）
✔ return 6 ✅

print(c2())  #  `c2` の `count` を 1 増やす → `7`
✔ c2 の count = 6 → 7
✔ return 7 ✅

🔹 最終的な出力
11
12
6
7

📌 ポイント
✔ クロージャを使うと、特定の値（count）を記憶した関数を作成できる！
✔ nonlocal を使うことで、ネストされた関数内で count を更新できる！
✔ c1 と c2 は、それぞれ独立した count を持つため、お互いに影響しない！

📌 もし c2 = c1 だった場合、c2() も c1() の count を共有する！
c2 = c1
print(c2())  # 13 になる！（c1 の count を共有）",3,3,
168,"以下のコードを実行すると、出力される値は？

def factorial(n):
    if n == 0:
        return 1
    else:
        return n * factorial(n - 1)

print(factorial(5))

1️⃣ 120
2️⃣ 24
3️⃣ 5
4️⃣ Error（エラーが発生する）","1️⃣ 120","🔹 再帰関数（Recursive Function）とは？
再帰関数とは、関数の中で自分自身を呼び出す関数 のことです。
このコードでは、factorial(n) が n * factorial(n-1) を計算しながら再帰的に呼び出される 仕組みになっています。

🔹 factorial(5) の処理の流れ
def factorial(n):
    if n == 0:
        return 1  # ベースケース（再帰の終了条件）
    else:
        return n * factorial(n - 1)  # 再帰呼び出し

📌 n == 0 の場合に 1 を返すことで、無限ループを防ぐ！
📌 それ以外の場合、n * factorial(n - 1) を計算する！

🔹 再帰の展開
factorial(5)
= 5 * factorial(4)
= 5 * (4 * factorial(3))
= 5 * (4 * (3 * factorial(2)))
= 5 * (4 * (3 * (2 * factorial(1))))
= 5 * (4 * (3 * (2 * (1 * factorial(0)))))
= 5 * 4 * 3 * 2 * 1 * 1
= 120

✅ 出力は 120 🎯

📌 ポイント
✔ 再帰関数は、関数が自分自身を呼び出すことで繰り返し処理を行う！
✔ 「ベースケース（終了条件）」を適切に設定しないと無限ループになる！
✔ 階乗（n!）のような数値計算、ツリー構造の探索（例：ファイルシステム）などでよく使われる！

📌 ループで書く場合
def factorial_iter(n):
    result = 1
    for i in range(1, n + 1):
        result *= i
    return result

✅ factorial_iter(5) でも 120 が求まる！",3,3,
169,"以下のコードを実行すると、出力される値は？

def decorator(func):
    def wrapper():
        print(""関数が実行される前の処理"")
        func()
        print(""関数が実行された後の処理"")
    return wrapper

@decorator
def say_hello():
    print(""Hello!"")

say_hello()
1️⃣ ""関数が実行される前の処理"" → ""Hello!"" → ""関数が実行された後の処理""
2️⃣ ""Hello!"" のみが出力される
3️⃣ ""関数が実行される前の処理"" → ""関数が実行された後の処理""（""Hello!"" は出力されない）
4️⃣ Error（エラーが発生する）","1️⃣ ""関数が実行される前の処理"" → ""Hello!"" → ""関数が実行された後の処理""","🔹 デコレーター（Decorator）とは？
デコレーターは、関数の振る舞いを変更・拡張するための仕組み です！
@decorator を付けることで、say_hello() の実行前後に処理を追加 できます！
これは、「関数をラップする」 仕組みとして広く使われます。

🔹 コードの流れ
def decorator(func):
    def wrapper():
        print(""関数が実行される前の処理"")  # ①
        func()  # ② 元の関数 (`say_hello()`) を実行
        print(""関数が実行された後の処理"")  # ③
    return wrapper

📌 デコレーター関数 decorator(func) は、新しい wrapper() 関数を返す！
📌 この wrapper() は、元の func() をラップして実行！

🔹 デコレーター適用
@decorator
def say_hello():
    print(""Hello!"")

📌 @decorator を付けると、say_hello() の実態が wrapper() に置き換えられる！

🔹 say_hello() の実行
say_hello()
1. ""関数が実行される前の処理"" を出力
2. say_hello() の本来の処理で ""Hello!"" を出力
3. ""関数が実行された後の処理"" を出力

✅ 最終的な出力

コピーする
編集する
関数が実行される前の処理
Hello!
関数が実行された後の処理
📌 ポイント
✔ デコレーターを使うと、関数の前後に処理を追加できる！
✔ 関数の振る舞いを変えずにログ出力やエラーハンドリングを追加できる！
✔ @decorator の書き方で、簡単に適用できる！

📌 デコレーターの応用例

python
コピーする
編集する
def debug(func):
    def wrapper(*args, **kwargs):
        print(f""実行中: {func.__name__}({args}, {kwargs})"")
        return func(*args, **kwargs)
    return wrapper

@debug
def add(a, b):
    return a + b

print(add(3, 5))
✅ 出力

css
コピーする
編集する
実行中: add((3, 5), {})
8
🔹 関数の引数や処理のログを簡単に出力できる！",3,3,
170,"以下のコードを実行すると、出力される値は？

def fibonacci(n):
    if n <= 0:
        return 0
    elif n == 1:
        return 1
    else:
        return fibonacci(n - 1) + fibonacci(n - 2)

print(fibonacci(6))
1️⃣ 5
2️⃣ 8
3️⃣ 13
4️⃣ Error（エラーが発生する）","2️⃣ 8","🔹 フィボナッチ数列とは？
フィボナッチ数列（Fibonacci Sequence）とは、「前の2つの項を足した値が次の項になる」数列 です。

📌 フィボナッチ数列の最初の数値
0, 1, 1, 2, 3, 5, 8, 13, 21, ...
📌 一般的な定義
fibonacci(0) = 0
fibonacci(1) = 1
fibonacci(n) = fibonacci(n - 1) + fibonacci(n - 2)（n ≥ 2）
🔹 コードの流れ
def fibonacci(n):
    if n <= 0:
        return 0  # ベースケース 1
    elif n == 1:
        return 1  # ベースケース 2
    else:
        return fibonacci(n - 1) + fibonacci(n - 2)  # 再帰

📌 n == 0 なら 0 を返す（ベースケース）
📌 n == 1 なら 1 を返す（ベースケース）
📌 n >= 2 なら、前の2つのフィボナッチ数の和を求める

🔹 fibonacci(6) の計算
fibonacci(6) = fibonacci(5) + fibonacci(4)
fibonacci(5) = fibonacci(4) + fibonacci(3)
fibonacci(4) = fibonacci(3) + fibonacci(2)
fibonacci(3) = fibonacci(2) + fibonacci(1)
fibonacci(2) = fibonacci(1) + fibonacci(0)
✅ 各値を代入：
fibonacci(2) = 1 + 0 = 1
fibonacci(3) = 1 + 1 = 2
fibonacci(4) = 2 + 1 = 3
fibonacci(5) = 3 + 2 = 5
fibonacci(6) = 5 + 3 = 8
✅ 出力は 8 🎯

📌 ポイント
✔ フィボナッチ数列は「前の2つの数を足した値が次の値になる」数列！
✔ 再帰関数を使って簡潔に定義できる！
✔ ただし、再帰の計算量が多いため、メモ化（動的計画法）を使うのがベスト！

📌 メモ化（キャッシュ）を使って最適化
from functools import lru_cache

@lru_cache(maxsize=None)
def fibonacci(n):
    if n <= 0:
        return 0
    elif n == 1:
        return 1
    else:
        return fibonacci(n - 1) + fibonacci(n - 2)

print(fibonacci(50))  # 計算が高速化！

✅ キャッシュを使うことで、大きな n でも高速に計算できる！

",3,3,
171,"以下のコードを実行すると、出力される値は？

def compose(f, g):
    return lambda x: f(g(x))

def double(n):
    return n * 2

def increment(n):
    return n + 1

h = compose(double, increment)
print(h(3))

1️⃣ 6
2️⃣ 7
3️⃣ 8
4️⃣ Error（エラーが発生する）","3️⃣ 8","🔹 関数合成（Function Composition）とは？
関数合成とは、「ある関数の出力を、別の関数の入力として渡す」こと です。
このコードでは、compose(f, g) を使って g(x) の結果を f() に渡す 仕組みを作っています。

・ g(x) は def g(x) で定義された関数のこと！
・ f(x) も def f(x) で定義された関数のこと！
・ 関数 compose(f, g) の役割は、「g(x) の結果を f(x) に渡す新しい関数を作る」こと！

🔹 コードの流れ
def compose(f, g):
    return lambda x: f(g(x))

📌 compose(f, g) を呼び出すと、
lambda x: f(g(x))
という 関数オブジェクト を返す！
つまり、g(x) を先に実行し、その結果を f(x) に渡す関数が作られる！

🔹 double(n) と increment(n) の定義
def double(n):
    return n * 2

def increment(n):
    return n + 1

✔ double(n) は n を2倍にする関数
✔ increment(n) は n に +1 する関数

🔹 compose(double, increment) の実行
h = compose(double, increment)

📌 この h(x) は、次のように動作する！
h = lambda x: double(increment(x))

📌 つまり、h(x) を実行すると：
1. increment(x) を実行（x + 1）
2. その結果を double() に渡す（(x + 1) * 2）

🔹 h(3) の計算
print(h(3))

1. increment(3) を計算
　　increment(3) = 3 + 1 = 4
2. その結果 4 を double() に渡す
　　double(4) = 4 * 2 = 8

✅ 出力は 8 🎯

📌 ポイント
✔ 関数合成では、内側の関数（g(x)）が先に実行され、外側の関数（f(x)）が後に実行される！
✔ この仕組みを使うと、データ変換やパイプライン処理を簡潔に記述できる！
✔ 関数型プログラミング（Functional Programming）でよく使われるテクニック！",3,3,
172,"以下のコードを実行すると、出力される値は？

numbers = [1, 2, 3, 4, 5]
numbers.append(6)
print(numbers)

1️⃣ [1, 2, 3, 4, 5]
2️⃣ [1, 2, 3, 4, 5, 6]
3️⃣ [6, 1, 2, 3, 4, 5]
4️⃣ Error（エラーが発生する）","2️⃣ [1, 2, 3, 4, 5, 6]","🔹 append() メソッドとは？
append() メソッドは、リストの末尾に新しい要素を追加する メソッドです！

📌 ポイント
✔ append() はリストの末尾に新しい要素を追加する！
✔ リストの既存の要素は変更されず、新しい要素が追加されるだけ！
✔ リストの先頭に要素を追加したい場合は insert(0, 値) を使う！

📌 リストの先頭に追加する方法
numbers.insert(0, 0)  # 先頭に 0 を追加
print(numbers)  # [0, 1, 2, 3, 4, 5, 6]

📌 複数の要素を追加する方法（extend()）
numbers.extend([7, 8, 9])  # 7, 8, 9 をまとめて追加
print(numbers)  # [1, 2, 3, 4, 5, 6, 7, 8, 9]
",10,1,
173,"以下のコードを実行すると、出力される値は？

fruits = (""apple"", ""banana"", ""cherry"")
fruits.append(""orange"")
print(fruits)

1️⃣ (""apple"", ""banana"", ""cherry"", ""orange"")
2️⃣ [""apple"", ""banana"", ""cherry"", ""orange""]
3️⃣ (""orange"", ""apple"", ""banana"", ""cherry"")
4️⃣ Error（エラーが発生する）","4️⃣ Error（エラーが発生する）","🔹 タプル (tuple) は変更できない！
このコードでは、fruits はタプル (tuple) なので、append() メソッドを使うことは できません！
そのため、エラー (AttributeError) が発生します。

fruits = (""apple"", ""banana"", ""cherry"")
fruits.append(""orange"")  # ❌ タプルには append() がないのでエラー！

✅ エラー内容
AttributeError: 'tuple' object has no attribute 'append'

✅ 正解は 4️⃣ Error（エラーが発生する） 🎯

📌 タプルの特徴
✔ タプルは「イミュータブル（変更不可）」なデータ構造！
✔ 要素を追加・削除・変更することはできない！
✔ リストは append() で要素を追加できるが、タプルはできない！

📌 タプルをリストに変換して追加する方法
fruits = (""apple"", ""banana"", ""cherry"")
fruits_list = list(fruits)  # タプル → リスト に変換
fruits_list.append(""orange"")  # リストなので append() が使える！
fruits = tuple(fruits_list)  # リスト → タプル に戻す
print(fruits)  # ('apple', 'banana', 'cherry', 'orange')",10,1,
174,"以下のコードを実行すると、出力される値は？

data = {""name"": ""Alice"", ""age"": 25}
data[""city""] = ""Tokyo""
print(data)

1️⃣ {""name"": ""Alice"", ""age"": 25}
2️⃣ {""name"": ""Alice"", ""age"": 25, ""city"": ""Tokyo""}
3️⃣ [""name"", ""Alice"", ""age"", 25, ""city"", ""Tokyo""]
4️⃣ Error（エラーが発生する）","2️⃣ {""name"": ""Alice"", ""age"": 25, ""city"": ""Tokyo""}","🔹 辞書 (dict) のキーと値の追加
辞書（dict）は キーと値のペアでデータを管理するデータ構造 で、新しいキーを追加すると、そのキーと値が辞書に保存される！

data = {""name"": ""Alice"", ""age"": 25}  # 初期の辞書
data[""city""] = ""Tokyo""  # ""city"" というキーを追加
print(data)

✅ 新しいキー ""city"" を追加すると、対応する値 ""Tokyo"" が格納される！

🔹 出力
{'name': 'Alice', 'age': 25, 'city': 'Tokyo'}

✅ 正解は 2️⃣ {""name"": ""Alice"", ""age"": 25, ""city"": ""Tokyo""} 🎯

📌 ポイント
✔ 辞書は {キー: 値} のペアで管理される！
✔ data[""新しいキー""] = 値 で、新しいキーと値を追加できる！
✔ キーがすでに存在する場合は、その値が更新される！

📌 キーの値を変更する方法
data[""age""] = 30  # 既存の ""age"" の値を更新
print(data)  # {'name': 'Alice', 'age': 30, 'city': 'Tokyo'}

📌 辞書の削除 (del)
del data[""city""]  # ""city"" のキーを削除
print(data)  # {'name': 'Alice', 'age': 25}

📌 キーが存在するか確認する方法
if ""city"" in data:
    print(""city は辞書に含まれています！"")
",10,1,
175,"以下のコードを実行すると、出力される値は？

numbers = [10, 20, 30, 40, 50]
print(numbers[2])

1️⃣ 10
2️⃣ 20
3️⃣ 30
4️⃣ Error（エラーが発生する）","3️⃣ 30","🔹 リストのインデックスアクセス
リストでは、各要素には0から始まるインデックス（番号） が割り当てられています。

numbers = [10, 20, 30, 40, 50]
print(numbers[2])  # 2番目のインデックスの値を取得

✅ Pythonのインデックス番号
numbers = [10, 20, 30, 40, 50]
             ↑   ↑   ↑   ↑   ↑  
             0   1   2   3   4   （インデックス番号）

📌 numbers[2] は 2番目のインデックスの要素 30 を取得！

🔹 出力
30

✅ 正解は 3️⃣ 30 🎯

📌 ポイント
✔ リストのインデックスは 0 から始まる！（numbers[0] は 10）
✔ リストの n 番目の要素を取得するには numbers[n] を使う！
✔ 範囲外のインデックスを指定すると IndexError が発生する！

📌 最後の要素を取得するには -1 を使う
print(numbers[-1])  # 50

📌 リストのスライス（複数要素を取得）
print(numbers[1:4])  # [20, 30, 40] （1番目から3番目の要素を取得）
",10,1,
176,"以下のコードを実行すると、出力される値は？

fruits = [""apple"", ""banana"", ""cherry""]
fruits.remove(""banana"")
print(fruits)

1️⃣ [""apple"", ""banana"", ""cherry""]
2️⃣ [""apple"", ""cherry""]
3️⃣ [""banana"", ""cherry""]
4️⃣ Error（エラーが発生する）","2️⃣ [""apple"", ""cherry""]","🔹 remove() メソッドとは？
remove() メソッドは、リスト内の指定した要素を削除する メソッドです。
ただし、削除する要素がリストに複数存在する場合、最初に見つかった1つだけが削除される！

📌 ポイント
✔ remove(値) はリスト内の最初に見つかった指定の値を削除する！
✔ 値がリスト内にない場合は ValueError が発生する！
✔ インデックス指定で削除したい場合は del や pop() を使う！

📌 要素が存在しない場合のエラー
fruits.remove(""orange"")  # ❌ ValueError: list.remove(x): x not in list

📌 インデックスで削除する方法
del fruits[1]  # 1番目の要素を削除
print(fruits)  # ['apple', 'cherry']

📌 pop() を使うと削除した要素を取得できる
removed_item = fruits.pop(1)  # 1番目の要素を削除して取得
print(removed_item)  # ""banana""
print(fruits)  # ['apple', 'cherry']",10,1,
177,"以下のコードを実行すると、出力される値は？


info = {""name"": ""Bob"", ""age"": 30}
print(info.get(""city"", ""Unknown""))

1️⃣ ""Unknown""
2️⃣ ""city""
3️⃣ None
4️⃣ Error（エラーが発生する）","1️⃣ ""Unknown""","🔹 dict.get(key, default) メソッドとは？
get() メソッドを使うと、辞書内にキーが存在しない場合でも、エラーを発生させずにデフォルト値を返す ことができます！
info = {""name"": ""Bob"", ""age"": 30}
print(info.get(""city"", ""Unknown""))  # ""city"" がない場合、""Unknown"" を返す

✅ ""city"" というキーは辞書に存在しないため、デフォルト値 ""Unknown"" が返される！

🔹 出力
""Unknown""

✅ 正解は 1️⃣ ""Unknown"" 🎯

📌 ポイント
✔ 辞書にキーがある場合は、その値が返る！
✔ キーが存在しない場合でも get() を使えばエラーにならない！
✔ 第二引数（デフォルト値）を指定しない場合、None が返る！

📌 キーが存在する場合
print(info.get(""name"", ""Unknown""))  # ""Bob""（デフォルト値は使われない）

📌 キーが存在しない場合（デフォルト値なし）
print(info.get(""city""))  # None（デフォルト値がないので `None` が返る）

📌 普通の辞書アクセス（info[""city""]）だとエラーになる！

print(info[""city""])  # ❌ KeyError: 'city'
✅ エラーを避けたい場合は get() を使うと安全！",10,1,
178,"以下のコードを実行すると、出力される値は？

numbers = [1, 2, 3]
numbers.extend([4, 5, 6])
print(numbers)

1️⃣ [1, 2, 3, [4, 5, 6]]
2️⃣ [1, 2, 3, 4, 5, 6]
3️⃣ [4, 5, 6, 1, 2, 3]
4️⃣ Error（エラーが発生する）","2️⃣ [1, 2, 3, 4, 5, 6]","🔹 extend() メソッドとは？
extend() メソッドは、リストの末尾に別のリストの要素を追加する メソッドです！

📌 ポイント
✔ extend() はリストの末尾に複数の要素を追加できる！
✔ リストを append() すると「リストの中にリスト」ができるので注意！
✔ + 演算子を使っても同じ結果になる！

📌 append() を使うとどうなる？
numbers = [1, 2, 3]
numbers.append([4, 5, 6])  # リスト全体を1つの要素として追加
print(numbers)

✅ 出力
[1, 2, 3, [4, 5, 6]]  # ❌ 内側にリストができる！
🔹 リストを展開したい場合は extend() を使う！

📌 + 演算子で結合する方法
numbers = [1, 2, 3] + [4, 5, 6]
print(numbers)  # [1, 2, 3, 4, 5, 6]

✅ extend() と同じ結果になる！",10,1,
179,"以下のコードを実行すると、出力される値は？

x = (10,)
print(type(x))

1️⃣ <class 'int'>
2️⃣ <class 'tuple'>
3️⃣ <class 'list'>
4️⃣ Error（エラーが発生する）","2️⃣ <class 'tuple'>","🔹 タプル (tuple) を作成するには (値,) のカンマが必要！
Pythonでは、1つの要素を持つタプルを作成する場合、(10,) のように最後にカンマを付ける必要がある！

x = (10,)  # カンマがあるのでタプルとして認識される

✅ type(x) の結果は <class 'tuple'> になる！ 🎯

📌 ポイント
✔ カンマがないと、単なる整数 (int) になってしまう！
✔ タプルを1要素だけ作るときは (値,) のようにカンマを付ける！
✔ 複数の要素がある場合は (10, 20, 30) のように普通に書けばOK！

📌 カンマがないとどうなる？
x = (10)  # ❌ これはタプルではなく、単なる整数
print(type(x))  # <class 'int'>

📌 複数の要素を持つ場合
y = (10, 20, 30)
print(type(y))  # <class 'tuple'>

📌 リストと比較
z = [10]  # リストならカンマなしでもOK
print(type(z))  # <class 'list'>
",10,1,
180,"以下のコードを実行すると、出力される値は？

data = {""A"": 1, ""B"": 2, ""C"": 3}
result = data.keys()
print(result)

1️⃣ [""A"", ""B"", ""C""]
2️⃣ dict_keys(['A', 'B', 'C'])
3️⃣ (""A"", ""B"", ""C"")
4️⃣ Error（エラーが発生する）","2️⃣ dict_keys(['A', 'B', 'C'])","🔹 keys() メソッドとは？
dict.keys() メソッドを使うと、辞書のキー（key）を取得することができる！
ただし、戻り値は list ではなく、dict_keys オブジェクト になる！

dict_keys オブジェクト とは、Pythonの辞書 (dict) で .keys() メソッドを使ったときに返される特殊なオブジェクトのことです！
✔ dict.keys() は dict_keys オブジェクトを返す！
✔ dict_keys はリストのようにループで使えるが、リストではない！
✔ リストに変換したい場合は list(data.keys()) を使う！
✔ 元の辞書を変更すると、dict_keys も変更を反映する

data = {""A"": 1, ""B"": 2, ""C"": 3}
result = data.keys()
print(result)

✅ 辞書 data のキーは A, B, C なので、keys() を使うと dict_keys(['A', 'B', 'C']) が返る！

📌 ポイント
✔ keys() メソッドは dict_keys オブジェクトを返す！
✔ リストのように扱えるが、実際はリストではない！
✔ リストに変換したい場合は list(data.keys()) を使う！

📌 リストに変換する方法
key_list = list(data.keys())
print(key_list)  # ['A', 'B', 'C']

📌 values() を使うと値を取得できる
print(data.values())  # dict_values([1, 2, 3])

📌 items() を使うとキーと値のペアを取得
print(data.items())  # dict_items([('A', 1), ('B', 2), ('C', 3)])",10,2,
181,"以下のコードを実行すると、出力される値は？

tuple1 = (1, 2, 3)
tuple2 = (4, 5, 6)
result = tuple1 + tuple2
print(result)

1️⃣ (1, 2, 3, 4, 5, 6)
2️⃣ ((1, 2, 3), (4, 5, 6))
3️⃣ [1, 2, 3, 4, 5, 6]
4️⃣ Error（エラーが発生する）","1️⃣ (1, 2, 3, 4, 5, 6)","🔹 タプル (tuple) の結合
タプルは + 演算子を使うことで、新しいタプルとして結合することができます！

tuple1 = (1, 2, 3)
tuple2 = (4, 5, 6)
result = tuple1 + tuple2
print(result)

✅ tuple1 + tuple2 により、2つのタプルが連結され、新しいタプル (1, 2, 3, 4, 5, 6) が作成される！

📌 ポイント
✔ タプル同士は + で結合できる！（list の + と同じ動作）
✔ タプルを結合すると、新しいタプルが作成され、元のタプルは変更されない！（タプルはイミュータブル！）
✔ ネストされたタプル ((1, 2, 3), (4, 5, 6)) にはならない！（リストのようにネストされるわけではない！）

📌 ネストしたタプルを作りたい場合
nested_tuple = (tuple1, tuple2)
print(nested_tuple)  # ((1, 2, 3), (4, 5, 6))

✅ この場合、タプルの中にタプルが入る！

📌 タプルをリストに変換して結合
list1 = list(tuple1) + list(tuple2)  # タプルをリストに変換
print(list1)  # [1, 2, 3, 4, 5, 6]

✅ タプルの結合とは異なり、リストとして扱える！",10,2,
182,"以下のコードを実行すると、出力される値は？

fruits = {""apple"", ""banana"", ""cherry""}
fruits.add(""banana"")
print(fruits)

1️⃣ {""apple"", ""banana"", ""cherry""}
2️⃣ {""apple"", ""banana"", ""cherry"", ""banana""}
3️⃣ [""apple"", ""banana"", ""cherry""]
4️⃣ Error（エラーが発生する）","1️⃣ {""apple"", ""banana"", ""cherry""}","🔹 set（集合型）の特性
set（集合）は 重複する要素を持たないデータ構造 なので、同じ値を追加しようとしても変化しません！

重複する要素を持たないデータ構造のため、セットの出力順は一定ではなく、異なる順番で表示されることがあります！

✔ セット（set）は順番を保証しない！
✔ 同じ要素を持つセットは、どんな順番で表示されても「同じセット」とみなされる！
✔ リストとは違い、インデックス（fruits[0] のような指定）はできない！

📌 もし順番を保証したいならリスト (list) に変換する！
fruits = {""apple"", ""banana"", ""cherry""}
sorted_fruits = sorted(fruits)  # アルファベット順にソート
print(sorted_fruits)  # ['apple', 'banana', 'cherry']
✅ これなら順番を固定できる！

📌 ポイント
✔ **set は 重複する要素を許さない！
✔ add() メソッドを使うと、新しい要素を追加できる！
✔ 既に存在する要素を add() しても無視される（エラーにはならない）！

📌 新しい要素を追加する
fruits.add(""orange"")
print(fruits)  # {'apple', 'banana', 'cherry', 'orange'}

📌 複数の要素を追加する（update()）
fruits.update([""grape"", ""melon""])
print(fruits)  # {'apple', 'banana', 'cherry', 'grape', 'melon'}

📌 要素を削除する
fruits.remove(""banana"")  # ""banana"" を削除
print(fruits)  # {'apple', 'cherry'}

📌 discard() を使うと、要素がなくてもエラーにならない
fruits.discard(""banana"")  # すでに削除済みでもエラーにならない",10,2,
183,"以下のコードを実行すると、出力される値は？

data = {""x"": 10, ""y"": 20}
value = data.pop(""y"")
print(value)

1️⃣ {""x"": 10, ""y"": 20}
2️⃣ 20
3️⃣ None
4️⃣ Error（エラーが発生する）","2️⃣ 20","🔹 pop() メソッドとは？
辞書 (dict) の pop() メソッドは、指定したキーの値を取り出し、そのキーと値を辞書から削除する 役割を持ちます！

data = {""x"": 10, ""y"": 20}  # 辞書を作成
value = data.pop(""y"")  # ""y"" のキーを削除し、その値（20）を取得
print(value)  # 20

✅ pop(""y"") によって ""y"": 20 のペアが辞書から削除され、値 20 が返される！

📌 ポイント
✔ pop(キー) を使うと、そのキーの値を取得しながら削除できる！
✔ キーが存在しない場合、KeyError が発生する！
✔ デフォルト値を指定すれば、エラーを回避できる！

📌 キーが存在しないとエラーになる
data = {""x"": 10}
value = data.pop(""y"")  # ❌ KeyError: 'y'

📌 エラーを防ぐ方法（デフォルト値を指定）
value = data.pop(""y"", ""Not Found"")
print(value)  # ""Not Found""（キーがなければデフォルト値を返す）

📌 del を使う方法（値は取得できない）
del data[""x""]  # ""x"" のキーを削除
print(data)  # {}

✅ del は pop() と違い、値を取得せずに削除する！",10,2,
184,"以下のコードを実行すると、出力される値は？

numbers = [1, 2, 3, 4, 5]
sliced = numbers[1:4]
print(sliced)

1️⃣ [1, 2, 3, 4]
2️⃣ [2, 3, 4]
3️⃣ [2, 3]
4️⃣ Error（エラーが発生する）","2️⃣ [2, 3, 4]","🔹 スライス（リストの一部を取得）
リストのスライス（list[start:end]）を使うと、リストの一部を切り出すことができます！

numbers = [1, 2, 3, 4, 5]
sliced = numbers[1:4]  # 1番目（2）から4番目（5）の直前（4）までを取得
print(sliced)

✅ スライス [1:4] は「1番目から4番目の直前（3番目）」までの要素を取得！

🔹 リストのインデックス
        numbers = [1, 2, 3, 4, 5]
（インデックス番号） 0  1  2  3  4   

📌 ポイント
✔ スライス [start:end] では、end の位置は含まれない！（end - 1 まで取得）
✔ リストの先頭からスライスする場合は numbers[:end]、末尾まで取得する場合は numbers[start:] を使う！
✔ numbers[:] を使うとリスト全体をコピーできる！

📌 最初から 3 番目（2番目の直前）まで取得
print(numbers[:2])  # [1, 2]

📌 3 番目以降を取得
print(numbers[2:])  # [3, 4, 5]

📌 負のインデックスを使って末尾からスライス
print(numbers[-3:])  # [3, 4, 5]（後ろ3つを取得）
",10,2,
185,"以下のコードを実行すると、出力される値は？

info = {""name"": ""Alice"", ""age"": 25}
info.clear()
print(info)

1️⃣ {""name"": ""Alice"", ""age"": 25}
2️⃣ {}
3️⃣ None
4️⃣ Error（エラーが発生する）","2️⃣ {}","🔹 clear() メソッドとは？
clear() メソッドは、辞書のすべての要素を削除し、空の辞書 {} にする メソッドです！

info = {""name"": ""Alice"", ""age"": 25}  # 辞書を作成
info.clear()  # 辞書のすべての要素を削除
print(info)  # 空の辞書 `{}` になる

✅ 辞書の中身はすべて削除され、空の辞書 {} になる！

📌 ポイント
✔ clear() を使うと辞書の中身がすべて削除され、空の辞書 {} になる！
✔ 辞書自体は削除されず、変数 info は空の辞書として残る！
✔ 辞書を完全に削除したい場合は del を使う！

📌 辞書を完全に削除する方法
del info  # 変数 `info` 自体を削除
print(info)  # ❌ NameError: name 'info' is not defined
✅ del を使うと、変数ごと削除されるため info は参照できなくなる！

📌 空の辞書を作成する方法
empty_dict = {}  # 空の辞書を作る
print(empty_dict)  # {}
",10,2,
186,"以下のコードを実行すると、出力される値は？

data = {""x"": 5, ""y"": 10}
data2 = data.copy()
data2[""y""] = 20
print(data[""y""])

1️⃣ 10
2️⃣ 20
3️⃣ { ""x"": 5, ""y"": 20 }
4️⃣ Error（エラーが発生する）","1️⃣ 10","🔹 copy() メソッドとは？
copy() メソッドは、辞書のシャローコピー（浅いコピー）を作成する メソッドです！
オリジナルの辞書には影響を与えず、コピーした辞書だけが変更される！

🔹 コードの流れ
data = {""x"": 5, ""y"": 10}  # 元の辞書
data2 = data.copy()  # シャローコピー（新しい辞書を作る）
data2[""y""] = 20  # コピー側（data2）の ""y"" の値を変更
print(data[""y""])  # 元の辞書（data）の ""y"" の値を表示

✅ data.copy() によって、新しい辞書 data2 が作られる！
✅ data2[""y""] = 20 の変更は data2 にのみ影響し、data には影響しない！
✅ 元の辞書 data[""y""] は変更されず、そのまま 10！

📌 ポイント
✔ copy() を使うと、新しい辞書が作成され、元の辞書とは別のオブジェクトになる！
✔ コピー後に data2 を変更しても、data には影響しない！
✔ リストや辞書の「シャローコピー」と「ディープコピー」の違いも知っておくと便利！

📌 copy() の動作確認
print(data)  # {'x': 5, 'y': 10}
print(data2)  # {'x': 5, 'y': 20}

📌 もしネストされた辞書をコピーする場合は deepcopy() を使う
import copy
nested_dict = {""a"": {""b"": 1}}
deep_copied = copy.deepcopy(nested_dict)
deep_copied[""a""][""b""] = 99
print(nested_dict)  # {'a': {'b': 1}}（元の辞書は変わらない！）
",10,2,
187,"以下のコードを実行すると、何が起こるでしょうか？

file = open(""test.txt"", ""w"")
file.write(""Hello, World!"")
file.close()

1️⃣ test.txt というファイルが作成され、内容は ""Hello, World!"" になる
2️⃣ test.txt というファイルが作成されるが、内容は空になる
3️⃣ test.txt は作成されず、エラーが発生する
4️⃣ 何も起こらない","1️⃣ test.txt というファイルが作成され、内容は ""Hello, World!"" になる","🔹 open(""ファイル名"", ""モード"") を使うと、ファイルを開いたり作成したりできる！
open(""test.txt"", ""w"") を実行すると、test.txt というファイルが作成され、書き込みモード (""w"") で開かれます。

file = open(""test.txt"", ""w"")  # ""test.txt"" を書き込みモードで開く（存在しない場合は新規作成）
file.write(""Hello, World!"")  # ""Hello, World!"" という文字列を書き込む
file.close()  # ファイルを閉じる

✅ このコードを実行すると、test.txt というファイルが作成され、その中に ""Hello, World!"" という内容が書き込まれる！

📌 ポイント
✔ ""w""（書き込みモード）を指定すると、新しいファイルを作成する！（既に存在する場合は上書き）
✔ write() を使って文字列を書き込める！
✔ close() を呼び出して、ファイルを閉じるのが基本！（安全のため）

📌 既存のファイルに追記 (""a"") したい場合
file = open(""test.txt"", ""a"")  # 追記モードで開く
file.write(""\n追加のテキスト"")  # 既存の内容の後に追加
file.close()

📌 with open() を使うと、close() を書かなくてもOK！
with open(""test.txt"", ""w"") as file:
    file.write(""Hello, World!"")

# 自動的にファイルが閉じられる！

✅ with open() を使うと、ファイルの閉じ忘れを防げるのでオススメ！",6,1,
188,"以下のコードを実行すると、出力される値は？

with open(""test.txt"", ""r"") as file:
    content = file.read()
print(content)

1️⃣ test.txt の内容がそのまま出力される
2️⃣ test.txt の1行目だけが出力される
3️⃣ test.txt の内容がリストで出力される
4️⃣ Error（エラーが発生する）","1️⃣ test.txt の内容がそのまま出力される","🔹 read() メソッドを使うと、ファイル全体の内容を一度に読み込むことができる！

with open(""test.txt"", ""r"") as file:  # ""test.txt"" を読み取りモード (""r"") で開く
    content = file.read()  # ファイルの内容をすべて読み込む
print(content)  # 読み込んだ内容を出力

✅ このコードを実行すると、test.txt に書かれている内容がそのまま表示される！

📌 ポイント
✔ open(""test.txt"", ""r"") は、""test.txt"" を ""読み取りモード"" で開く！
✔ read() はファイルの内容をすべて文字列として読み込む！
✔ with open() を使うと、ファイルが自動的に閉じられる！（close() の書き忘れを防げる！）

📌 もし test.txt が存在しないとエラー (FileNotFoundError) になる

with open(""non_existent.txt"", ""r"") as file:
    content = file.read()  # ❌ FileNotFoundError

✅ ファイルが存在するか事前に確認するには、os.path.exists() を使う！

import os
if os.path.exists(""test.txt""):
    with open(""test.txt"", ""r"") as file:
        content = file.read()
        print(content)
else:
    print(""ファイルが見つかりません！"")

📌 1行ずつ読み込む方法 (readline())
with open(""test.txt"", ""r"") as file:
    first_line = file.readline()  # 最初の1行を読み込む
print(first_line)

📌 リストとしてすべての行を取得 (readlines())
with open(""test.txt"", ""r"") as file:
    lines = file.readlines()  # 各行をリストとして取得
print(lines)  # ['Hello, World!\n', '次の行\n']
",6,1,
189,"以下のコードを実行すると、出力される値は？

with open(""test.txt"", ""a"") as file:
    file.write(""\n追加の行"")

1️⃣ test.txt の内容は変更されない
2️⃣ test.txt の内容が消え、「追加の行」だけが書き込まれる
3️⃣ test.txt の末尾に「追加の行」が追記される
4️⃣ Error（エラーが発生する）","3️⃣ test.txt の末尾に「追加の行」が追記される","🔹 ""a""（追記モード）を使うと、既存の内容を保持したまま末尾に追加できる！
with open(""test.txt"", ""a"") as file:  # ""a"" モードで開く（追記）
    file.write(""\n追加の行"")  # ファイルの末尾に新しい内容を追加

✅ このコードを実行すると、test.txt の既存の内容を保持したまま、末尾に ""\n追加の行"" が追加される！

🔹 出力（test.txt の中身）
Hello, World!
追加の行

✅ test.txt の末尾に「追加の行」が追記される 🎯

📌 ポイント
✔ ""a"" モードは「追記（append）」なので、元の内容は消えない！
✔ 改行を入れたい場合は ""\n"" を追加するのがポイント！
✔ 上書きしたい場合は ""w""（書き込みモード）を使う！

📌 書き込み (""w"") を使うと、元の内容が消える！
with open(""test.txt"", ""w"") as file:
    file.write(""新しい内容"")  # ⚠️ これを実行すると、既存の内容はすべて消える！

✅ 「上書き」ではなく「追記」したい場合は ""a"" を使う！

📌 複数行をまとめて追加 (writelines())
with open(""test.txt"", ""a"") as file:
    file.writelines([""\n1行目"", ""\n2行目""])

✅ リスト形式で複数行を一度に追加できる！

",6,1,
190,"以下のコードを実行すると、出力される値は？
但し、sample.txt は、存在しているものとする。

import os
os.remove(""sample.txt"")
print(""ファイル削除完了"")

1️⃣ ""sample.txt"" が削除され、""ファイル削除完了"" と表示される
2️⃣ ""sample.txt"" は削除されるが、エラーが発生する
3️⃣ 何も起こらない
4️⃣ ""sample.txt"" が存在しない場合、エラーが発生する","1️⃣ ""sample.txt"" が削除され、""ファイル削除完了"" と表示される","🔹 os.remove() はファイルを削除する関数！
os.remove(""ファイル名"") を使うと、指定したファイルを削除できます。
しかし、削除しようとしたファイルが存在しない場合、FileNotFoundError が発生します！

🔹 コードの流れ
import os
os.remove(""sample.txt"")  # ""sample.txt"" を削除
print(""ファイル削除完了"")  # 削除成功後に表示

✅ このコードは sample.txt が存在する場合は、ファイルを削除して ""ファイル削除完了"" と表示される！

❌ しかし、sample.txt が存在しない場合、FileNotFoundError が発生！

🔹 エラー発生時の出力
FileNotFoundError: [Errno 2] No such file or directory: 'sample.txt'

📌 ポイント
✔ os.remove(""ファイル名"") を使うと、指定したファイルを削除できる！
✔ ファイルが存在しないと FileNotFoundError が発生する！
✔ エラーを防ぐには、ファイルの存在を事前に確認する！

📌 ファイルが存在するか確認してから削除する方法
import os

if os.path.exists(""sample.txt""):
    os.remove(""sample.txt"")  # ファイルを削除
    print(""ファイル削除完了"")
else:
    print(""ファイルが存在しません"")

✅ これなら、ファイルがない場合でもエラーを回避できる！

📌 ディレクトリ（フォルダ）を削除する場合
os.rmdir(""sample_folder"")  # 空のフォルダを削除（中身があるとエラー）

📌 フォルダごと削除する場合（中身があっても削除）
import shutil
shutil.rmtree(""sample_folder"")  # フォルダとその中身をすべて削除

✅ フォルダを削除するときは shutil.rmtree() を使う！

",6,1,
191,"以下のコードを実行すると、出力される値は？
但し、sample.txt は、存在していないものとする。

import os
os.remove(""sample.txt"")
print(""ファイル削除完了"")

1️⃣ ""sample.txt"" が削除され、""ファイル削除完了"" と表示される
2️⃣ ""sample.txt"" は削除されるが、エラーが発生する
3️⃣ 何も起こらない
4️⃣ ""sample.txt"" が存在しない場合、エラーが発生する","4️⃣ ""sample.txt"" が存在しない場合、エラーが発生する","🔹 os.remove() はファイルを削除する関数！
os.remove(""ファイル名"") を使うと、指定したファイルを削除できます。
❌しかし、削除しようとしたファイルが存在しない場合、FileNotFoundError が発生します！",6,1,
192,"以下のコードを実行すると、出力される値は？
※ test.txt が存在しており、複数行のデータが含まれている とする。

with open(""test.txt"", ""r"") as file:
    for line in file:
        print(line, end="""")

1️⃣ test.txt の各行が改行ありで出力される
2️⃣ test.txt の各行が改行なしで出力される
3️⃣ test.txt の最初の1行だけが出力される
4️⃣ Error（エラーが発生する）","2️⃣ test.txt の各行が改行なしで出力される","🔹 for line in file: を使うと、ファイルを 1行ずつループしながら読み込む！
🔹 ファイルの各行にはすでに \n（改行）が含まれているので、print(line) だと二重改行になる！
🔹 しかし、print(line, end="""") を使うと print() のデフォルトの改行を防ぎ、行の末尾がそのまま出力される！

🔹 コードの流れ
with open(""test.txt"", ""r"") as file:
    for line in file:  # ファイルを1行ずつ読み込む
        print(line, end="""")  # `end=""""` でprintのデフォルト改行を防ぐ
✅ print(line, end="""") を使うことで、改行が追加されず、ファイル内の改行 (\n) だけが適用される！

🔹 ファイル (test.txt) の内容
Hello, World!
Python is fun!

🔹 出力
Hello, World!
Python is fun!
✅ 改行ありで出力されるが、余計な空行は発生しない！

📌 ポイント
✔ for line in file: は、ファイルを 1行ずつループしながら読み込む！
✔ print(line, end="""") を使うと、余計な改行を防げる！（通常 print() はデフォルトで改行する）
✔ ファイルの \n（改行文字）はそのままなので、改行は維持される！

📌 もし print(line) にすると？
with open(""test.txt"", ""r"") as file:
    for line in file:
        print(line)  # ここで改行が二重になる！
✅ print() はデフォルトで改行を入れるので、ファイルの改行と二重になり、間に空行ができる！

",6,2,
193,"以下のコードを実行すると、出力される値は？
※ test.txt の内容は ""Hello, Python!"" であるとする。

with open(""test.txt"", ""r"") as file:
    content = file.read(5)
print(content)

1️⃣ ""Hello""
2️⃣ ""Hello, Python!""
3️⃣ ""Hello,""
4️⃣ Error（エラーが発生する）","1️⃣ ""Hello""","🔹 read(n) メソッドとは？
read(n) を使うと、ファイルから指定した n 文字だけを読み込む ことができます！
✅ read(5) なら、最初の 5 文字 ""Hello"" を取得！

🔹 コードの流れ
with open(""test.txt"", ""r"") as file:
    content = file.read(5)  # 最初の5文字を読み込む
print(content)

✅ test.txt の内容が ""Hello, Python!"" の場合、最初の5文字は ""Hello"" なので、それが出力される！

📌 ポイント
✔ read(n) は、ファイルから n 文字だけを読み込む！（n 文字以上あっても、それ以上は読まない！）
✔ 改行 (\n) も1文字としてカウントされるので注意！
✔ read() に引数を渡さない場合、ファイル全体を読み込む！

📌 read() を引数なしで使うと？
with open(""test.txt"", ""r"") as file:
    content = file.read()  # 全部読み込む
print(content)

✅ 出力
Hello, Python!

📌 さらに5文字ずつ読む方法
with open(""test.txt"", ""r"") as file:
    print(file.read(5))  # ""Hello""
    print(file.read(5))  # "", Pyt""
    print(file.read(5))  # ""hon!""

✅ read(n) を繰り返すと、少しずつデータを読み取れる！

",6,2,
194,"以下のコードを実行すると、出力される値は？
※ test.txt の内容は ""Python\nis\nawesome!"" であるとする。

with open(""test.txt"", ""r"") as file:
    lines = file.readlines()
print(lines)

1️⃣ [""Python"", ""is"", ""awesome!""]
2️⃣ [""Python\n"", ""is\n"", ""awesome!""]
3️⃣ ""Python\nis\nawesome!""
4️⃣ Error（エラーが発生する）"," 2️⃣ [""Python\n"", ""is\n"", ""awesome!""]","🔹 readlines() メソッドとは？
readlines() は、ファイルの各行を「リスト」として取得するメソッド です。
✅ 各行はリストの要素になり、改行 (\n) もそのまま含まれる！

🔹 コードの流れ

with open(""test.txt"", ""r"") as file:
    lines = file.readlines()  # 各行をリストとして取得
print(lines)

✅ test.txt の内容が ""Python\nis\nawesome!"" の場合、リストとして各行が取得される！

🔹 ファイル (test.txt) の内容
Python
is
awesome!

🔹 readlines() の出力
[""Python\n"", ""is\n"", ""awesome!""]

✅ 正解は 2️⃣ [""Python\n"", ""is\n"", ""awesome!""] 🎯

📌 ポイント
✔ readlines() は、ファイルの各行をリストで取得する！（改行 \n もそのまま含まれる！）
✔ リスト形式なので、lines[0] で最初の行、lines[1] で2行目を取得できる！
✔ strip() を使えば改行を削除できる！

📌 read() を使うと？
with open(""test.txt"", ""r"") as file:
    content = file.read()  # ファイル全体を1つの文字列として読み込む
print(content)
✅ 出力
Python
is
awesome!

❌ read() は1つの文字列として全体を取得する！（list ではない！）

📌 改行なしのリストを作るには？

with open(""test.txt"", ""r"") as file:
    lines = [line.strip() for line in file.readlines()]  # `strip()` で改行を削除
print(lines)

✅ 出力
[""Python"", ""is"", ""awesome!""]

✅ これなら 1️⃣ のように改行を削除したリストを作れる！

",6,2,
195,"以下のコードを実行すると、出力される値は？
※ test.txt の内容は ""Python\nis\nawesome!"" であるとする。

with open(""test.txt"", ""r"") as file:
    first_line = file.readline()
print(first_line)

1️⃣ ""Python""
2️⃣ ""Python\n""
3️⃣ [""Python\n""]
4️⃣ Error（エラーが発生する）","2️⃣ ""Python\n""","🔹 readline() メソッドとは？
readline() を使うと、ファイルの最初の1行だけを取得できる！
✅ 改行 (\n) もそのまま含まれるので注意！

🔹 コードの流れ
with open(""test.txt"", ""r"") as file:
    first_line = file.readline()  # 最初の1行を取得
print(first_line)
✅ test.txt の内容が ""Python\nis\nawesome!"" の場合、最初の1行 ""Python\n"" が取得される！

🔹 ファイル (test.txt) の内容
Python
is
awesome!

🔹 出力
Python\n

📌 ポイント
✔ readline() は、最初の1行だけを取得する！（改行 \n も含まれる！）
✔ 次に readline() を呼び出せば、次の行を取得できる！
✔ 改行を削除したい場合は strip() を使う！

📌 2行目を取得するには？
with open(""test.txt"", ""r"") as file:
    print(file.readline())  # ""Python\n""
    print(file.readline())  # ""is\n""

📌 改行を削除するには？
with open(""test.txt"", ""r"") as file:
    first_line = file.readline().strip()  # `strip()` で改行を削除
print(first_line)

✅ 出力
Python

📌 すべての行をリストで取得したい場合（readlines() を使う）
with open(""test.txt"", ""r"") as file:
    lines = file.readlines()
print(lines)

✅ 出力
[""Python\n"", ""is\n"", ""awesome!""]

❌ readline() はリストを返さないので、[""Python\n""] にはならない！

📌 readlines() と readline() の違い
🔹 readline()
ファイルの最初の1行を「文字列」として取得する
リストではなく、文字列として扱う

🔹 readlines()
ファイル全体の行を「リスト」として取得する
リストの各要素が1行になり、改行 (\n) も含まれる",6,2,
196,"以下のコードを実行すると、出力される値は？
※ test.txt の内容は ""Hello, Python!"" であるとする。

with open(""test.txt"", ""r"") as file:
    file.seek(7)
    content = file.read(5)
print(content)

1️⃣ ""Hello""
2️⃣ ""Pytho""
3️⃣ "", Py""
4️⃣ Error（エラーが発生する）","2️⃣ ""Pytho"" ","🔹 seek(n) メソッドとは？
seek(n) を使うと、ファイルの読み取り位置（カーソル）を n バイト目に移動する ことができます！

""Hello, Python!""
✅ **seek(7) により、ファイルの先頭から 7バイト目（, の位置） に移動！
✅ その位置から read(5) で5文字 ("", Py"") を取得！

 0  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15
 H  e  l  l  o  ,     P  y  t  h  o  n  !
✅ seek(7) により、7バイト目（, の位置）に移動し、そこから5文字 "", Py"" を取得！

📌 ポイント
✔ seek(n) は、ファイルの読み取り位置を n バイト目に移動する！
✔ read(n) は、そこから n 文字を取得する！
✔ 改行 (\n) も1バイトとしてカウントされるので注意！

📌 tell() で現在の読み取り位置を確認できる
with open(""test.txt"", ""r"") as file:
    print(file.tell())  # 0（ファイルの先頭）
    file.seek(7)
    print(file.tell())  # 7（カーソルの移動後）




",6,2,
197,"以下のコードを実行すると、出力される値は？
※ test.txt の内容は ""Hello, World!"" であるとする。

with open(""test.txt"", ""r+"") as file:
    file.write(""Goodbye"")
    file.seek(0)
    content = file.read()
print(content)

1️⃣ ""Hello, World!""
2️⃣ ""Goodbye, World!""
3️⃣ ""Goodbyeorld!""
4️⃣ Error（エラーが発生する）","3️⃣ ""GoodbyeWorld!""","🔹 r+ モード（読み書き）とは？
r+ モードを使うと、ファイルを「読み書き両方できる状態」で開く ことができます。
しかし、「上書き」されるが、元の文字数が変わらない範囲でしか影響しない という特徴があります！

🔹 コードの流れ
with open(""test.txt"", ""r+"") as file:
    file.write(""Goodbye"")  # 先頭の7文字に ""Goodbye"" を上書き
    file.seek(0)  # ファイルの先頭に戻る
    content = file.read()  # ファイル全体を読み込む
print(content)
✅ 最初に ""Goodbye"" が ""Hello, "" の部分に上書きされる！
✅ seek(0) により、ファイルの先頭から再び読み込み！

🔹 ファイル (test.txt) の内容（元の状態）
　　Hello, World!

 0  1  2  3  4  5  6  7  8  9 10 11 12
 H  e  l  l  o  ,     W  o  r  l  d  !

🔹 write(""Goodbye"") を実行すると？
GoodbyeWorld!
✅ ""Hello, ""（7文字）→ ""Goodbye""（7文字） に上書きされ、""World!"" はそのまま残る！

🔹 出力
GoodbyeWorld!

📌 ポイント
✔ r+ モードは「読み書き両方できる」が、元のデータの長さが変わらない範囲での上書きのみ！
✔ ファイルの先頭から write() すると、その分だけ既存のデータに上書きされる！
✔ 元のデータが ""Hello, World!""（13文字）、新しく書き込む ""Goodbye""（7文字）なので、""World!"" の部分はそのまま残る！

📌 元の内容を完全に書き換えたい場合は w モード（書き込み専用）を使う！
with open(""test.txt"", ""w"") as file:
    file.write(""Goodbye"")
✅ これなら ""Hello, World!"" が完全に消えて、""Goodbye"" だけが残る！

📌 ファイルの内容を最初に消してから r+ を使いたい場合
with open(""test.txt"", ""r+"") as file:
    file.truncate(0)  # ファイルを空にする
    file.write(""Goodbye"")
✅ これなら test.txt の中身を完全に書き換えられる！

",6,2,
198,"以下のコードを実行すると、出力されるのは？

try:
    result = 10 / 0
except ZeroDivisionError:
    print(""ゼロ除算エラーが発生しました！"")

1️⃣ 10 / 0 の結果が表示される
2️⃣ ""ゼロ除算エラーが発生しました！"" が表示される
3️⃣ エラーが発生し、プログラムが停止する
4️⃣ ""except"" ブロックが無視され、何も表示されない","2️⃣ ""ゼロ除算エラーが発生しました！"" が表示される","🔹 try-except とは？
try-except は、エラー（例外）が発生したときに、プログラムが停止しないように処理するための仕組み！

🔹 コードの流れ
try:
    result = 10 / 0  # 🔴 ここで「ゼロ除算エラー」が発生！
except ZeroDivisionError:
    print(""ゼロ除算エラーが発生しました！"")  # ✅ 例外が発生したので、ここが実行される！

✅ 10 / 0 は数学的に定義されていないため、ZeroDivisionError が発生する！
✅ except ZeroDivisionError: が ZeroDivisionError をキャッチするので、エラーメッセージを表示！

🔹 出力
ゼロ除算エラーが発生しました！

📌 ポイント
✔ try ブロックの中でエラーが発生すると、except に処理が移る！
✔ ZeroDivisionError は「ゼロで割ると発生する例外」！
✔ except でエラーを適切に処理することで、プログラムが途中で止まるのを防げる！

📌 例：エラーをキャッチしないとどうなる？
result = 10 / 0  # 例外処理なし
❌ エラーが発生してプログラムがクラッシュ！
ZeroDivisionError: division by zero

📌 異なる例外をキャッチすることもできる！
try:
    x = int(""ABC"")  # ここで ValueError が発生！
except ValueError:
    print(""数値に変換できません！"")

✅ 出力
数値に変換できません！
",7,1,
199,"以下のコードを実行すると、出力されるのは？

try:
    x = int(""ABC"")
except ValueError:
    print(""変換エラーが発生しました！"")

1️⃣ x に ""ABC"" が代入される
2️⃣ ValueError が発生し、プログラムが停止する
3️⃣ ""変換エラーが発生しました！"" が表示される
4️⃣ 何も表示されない","3️⃣ ""変換エラーが発生しました！"" が表示される","🔹 ValueError とは？
ValueError は、データの型（型変換）が正しくない場合に発生するエラー！
例えば、int(""ABC"") のように、数値に変換できない文字列を int() に渡すと ValueError になる。

🔹 コードの流れ
try:
    x = int(""ABC"")  # 🔴 ここで ValueError が発生！
except ValueError:
    print(""変換エラーが発生しました！"")  # ✅ 例外をキャッチしてメッセージを表示！

✅ int(""ABC"") は、文字 ""ABC"" を数値に変換できないため ValueError が発生！
✅ except ValueError: で ValueError をキャッチするので、エラーメッセージを表示！

🔹 出力
変換エラーが発生しました！
✅ 正解は 3️⃣ ""変換エラーが発生しました！"" 🎯

📌 ポイント
✔ int() に数値以外の文字列を渡すと ValueError が発生する！
✔ try-except を使えば、エラーが発生してもプログラムを継続できる！
✔ except ValueError: で、数値変換エラーだけをキャッチできる！

📌 ValueError が発生する例
x = int(""123"")  # ✅ OK（""123"" は整数に変換できる）
y = int(""ABC"")  # ❌ ValueError（""ABC"" は整数に変換できない！）

📌 複数の例外をキャッチする方法
try:
    x = int(""ABC"")
except (ValueError, TypeError):  # 複数の例外をキャッチ可能！
    print(""変換エラーまたは型エラーが発生しました！"")
✅ ValueError や TypeError のどちらが発生しても対応できる！

📌 エラーの詳細メッセージを取得する
try:
    x = int(""ABC"")
except ValueError as e:
    print(f""エラー内容: {e}"")  # エラーメッセージを表示

✅ 出力
エラー内容: invalid literal for int() with base 10: 'ABC'
",7,1,
200,"以下のコードを実行すると、出力されるのは？

try:
    my_list = [1, 2, 3]
    print(my_list[5])
except IndexError:
    print(""インデックスエラーが発生しました！"")

1️⃣ 3 が表示される
2️⃣ IndexError が発生し、プログラムが停止する
3️⃣ ""インデックスエラーが発生しました！"" が表示される
4️⃣ 何も表示されない","3️⃣ ""インデックスエラーが発生しました！"" が表示される","🔹 IndexError とは？
IndexError は、リストやタプルの範囲外のインデックスを指定したときに発生するエラー！
たとえば、長さが3のリストに my_list[5] のような存在しないインデックス を指定すると IndexError になる。

🔹 コードの流れ
try:
    my_list = [1, 2, 3]
    print(my_list[5])  # 🔴 存在しないインデックス → IndexError 発生！
except IndexError:
    print(""インデックスエラーが発生しました！"")  # ✅ 例外をキャッチしてメッセージを表示！

✅ my_list の要素は [1, 2, 3]（インデックス 0, 1, 2）しかない！
✅ my_list[5] は存在しないので IndexError が発生！
✅ except IndexError: により、エラーをキャッチして ""インデックスエラーが発生しました！"" を表示！

🔹 出力
インデックスエラーが発生しました！

📌 ポイント
✔ リストの範囲外のインデックスを指定すると IndexError が発生する！
✔ try-except を使えば、エラーが発生してもプログラムを継続できる！
✔ except IndexError: で IndexError だけをキャッチできる！

📌 IndexError が発生する例
my_list = [10, 20, 30]
print(my_list[3])  # ❌ IndexError（リストの最大インデックスは2）

📌 エラーを防ぐ方法
my_list = [10, 20, 30]
index = 3

if index < len(my_list):  # インデックスが範囲内か確認
    print(my_list[index])
else:
    print(""無効なインデックスです！"")
✅ リストの長さ len(my_list) を使って範囲チェックすればエラーを防げる！

📌 エラーの詳細メッセージを取得する
try:
    my_list = [1, 2, 3]
    print(my_list[5])
except IndexError as e:
    print(f""エラー内容: {e}"")  # エラーメッセージを表示

✅ 出力
エラー内容: list index out of range

✅ list index out of range というメッセージで、範囲外のアクセスだと分かる！

",7,1,
201,"以下のコードを実行すると、出力されるのは？

try:
    x = ""hello"" + 5
except TypeError:
    print(""型エラーが発生しました！"")

1️⃣ ""hello5"" が表示される
2️⃣ TypeError が発生し、プログラムが停止する
3️⃣ ""型エラーが発生しました！"" が表示される
4️⃣ 何も表示されない","3️⃣ ""型エラーが発生しました！"" が表示される","🔹 TypeError とは？
TypeError は、異なるデータ型を不適切に扱ったときに発生するエラー！
たとえば、文字列 (str) と整数 (int) を直接 + で結合しようとすると TypeError になる！

🔹 コードの流れ
try:
    x = ""hello"" + 5  # 🔴 異なる型を + で結合 → TypeError 発生！
except TypeError:
    print(""型エラーが発生しました！"")  # ✅ 例外をキャッチしてメッセージを表示！

✅ ""hello"" は str（文字列）で、5 は int（整数）！
✅ str + int は許可されていないため TypeError が発生！
✅ except TypeError: で TypeError をキャッチし、 ""型エラーが発生しました！"" を表示！

🔹 出力
型エラーが発生しました！

📌 ポイント
✔ 異なる型（str と int など）を + で結合すると TypeError が発生する！
✔ try-except を使えば、エラーが発生してもプログラムを継続できる！
✔ except TypeError: で TypeError だけをキャッチできる！

📌 正しく結合する方法
x = ""hello"" + str(5)  # ✅ int を str に変換
print(x)  # hello5
✅ 文字列に変換すれば TypeError は発生しない！

📌 エラーの詳細メッセージを取得する
try:
    x = ""hello"" + 5
except TypeError as e:
    print(f""エラー内容: {e}"")  # エラーメッセージを表示

✅ 出力
エラー内容: can only concatenate str (not ""int"") to str

✅ 「int を str に連結できない！」と明示されている！

📌 isinstance() を使って型をチェック
x = ""hello""
y = 5

if isinstance(y, str):  # y が文字列かチェック
    result = x + y
else:
    result = x + str(y)  # 型変換を行う
print(result)

✅ こうすれば TypeError を未然に防げる！

",7,1,
202,"以下のコードを実行すると、出力されるのは？

try:
    my_dict = {""a"": 1, ""b"": 2}
    print(my_dict[""c""])
except KeyError:
    print(""キーエラーが発生しました！"")

1️⃣ None が表示される
2️⃣ KeyError が発生し、プログラムが停止する
3️⃣ ""キーエラーが発生しました！"" が表示される
4️⃣ 0 が表示される","3️⃣ ""キーエラーが発生しました！"" が表示される","🔹 KeyError とは？
KeyError は、辞書（dict）で存在しないキーを指定したときに発生するエラー！
たとえば、辞書に ""c"" というキーが存在しないのに my_dict[""c""] を実行すると KeyError になる。

🔹 コードの流れ
try:
    my_dict = {""a"": 1, ""b"": 2}
    print(my_dict[""c""])  # 🔴 ""c"" は辞書にないので KeyError 発生！
except KeyError:
    print(""キーエラーが発生しました！"")  # ✅ 例外をキャッチしてメッセージを表示！

✅ 辞書 my_dict には ""a"" と ""b"" しかない！
✅ my_dict[""c""] は存在しないキーを参照するので KeyError が発生！
✅ except KeyError: で KeyError をキャッチし、 ""キーエラーが発生しました！"" を表示！

🔹 出力
キーエラーが発生しました！

📌 ポイント
✔ 辞書で存在しないキーを参照すると KeyError が発生する！
✔ try-except を使えば、エラーが発生してもプログラムを継続できる！
✔ except KeyError: で KeyError だけをキャッチできる！

📌 KeyError が発生する例
my_dict = {""x"": 10, ""y"": 20}
print(my_dict[""z""])  # ❌ ""z"" は辞書にないので KeyError 発生！

📌 get() を使ってエラーを防ぐ
my_dict = {""x"": 10, ""y"": 20}
value = my_dict.get(""z"", ""キーが存在しません"")  # 🔹 get() なら KeyError を防げる！
print(value)

✅ 出力
キーが存在しません

✅ get(""キー"", デフォルト値) を使えば、キーが存在しない場合でもデフォルト値を返せる！

📌 エラーの詳細メッセージを取得
try:
    my_dict = {""a"": 1, ""b"": 2}
    print(my_dict[""c""])
except KeyError as e:
    print(f""エラー内容: {e}"")  # エラーメッセージを表示

✅ 出力
エラー内容: 'c'

✅ 'c' というキーがないことが分かる！

",7,1,
203,"以下のコードを実行すると、出力されるのは？

try:
    num_list = [1, 2, 3]
    for i in range(5):
        print(num_list[i])
except IndexError:
    print(""リストの範囲外にアクセスしました！"")

1️⃣ 1 2 3 が表示される
2️⃣ 1 2 3 が表示され、その後 ""リストの範囲外にアクセスしました！"" が表示される
3️⃣ IndexError が発生し、プログラムが停止する
4️⃣ 何も表示されない","2️⃣ 1 2 3 が表示され、その後 ""リストの範囲外にアクセスしました！"" が表示される","🔹 このコードのポイント

for i in range(5): で i が 0 から 4 まで変化する
num_list = [1, 2, 3] なので、リストの範囲は 0, 1, 2 のみ（3要素）
i = 3 になると num_list[3] が 存在しないため IndexError が発生！
try-except によって、エラーメッセージが表示される！
🔹 コードの流れ
try:
    num_list = [1, 2, 3]
    for i in range(5):  # 🔹 i は 0, 1, 2, 3, 4 の順に変化
        print(num_list[i])  # 🔴 i = 3 で IndexError が発生！
except IndexError:
    print(""リストの範囲外にアクセスしました！"")  # ✅ 例外をキャッチしてメッセージを表示！

✅ i = 0, 1, 2 のときは問題なくリストの要素が表示される！
✅ i = 3 で num_list[3] にアクセスしようとして IndexError が発生！
✅ エラーをキャッチし ""リストの範囲外にアクセスしました！"" が表示！

🔹 出力
1
2
3
リストの範囲外にアクセスしました！

📌 ポイント
✔ for ループが try ブロック内にある場合、途中でエラーが発生すると except に処理が移る！
✔ IndexError は「リストの範囲外」にアクセスすると発生する！
✔ エラーをキャッチすれば、プログラムが途中で止まらず、適切なエラーメッセージを表示できる！

📌 安全な方法（len() を使う）
num_list = [1, 2, 3]
for i in range(len(num_list)):  # ✅ リストの長さに基づいてループ
    print(num_list[i])

✅ これなら IndexError は発生しない！

📌 エラーの詳細メッセージを取得
try:
    num_list = [1, 2, 3]
    for i in range(5):
        print(num_list[i])
except IndexError as e:
    print(f""エラー内容: {e}"")  # エラーメッセージを表示

✅ 出力
1
2
3
エラー内容: list index out of range

✅ 「list index out of range」で範囲外アクセスだと分かる！

",7,2,
204,"以下のコードを実行すると、出力されるのは？

try:
    raise ValueError(""無効な値です！"")
except ValueError as e:
    print(f""エラーが発生しました: {e}"")

1️⃣ ""エラーが発生しました: 無効な値です！"" が表示される
2️⃣ ValueError が発生し、プログラムが停止する
3️⃣ 何も表示されない
4️⃣ ""無効な値です！"" のみが表示される","1️⃣ ""エラーが発生しました: 無効な値です！"" が表示される","🔹 raise とは？
raise は、プログラムの中で意図的に例外（エラー）を発生させるときに使う！
たとえば、入力値が不正な場合などに、raise を使ってエラーを発生させることができる。

🔹 コードの流れ
try:
    raise ValueError(""無効な値です！"")  # 🔴 ここで ValueError を意図的に発生！
except ValueError as e:
    print(f""エラーが発生しました: {e}"")  # ✅ 例外をキャッチしてメッセージを表示！

✅ raise ValueError(""無効な値です！"") により ValueError が発生！
✅ except ValueError as e: で ValueError をキャッチ！
✅ エラーメッセージ ""無効な値です！"" を変数 e に格納し、メッセージを表示！

🔹 出力
エラーが発生しました: 無効な値です！

📌 ポイント
✔ raise を使うと、意図的に例外を発生させることができる！
✔ except で as e を使うと、エラーメッセージを取得できる！
✔ エラーメッセージを表示すれば、問題の原因を特定しやすくなる！

📌 raise を使うケース
def check_age(age):
    if age < 0:
        raise ValueError(""年齢は0以上である必要があります！"")
    print(f""年齢: {age}"")

try:
    check_age(-5)
except ValueError as e:
    print(f""エラーが発生しました: {e}"")

✅ 出力
エラーが発生しました: 年齢は0以上である必要があります！

✅ raise を使えば、条件に応じて適切なエラーを発生させられる！

📌 エラーの詳細メッセージを取得
try:
    raise TypeError(""型が正しくありません！"")
except TypeError as e:
    print(f""エラー内容: {e}"")

✅ 出力
エラー内容: 型が正しくありません！

✅ エラーの種類を適切に指定すれば、バグの原因が分かりやすくなる！

",7,2,
205,"以下のコードを実行すると、出力されるのは？
try:
    x = 10 / 2
finally:
    print(""処理が終了しました。"")

1️⃣ ""処理が終了しました。"" のみが表示される
2️⃣ 5.0 のみが表示される
3️⃣ 5.0 が表示された後 ""処理が終了しました。"" が表示される
4️⃣ エラーが発生し、プログラムが停止する","3️⃣ 5.0 が表示された後 ""処理が終了しました。"" が表示される","🔹 finally とは？
finally ブロックは、try の中でエラーが発生したかどうかに関係なく、必ず実行される処理！
try-except-finally の構造 では、finally は最後に実行される。

🔹 コードの流れ
try:
    x = 10 / 2  # ✅ ここはエラーなく実行される（x = 5.0）
finally:
    print(""処理が終了しました。"")  # ✅ `finally` は必ず実行される

✅ 10 / 2 は正常な計算なので x = 5.0 が出力される！
✅ finally: の中の print(""処理が終了しました。"") は必ず実行される！

🔹 出力
5.0
処理が終了しました。

📌 ポイント
✔ finally は、エラーが発生しても発生しなくても、必ず実行される！
✔ ファイルの後処理やリソースの解放などに finally を使う！
✔ try-finally だけでも使える！（except は省略可能！）

📌 finally の実用例（ファイルを開いたら必ず閉じる）
try:
    file = open(""data.txt"", ""r"")
    content = file.read()
finally:
    file.close()  # ✅ `finally` で必ずファイルを閉じる！

✅ エラーが発生しても file.close() は必ず実行される！

📌 エラーが発生する場合
try:
    x = 10 / 0  # ❌ ZeroDivisionError 発生！
finally:
    print(""処理が終了しました。"")  # ✅ それでも `finally` は実行される！

✅ 出力
処理が終了しました。
Traceback (most recent call last):
  File ""main.py"", line 2, in <module>
    x = 10 / 0
ZeroDivisionError: division by zero

✅ finally は実行されるが、エラーがキャッチされないとプログラムは停止する！

",7,2,
206,"以下のコードを実行すると、出力されるのは？

try:
    x = int(""42"")
except ValueError:
    print(""変換エラーが発生しました！"")
else:
    print(""正常に変換できました！"")

1️⃣ ""変換エラーが発生しました！"" が表示される
2️⃣ ""正常に変換できました！"" が表示される
3️⃣ 42 が表示される
4️⃣ エラーが発生し、プログラムが停止する","2️⃣ ""正常に変換できました！"" が表示される","🔹 else は、try ブロック内の処理が成功した場合に実行される！
try-except-else の構造 を使うと、エラーが発生しなかった場合の処理を明示的に指定できる！

🔹 コードの流れ

try:
    x = int(""42"")  # ✅ ""42"" は数値に変換できる！（エラーなし）
except ValueError:
    print(""変換エラーが発生しました！"")  # ❌ エラーが発生しないので実行されない
else:
    print(""正常に変換できました！"")  # ✅ try が成功したので実行される！

✅ int(""42"") は正常に実行され、エラー (ValueError) は発生しない！
✅ except ブロックはスキップされ、else ブロックが実行される！

🔹 出力
正常に変換できました！


📌 ポイント
✔ else は try 内の処理が成功した場合にのみ実行される！
✔ エラーが発生すると else は実行されず、except に処理が移る！
✔ try-except-else を使うと、エラーがない場合の処理を明確に分けられる！

📌 エラーが発生する場合
try:
    x = int(""abc"")  # ❌ ""abc"" は数値に変換できない！
except ValueError:
    print(""変換エラーが発生しました！"")  # ✅ 例外が発生したので実行！
else:
    print(""正常に変換できました！"")  # ❌ ここはスキップされる！

✅ 出力
変換エラーが発生しました！

✅ エラーが発生すると else は実行されない！

📌 else の実用例
try:
    file = open(""data.txt"", ""r"")
except FileNotFoundError:
    print(""ファイルが見つかりません！"")
else:
    print(""ファイルが正常に開けました！"")
    file.close()  # ✅ ファイルを閉じる処理

✅ エラーがなければ else で後処理を行うことができる！

",7,2,
207,"以下のコードを実行すると、出力されるのは？

try:
    try:
        1 / 0
    except ZeroDivisionError:
        print(""内側の例外処理"")
        raise
except ZeroDivisionError:
    print(""外側の例外処理"")

1️⃣ ""内側の例外処理"" のみが表示される
2️⃣ ""外側の例外処理"" のみが表示される
3️⃣ ""内側の例外処理"" と ""外側の例外処理"" の両方が表示される
4️⃣ エラーが発生し、プログラムが停止する","3️⃣ ""内側の例外処理"" と ""外側の例外処理"" の両方が表示される","🔹 raise とは？
raise は 現在の例外を再び発生させる（再送する）ために使う。
except の中で raise を使うと、例外が外側の try-except に伝播される！
ネストした try-except の場合、内側で raise すると、外側の except でキャッチされる！

🔹 コードの流れ
try:
    try:
        1 / 0  # 🔴 ここで `ZeroDivisionError` 発生！
    except ZeroDivisionError:
        print(""内側の例外処理"")  # ✅ まずこのメッセージが表示される！
        raise  # 🔴 例外を外側の `try` に再送（再度発生させる）
except ZeroDivisionError:
    print(""外側の例外処理"")  # ✅ `raise` された例外をキャッチ！

✅ 内側の except ZeroDivisionError: で ZeroDivisionError をキャッチ！
✅ print(""内側の例外処理"") が実行される！
✅ その後、raise で例外が再送される！
✅ 外側の except ZeroDivisionError: で、再送された ZeroDivisionError をキャッチ！
✅ print(""外側の例外処理"") が実行される！

🔹 出力
内側の例外処理
外側の例外処理

📌 ポイント
✔ raise を使うと、内側でキャッチした例外を外側に伝播できる！
✔ 外側で例外を再キャッチすれば、より適切な処理を実行できる！
✔ raise は「例外の再発生」だけでなく、新しい例外を発生させることもできる！

📌 raise の別の使い方（新しい例外を発生）
try:
    raise ValueError(""無効な値です！"")
except ValueError as e:
    print(f""エラー発生: {e}"")
    raise TypeError(""型エラーが発生しました！"")  # 🔹 新しい例外を発生！

✅ 出力
エラー発生: 無効な値です！
Traceback (most recent call last):
  File ""main.py"", line 2, in <module>
    raise ValueError(""無効な値です！"")
ValueError: 無効な値です！

During handling of the above exception, another exception occurred:

Traceback (most recent call last):
  File ""main.py"", line 5, in <module>
    raise TypeError(""型エラーが発生しました！"")
TypeError: 型エラーが発生しました！

✅ ValueError をキャッチした後、TypeError を新たに発生させることができる！

",7,3,
208,"以下のコードを実行すると、出力されるのは？

import math
print(math.sqrt(25))

1️⃣ 5.0
2️⃣ 25.0
3️⃣ エラーが発生する
4️⃣ 5","1️⃣ 5.0","🔹 math モジュールとは？
Pythonの math モジュール は、数学的な計算を行うための組み込みモジュール！
平方根（sqrt()）、三角関数、対数などの関数が用意されている。

🔹 コードの流れ
import math  # ✅ math モジュールをインポート
print(math.sqrt(25))  # ✅ 25 の平方根を求める

✅ math.sqrt(25) は、25 の平方根を計算する！
✅ 平方根（ルート）は √25 = 5.0 なので、結果は 5.0！

🔹 出力
5.0

📌 ポイント
✔ math.sqrt(n) を使うと n の平方根を求められる！
✔ 戻り値は float（浮動小数点数）になる！（整数ではなく 5.0 になる！）
✔ math モジュールをインポートして使う！

📌 math のその他の関数
import math

print(math.pow(2, 3))  # ✅ 2の3乗（2^3 = 8.0）
print(math.floor(3.9))  # ✅ 小数点以下を切り捨て（3）
print(math.ceil(3.1))   # ✅ 小数点以下を切り上げ（4）
print(math.pi)          # ✅ 円周率（3.141592653589793）



✅ 出力
8.0
3
4
3.141592653589793

✅ math には数学に関する便利な関数がたくさんある！

",8,1,
209,"以下のコードを実行すると、出力されるのは？

import random
print(random.randint(1, 10))

1️⃣ 1 から 10 の間の整数がランダムに表示される
2️⃣ 1.0 から 10.0 の間の浮動小数点数がランダムに表示される
3️⃣ エラーが発生する
4️⃣ 常に 5 が表示される","1️⃣ 1 から 10 の間の整数がランダムに表示される","🔹 random.randint(a, b) とは？
Pythonの random モジュールを使うと、ランダムな値を生成 できる！
random.randint(a, b) は、a 以上 b 以下のランダムな整数を返す関数！

🔹 コードの流れ
import random  # ✅ ランダムな値を扱うために random モジュールをインポート
print(random.randint(1, 10))  # ✅ 1 以上 10 以下のランダムな整数を出力
✅ random.randint(1, 10) は 1 から 10 の間の整数をランダムに返す！
✅ 実行するたびに異なる値が出る！（例: 3, 7, 10 など）

📌 random モジュールのポイント
✔ random.randint(a, b) → a 以上 b 以下のランダムな整数を取得
✔ random.random() → 0.0 以上 1.0 未満のランダムな浮動小数点数を取得
✔ random.uniform(a, b) → a 以上 b 以下のランダムな浮動小数点数を取得

📌 その他のランダム関数
import random

print(random.randint(1, 10))    # ✅ 1 ～ 10 のランダムな整数
print(random.random())          # ✅ 0.0 ～ 1.0 のランダムな浮動小数点数
print(random.uniform(5, 10))    # ✅ 5.0 ～ 10.0 のランダムな浮動小数点数
print(random.choice([""A"", ""B"", ""C""]))  # ✅ リストからランダムに1つ選ぶ

✅ 出力例
7
0.482934
8.76321
B

✅ random を使うと、ゲームやデータ分析などで便利に使える！

",8,1,
210,"以下のコードを実行すると、出力されるのは？

import datetime
today = datetime.date.today()
print(today)

1️⃣ 現在の日付が YYYY-MM-DD 形式で表示される
2️⃣ 1970-01-01 が表示される
3️⃣ 現在の時刻 が HH:MM:SS 形式で表示される
4️⃣ エラーが発生する","1️⃣ 現在の日付が YYYY-MM-DD 形式で表示される","🔹 datetime モジュールとは？
Pythonの datetime モジュールは、日付や時刻を扱うための標準ライブラリ！
✅ datetime.date.today() を使うと、現在の日付を取得できる！

🔹 コードの流れ
import datetime  # ✅ 日付・時刻を扱うために datetime モジュールをインポート
today = datetime.date.today()  # ✅ 現在の日付を取得
print(today)  # ✅ YYYY-MM-DD 形式で出力

✅ datetime.date.today() は、現在の日付を YYYY-MM-DD 形式で返す！

🔹 出力例（実行時の日付によって変わる！）
2025-02-05

📌 datetime モジュールのポイント
✔ datetime.date.today() → 現在の日付（YYYY-MM-DD）を取得
✔ datetime.datetime.now() → 現在の「日時」（YYYY-MM-DD HH:MM:SS）を取得
✔ datetime.timedelta(days=n) → 日付の加減算ができる！

📌 その他の datetime 関数
import datetime

# ✅ 現在の日付
today = datetime.date.today()
print(today)  # 例: 2025-02-05

# ✅ 現在の日時
now = datetime.datetime.now()
print(now)  # 例: 2025-02-05 14:30:12.123456

# ✅ 1週間後の日付
next_week = today + datetime.timedelta(days=7)
print(next_week)  # 例: 2025-02-12

# ✅ 1日前の日付
yesterday = today - datetime.timedelta(days=1)
print(yesterday)  # 例: 2025-02-04

✅ 実行すると、その日ごとに異なる日付や時刻が表示される！

",8,1,
211,"以下のコードを実行すると、出力されるのは？

import datetime
now = datetime.datetime.now()
formatted_time = now.strftime(""%Y/%m/%d %H:%M:%S"")
print(formatted_time)

1️⃣ YYYY/MM/DD HH:MM:SS の形式で現在の日時が表示される
2️⃣ YYYY-MM-DD HH:MM:SS の形式で現在の日時が表示される
3️⃣ エラーが発生する
4️⃣ 1970/01/01 00:00:00 が表示される","1️⃣ YYYY/MM/DD HH:MM:SS の形式で現在の日時が表示される","🔹 strftime() とは？
Pythonの datetime.strftime() は、日付や時刻を好きな形式の文字列に変換するためのメソッド！
✅ フォーマット文字列を指定することで、datetime オブジェクトを自由に整形できる！

🔹 コードの流れ
import datetime  # ✅ 日付・時刻を扱うために datetime モジュールをインポート

now = datetime.datetime.now()  # ✅ 現在の日時を取得
formatted_time = now.strftime(""%Y/%m/%d %H:%M:%S"")  # ✅ 指定した形式に変換
print(formatted_time)  # ✅ YYYY/MM/DD HH:MM:SS 形式で出力

✅ datetime.datetime.now() で現在の日時を取得！
✅ strftime(""%Y/%m/%d %H:%M:%S"") で YYYY/MM/DD HH:MM:SS の形式に整形！

🔹 出力例（実行する時の日時によって変わる！）
2025/02/05 14:45:30

📌 strftime() のフォーマット指定一覧
フォーマット	意味	          出力例
%Y	     西暦（4桁）	          2025
%m	     月（2桁）	          02
%d	     日（2桁）	          05
%H	     時（24時間制）        14
%M	     分（2桁）	          45
%S	     秒（2桁）	          30
%Y-%m-%d   YYYY-MM-DD 形式      2025-02-05
%Y/%m/%d   YYYY/MM/DD 形式      2025/02/05
%H:%M:%S	HH:MM:SS 形式	14:45:30

📌 strftime() の活用例
import datetime
now = datetime.datetime.now()

# ✅ いろんなフォーマットに変換
print(now.strftime(""%Y-%m-%d""))  # 例: 2025-02-05
print(now.strftime(""%Y/%m/%d %H:%M:%S""))  # 例: 2025/02/05 14:45:30
print(now.strftime(""%A, %B %d, %Y""))  # 例: Wednesday, February 05, 2025

✅ 実行すると、日時のフォーマットを自由に変更できる！

",8,1,
212,"以下のコードを実行すると、出力されるのは？

import os
print(os.getcwd())

1️⃣ 現在の作業ディレクトリ（カレントディレクトリ）のパスが表示される
2️⃣ ""C:\\""（Windows）または ""/""（Linux, macOS）が表示される
3️⃣ ""current directory"" という文字列が表示される
4️⃣ エラーが発生する","1️⃣ 現在の作業ディレクトリ（カレントディレクトリ）のパスが表示される","🔹 os モジュールとは？
Pythonの os モジュールは、ファイルやディレクトリの操作、システム情報の取得 などに使われる標準ライブラリ！

🔹 os.getcwd() とは？
現在の作業ディレクトリ（カレントディレクトリ）を取得する関数！
getcwd は ""get current working directory""（現在の作業ディレクトリを取得） の略！

✅ 現在の作業ディレクトリ（カレントディレクトリ）のパスが表示される！

🔹 出力例（環境によって異なる！） ✅ Windows の場合
C:\Users\Username\Projects

✅ Mac / Linux の場合
/home/username/projects

📌 os モジュールの便利な関数
✔ os.getcwd() → 現在の作業ディレクトリを取得
✔ os.listdir() → ディレクトリ内のファイルやフォルダの一覧を取得
✔ os.chdir(""path"") → 作業ディレクトリを変更

📌 他の os 関数の例
import os
print(os.getcwd())  # ✅ 現在の作業ディレクトリを取得
os.chdir("".."")  # ✅ 1つ上のディレクトリへ移動
print(os.getcwd())  # ✅ 移動後のディレクトリを取得
print(os.listdir())  # ✅ 現在のディレクトリ内のファイル一覧を取得

✅ 出力例
C:\Users\Username\Projects
C:\Users\Username
['project1', 'project2', 'document.txt']

✅ ディレクトリを変更したり、ファイル一覧を取得できる！",8,2,
213,"以下のコードを実行すると、出力されるのは？

import os
os.makedirs(""test_dir/sub_dir"", exist_ok=True)
print(os.path.exists(""test_dir/sub_dir""))

1️⃣ True が表示される
2️⃣ False が表示される
3️⃣ ""test_dir/sub_dir"" という文字列が表示される
4️⃣ エラーが発生する","1️⃣ True が表示される","🔹 os.makedirs(path, exist_ok=True) とは？
指定したディレクトリ（フォルダ）を再帰的に作成する関数！
親ディレクトリが存在しない場合も、自動で作成してくれる！
exist_ok=True を指定すると、すでにディレクトリが存在していてもエラーにならない！

🔹 コードの流れ
import os  # ✅ OS関連の機能を使うために os モジュールをインポート
os.makedirs(""test_dir/sub_dir"", exist_ok=True)  # ✅ test_dir/sub_dir を作成（存在してもOK）
print(os.path.exists(""test_dir/sub_dir""))  # ✅ ディレクトリが存在するか確認

✅ os.makedirs(""test_dir/sub_dir"", exist_ok=True) で test_dir/sub_dir を作成！
✅ os.path.exists(""test_dir/sub_dir"") で、ディレクトリが存在するか確認！
✅ ディレクトリが作成されたので True を返す！

📌 os モジュールのディレクトリ操作
✔ os.makedirs(path, exist_ok=True) → ディレクトリを作成（親フォルダも自動作成）
✔ os.path.exists(path) → 指定したパスが存在するかチェック
✔ os.rmdir(path) → 空のディレクトリを削除
✔ os.remove(path) → ファイルを削除

📌 他の os 関数の例
import os
# ✅ ディレクトリを作成
os.makedirs(""example_dir"", exist_ok=True)

# ✅ ディレクトリの存在を確認
print(os.path.exists(""example_dir""))  # True

# ✅ ディレクトリを削除
os.rmdir(""example_dir"")

# ✅ 削除後の確認
print(os.path.exists(""example_dir""))  # False

✅ os.makedirs() で作成、os.rmdir() で削除ができる！

",8,2,
214,"以下のコードを実行すると、出力されるのは？

import sys
print(sys.version)

1️⃣ Python のバージョン情報が表示される
2️⃣ ""Python 3.10"" と固定の文字列が表示される
3️⃣ ""sys"" という文字列が表示される
4️⃣ エラーが発生する","1️⃣ Python のバージョン情報が表示される","🔹 sys.version とは？
Python の sys モジュールは、Python の実行環境やシステムに関する情報を取得するためのモジュール！
その中の sys.version は、現在使用している Python のバージョン情報を取得するための属性！

🔹 コードの流れ
import sys  # ✅ システム関連の情報を取得するために sys モジュールをインポート
print(sys.version)  # ✅ Python のバージョン情報を表示

✅ sys.version を使うと、現在実行中の Python のバージョン情報を取得できる！

🔹 出力例（環境によって変わる！）
3.11.2 (main, Feb  5 2025, 14:30:00) [GCC 9.3.0]

📌 sys モジュールのポイント
✔ sys.version → Python のバージョン情報を取得
✔ sys.platform → 実行中の OS を取得
✔ sys.argv → コマンドライン引数を取得
✔ sys.exit() → プログラムを強制終了

📌 他の sys 関数の例
import sys
print(""Python バージョン:"", sys.version)
print(""OS:"", sys.platform)  # ✅ 実行中の OS を取得
print(""コマンドライン引数:"", sys.argv)  # ✅ 実行時の引数を取得

✅ 出力例（環境によって変わる）
Python バージョン: 3.11.2 (main, Feb  5 2025, 14:30:00) [GCC 9.3.0]
OS: win32  # Windows の場合
コマンドライン引数: ['script.py']

✅ Python の環境情報を取得するのに便利！

",8,2,
215,"以下のコードを実行すると、出力されるのは？

import time
time.sleep(2)
print(""Hello, Python!"")

1️⃣ ""Hello, Python!"" が 2 秒後に表示される
2️⃣ ""Hello, Python!"" がすぐに表示される
3️⃣ エラーが発生する
4️⃣ ""Hello, Python!"" が 5 秒後に表示される","1️⃣ ""Hello, Python!"" が 2 秒後に表示される","🔹 time.sleep(seconds) とは？
Python の time.sleep(n) は、プログラムの実行を n 秒間一時停止する関数！

🔹 コードの流れ
import time  # ✅ 時間関連の操作をするために time モジュールをインポート

time.sleep(2)  # ✅ 2 秒間プログラムを一時停止
print(""Hello, Python!"")  # ✅ 2 秒後に出力

✅ time.sleep(2) によって、プログラムが 2 秒間停止！
✅ その後 ""Hello, Python!"" が表示される！

📌 time モジュールのポイント
✔ time.sleep(n) → n 秒間プログラムを停止
✔ time.time() → 現在の時刻（1970年1月1日からの経過秒数）を取得
✔ time.ctime() → 現在の日時を文字列で取得

📌 他の time 関数の例
import time

print(""現在の時刻（エポック秒）:"", time.time())  # ✅ 1970年1月1日からの経過秒数
print(""現在の時刻（文字列）:"", time.ctime())  # ✅ 現在の日時を文字列で取得

print(""3 秒待ちます..."")
time.sleep(3)  # ✅ 3秒間停止
print(""時間経過！"")
✅ 出力例

現在の時刻（エポック秒）: 1707093667.123456
現在の時刻（文字列）: Wed Feb 5 15:21:07 2025
3 秒待ちます...
（3秒後）
時間経過！

✅ time.sleep(n) を使うと、処理のタイミングを調整できる！

",8,2,
216,"以下のコードを実行すると、出力されるのは？

import math
print(math.factorial(5))

1️⃣ 120
2️⃣ 5
3️⃣ 25
4️⃣ エラーが発生する","1️⃣ 120","🔹 math.factorial(n) とは？
Python の math.factorial(n) は、n の階乗（n!）を計算する関数！
階乗とは、1 から n までの整数をすべて掛け合わせた値！

🔹 コードの流れ
import math  # ✅ 数学系の計算を扱う math モジュールをインポート

print(math.factorial(5))  # ✅ 5!（5の階乗）を計算

✅ math.factorial(5) は 5! = 5 × 4 × 3 × 2 × 1 = 120 を計算！

🔹 出力
120

📌 math.factorial() のポイント
✔ math.factorial(n) → n!（n の階乗）を計算
✔ n は非負の整数でなければならない！（負の数はエラー）
✔ 階乗の計算は、組み合わせ計算や確率計算でよく使われる！

📌 math.factorial() の実用例
import math

print(math.factorial(3))  # ✅ 3! = 3 × 2 × 1 = 6
print(math.factorial(7))  # ✅ 7! = 7 × 6 × 5 × 4 × 3 × 2 × 1 = 5040
print(math.factorial(0))  # ✅ 0! は 1 と定義されているので 1

✅ 出力
6
5040
1

✅ math.factorial(0) = 1 は数学的に定義されている！

",8,2,
217,"以下のコードを実行すると、出力されるのは？

import collections
counter = collections.Counter([""apple"", ""banana"", ""apple"", ""orange"", ""banana"", ""apple""])
print(counter[""apple""])

1️⃣ 3
2️⃣ 2
3️⃣ 1
4️⃣ エラーが発生する","1️⃣ 3","🔹 collections.Counter とは？
Python の collections.Counter は、リストやタプルの要素の出現回数を数えるのに便利なクラス！
単語の頻度解析や、データの集計によく使われる！

🔹 コードの流れ
import collections  # ✅ collections モジュールをインポート

# ✅ リスト内の各要素の出現回数をカウント
counter = collections.Counter([""apple"", ""banana"", ""apple"", ""orange"", ""banana"", ""apple""])

print(counter[""apple""])  # ✅ ""apple"" の出現回数を取得

✅ リスト内の各要素の出現回数をカウントして、辞書のようにアクセスできる！

🔹 出力
3

✅ 正解は 1️⃣ 3 🎯

📌 collections.Counter のポイント
✔ collections.Counter(iterable) → 要素の出現回数をカウントして、辞書のように扱える！
✔ counter[""要素""] → 特定の要素の出現回数を取得！
✔ counter.most_common(n) → 出現回数が多い順に n 個の要素を取得！

📌 Counter の活用例
import collections

fruits = [""apple"", ""banana"", ""apple"", ""orange"", ""banana"", ""apple"", ""grape""]
counter = collections.Counter(fruits)

print(counter)  # ✅ 各フルーツの出現回数を表示
print(counter[""banana""])  # ✅ ""banana"" の出現回数
print(counter.most_common(2))  # ✅ 最も多い2つの要素を取得

✅ 出力
Counter({'apple': 3, 'banana': 2, 'orange': 1, 'grape': 1})
2
[('apple', 3), ('banana', 2)]

✅ データの頻度解析にとても便利！

",8,3,
218,"以下のコードを実行すると、出力されるのは？

import numpy as np
arr = np.array([[1, 2, 3], [4, 5, 6]])
print(arr.shape)

1️⃣ (2, 3)
2️⃣ (3, 2)
3️⃣ エラーが発生する
4️⃣ (6,)","1️⃣ (2, 3)","🔹 arr.shape とは？
shape は NumPy 配列の「形状（行と列の数）」を取得する属性！
(行数, 列数) の形式でタプルとして返される！

🔹 コードの流れ
import numpy as np  # ✅ numpy を np という短縮名でインポート
arr = np.array([[1, 2, 3], [4, 5, 6]])  # ✅ 2次元配列（2行3列）を作成
print(arr.shape)  # ✅ 配列の形状（行数, 列数）を取得

✅ 配列 arr は 2 行 3 列 の形状！
✅ arr.shape は (2, 3) を返す！

🔹 出力
(2, 3)

📌 shape のポイント
✔ shape は (行数, 列数) を返す！
✔ 1次元配列（ベクトル）は (要素数,) の形になる！
✔ 配列の形を変更するには reshape() を使う！

📌 配列の形状を確認する例
import numpy as np

# ✅ 1次元配列（ベクトル）
arr1 = np.array([1, 2, 3, 4, 5, 6])
print(arr1.shape)  # (6,)

# ✅ 2次元配列（行列）
arr2 = np.array([[1, 2, 3], [4, 5, 6]])
print(arr2.shape)  # (2, 3)

# ✅ 形を変更
arr3 = arr1.reshape(2, 3)  # (6,) → (2, 3) に変更
print(arr3.shape)  # (2, 3)

✅ 出力
(6,)
(2, 3)
(2, 3)

✅ reshape() を使うと、データの形を変えることができる！

",9,1,
219,"以下のコードを実行すると、出力されるのは？

import numpy as np
arr = np.array([10, 20, 30, 40, 50])
print(arr[1:4])

1️⃣ [10, 20, 30]
2️⃣ [20, 30, 40]
3️⃣ [20, 30, 40, 50]
4️⃣ エラーが発生する","2️⃣ [20, 30, 40]","🔹 NumPy 配列のスライス（arr[start:end]）とは？
NumPy の配列は、Python のリストと同じようにスライス（部分的に取り出すこと）ができる！
arr[start:end] の形式で start から end-1 までの要素を取得！
end のインデックスは含まれない！（Python のスライスの特徴）

✅ インデックス（0 からスタート）
 10  20  30  40  50
  ↑   ↑   ↑   ↑   ↑
  0   1   2   3   4
✅ arr[1:4] は 1 から 3 までの要素を取得（4 は含まれない！） → 出力は [20, 30, 40]

🔹 出力
[20 30 40]

📌 NumPy のスライスのポイント
✔ arr[start:end] → start から end-1 までの要素を取得（end は含まれない！）
✔ arr[start:] → start から 最後まで の要素を取得
✔ arr[:end] → 最初から end-1 までの要素を取得
✔ arr[::step] → step 間隔で要素を取得（スキップ）

📌 スライスの例
import numpy as np
arr = np.array([10, 20, 30, 40, 50])

print(arr[1:4])   # ✅ インデックス1から3まで（[20, 30, 40]）
print(arr[:3])    # ✅ 最初からインデックス2まで（[10, 20, 30]）
print(arr[2:])    # ✅ インデックス2から最後まで（[30, 40, 50]）
print(arr[::2])   # ✅ 2ステップごとに取得（[10, 30, 50]）

✅ 出力
[20 30 40]
[10 20 30]
[30 40 50]
[10 30 50]

✅ スライスを使うと、配列の一部を簡単に取り出せる！

",9,1,
220,"以下のコードを実行すると、出力されるのは？

import numpy as np
arr = np.array([[1, 2, 3], [4, 5, 6]])
print(arr[1, 2])

1️⃣ 2
2️⃣ 3
3️⃣ 5
4️⃣ 6","4️⃣ 6","🔹 NumPy 配列のインデックス指定（arr[row, col]）とは？
NumPy の 2次元配列では、arr[row, col] の形式で要素を取得できる！
row（行番号）は 0からカウント
col（列番号）も 0からカウント

✅ 配列の構造
       0列  1列  2列
0行   [ 1    2    3 ]
1行   [ 4    5    6 ]
✅ arr[1, 2] は、「1行2列」の値 → 6！

🔹 出力
6

📌 NumPy のインデックス指定のポイント
✔ arr[row, col] → (行番号, 列番号) で要素を取得
✔ arr[行, :] → その行のすべての要素を取得
✔ arr[:, 列] → その列のすべての要素を取得

📌 インデックス指定の例
import numpy as np
arr = np.array([[1, 2, 3], [4, 5, 6]])

print(arr[0, 1])  # ✅ 0行1列の値（2）
print(arr[1, :])  # ✅ 1行目のすべての値（[4, 5, 6]）
print(arr[:, 2])  # ✅ 2列目のすべての値（[3, 6]）

✅ 出力
2
[4 5 6]
[3 6]

✅ 行と列を指定すれば、必要なデータだけ取り出せる！

",9,1,
221,"以下のコードを実行すると、出力されるのは？

import numpy as np
arr = np.array([1, 2, 3, 4, 5])
arr = arr * 2
print(arr)

1️⃣ [1 2 3 4 5]
2️⃣ [2 4 6 8 10]
3️⃣ [1 4 9 16 25]
4️⃣ エラーが発生する","2️⃣ [2 4 6 8 10]","🔹 NumPy 配列の要素ごとの演算とは？
NumPy の配列は、要素ごとに演算を適用できる！（ブロードキャスト）
Python のリストとは異なり、arr * 2 と書くと、すべての要素が 2 倍される！

📌 NumPy のブロードキャスト
✔ arr * 2 → すべての要素が 2 倍！
✔ arr + 3 → すべての要素に 3 を加算！
✔ arr ** 2 → すべての要素を2乗！

📌 要素ごとの演算の例
import numpy as np
arr = np.array([1, 2, 3, 4, 5])

print(arr + 10)  # ✅ 各要素に10を加算
print(arr * 3)   # ✅ 各要素を3倍
print(arr ** 2)  # ✅ 各要素を2乗

✅ 出力
[11 12 13 14 15]
[ 3  6  9 12 15]
[ 1  4  9 16 25]

✅ NumPy なら、ループを書かなくても一括で演算ができる！

",9,1,
222,"以下のコードを実行すると、出力されるのは？

import numpy as np
arr1 = np.array([1, 2, 3])
arr2 = np.array([4, 5, 6])
result = arr1 + arr2
print(result)

1️⃣ [4, 5, 6]
2️⃣ [1, 2, 3, 4, 5, 6]
3️⃣ [5, 7, 9]
4️⃣ エラーが発生する","3️⃣ [5, 7, 9]","🔹 NumPy の配列同士の演算とは？
NumPy の配列は、要素ごとに演算を適用できる！（ブロードキャスト）
arr1 + arr2 のように書くと、対応する要素同士が足し算される！

📌 他の演算の例
import numpy as np
arr1 = np.array([1, 2, 3])
arr2 = np.array([4, 5, 6])

print(arr1 - arr2)  # ✅ 各要素を引き算
print(arr1 * arr2)  # ✅ 各要素を掛け算
print(arr1 / arr2)  # ✅ 各要素を割り算

✅ 出力
[-3 -3 -3]
[ 4 10 18]
[0.25 0.4  0.5 ]

✅ NumPy の配列同士なら、ループを書かずに計算できる！
",9,2,
223,"以下のコードを実行すると、出力されるのは？

import numpy as np
arr = np.array([1, 2, 3, 4, 5, 6])
result = arr.reshape(2, 3)
print(result)

1️⃣ [[1, 2], [3, 4], [5, 6]]
2️⃣ [[1, 2, 3], [4, 5, 6]]
3️⃣ エラーが発生する
4️⃣ [1, 2, 3, 4, 5, 6]（変化なし）","2️⃣ [[1, 2, 3], [4, 5, 6]]","🔹 reshape(m, n) とは？
NumPy の reshape(m, n) は、配列の形を変更するメソッド！
1次元配列 → 2次元配列に変換したり、行列の形を変更するときに使う！
要素の数（全体のサイズ）は変えられない！

✅ 元の配列（1次元）
[1 2 3 4 5 6]
✅ reshape(2,3) で 2行3列の行列に変換！
[[1 2 3]
 [4 5 6]]

📌 NumPy の reshape() のポイント
✔ reshape(m, n) → (m, n) の形に変換！
✔ 要素の合計数（m × n）は元の配列と一致している必要がある！
✔ 自動で形を調整する場合は -1 を使う！

📌 reshape() の活用例
import numpy as np
arr = np.array([1, 2, 3, 4, 5, 6])

print(arr.reshape(3, 2))  # ✅ 3行2列に変換
print(arr.reshape(2, -1))  # ✅ 自動で列数を調整（2行）
print(arr.reshape(-1, 3))  # ✅ 自動で行数を調整（3列）
✅ 出力
[[1 2]
 [3 4]
 [5 6]]

[[1 2 3]
 [4 5 6]]

[[1 2 3]
 [4 5 6]]

✅ -1 を使うと、NumPy が自動でサイズを調整してくれる！

",9,2,
224,"以下のコードを実行すると、出力されるのは？

import numpy as np
arr = np.array([10, 20, 30, 40, 50])
mask = arr > 25
print(arr[mask])

1️⃣ [10, 20]
2️⃣ [30, 40, 50]
3️⃣ [True, True, True, False, False]
4️⃣ エラーが発生する","2️⃣ [30, 40, 50]","🔹 NumPy のブールインデックス（条件に一致する要素を抽出）とは？
mask = arr > 25 のように条件を指定すると、条件に一致する要素が True、一致しない要素が False の配列が作成される！
arr[mask] を使うと、True の部分に対応する要素だけを取得できる！

🔹 コードの流れ
import numpy as np  # ✅ NumPy をインポート
arr = np.array([10, 20, 30, 40, 50])  # ✅ 1次元配列を作成
mask = arr > 25  # ✅ 各要素が 25 より大きいかを判定（ブール配列）
print(arr[mask])  # ✅ `True` の要素だけを取得

✅ mask の内容
[False False  True  True  True]

✅ arr[mask] の結果（True の要素のみ抽出！）
[30 40 50]

🔹 出力
[30 40 50]

📌 NumPy のブールインデックスのポイント
✔ mask = 条件式 → True/False のブール配列を作成
✔ arr[mask] → True に対応する要素だけを抽出
✔ データのフィルタリングや条件検索に便利！

📌 他の条件の例
import numpy as np
arr = np.array([10, 20, 30, 40, 50])

print(arr[arr >= 30])  # ✅ 30以上の要素を取得
print(arr[arr % 20 == 0])  # ✅ 20の倍数の要素を取得
print(arr[(arr > 10) & (arr < 50)])  # ✅ 10より大きく50より小さい要素を取得

✅ 出力
[30 40 50]
[20 40]
[20 30 40]

✅ 複数の条件も & や | で組み合わせて使える！

",9,3,
225,"以下のコードを実行すると、出力されるのは？

import numpy as np
arr = np.array([[1, 2, 3], [4, 5, 6]])
result = np.sum(arr, axis=0)
print(result)

1️⃣ [5, 7, 9]
2️⃣ [6, 15]
3️⃣ 21
4️⃣ エラーが発生する","1️⃣ [5, 7, 9]","🔹 NumPy の np.sum(arr, axis=0) とは？
np.sum(arr, axis=0) は、「列ごとに合計を計算する」 という意味！
axis=0 → 縦（列）方向に合計（行ごとに足し算）
axis=1 → 横（行）方向に合計（列ごとに足し算）

✅ 配列の構造
  1  2  3
  4  5  6
✅ axis=0（縦方向の合計）
1+4 = 5
2+5 = 7
3+6 = 9

✅ 出力
[5 7 9]

📌 NumPy の sum() の使い方
✔ np.sum(arr, axis=0) → 縦方向（列ごと）に合計
✔ np.sum(arr, axis=1) → 横方向（行ごと）に合計
✔ np.sum(arr) → 配列全体の合計

📌 他の例
import numpy as np

arr = np.array([[1, 2, 3], [4, 5, 6]])

print(np.sum(arr, axis=0))  # ✅ 列ごとの合計（[5, 7, 9]）
print(np.sum(arr, axis=1))  # ✅ 行ごとの合計（[6, 15]）
print(np.sum(arr))  # ✅ 配列全体の合計（21）

✅ 出力
[5 7 9]
[6 15]
21

✅ axis=0 で列ごとの合計、axis=1 で行ごとの合計、指定なしで全体の合計！


",9,3,
226,"以下のコードを実行すると、出力されるのは？
```
class Car:
    def __init__(self, brand, color):
        self.brand = brand
        self.color = color

car1 = Car(""Toyota"", ""red"")
print(car1.brand)
```
1️⃣ ""Toyota""
2️⃣ ""red""
3️⃣ エラーが発生する
4️⃣ None","1️⃣ ""Toyota""","🔹 クラスの __init__() メソッドとは？
__init__() は、オブジェクトが作られる時に自動的に実行されるコンストラクタ
self.brand = brand のように書くことで、オブジェクトごとに異なるデータを持たせることができる！

🔹 コードの流れ
```
class Car:
    def __init__(self, brand, color):  # ✅ 初期化メソッド（コンストラクタ）
        self.brand = brand  # ✅ 車のブランドを設定
        self.color = color  # ✅ 車の色を設定

car1 = Car(""Toyota"", ""red"")  # ✅ Toyotaブランドの赤い車を作成
print(car1.brand)  # ✅ brand（ブランド名）を出力
```
✅ Car(""Toyota"", ""red"") で brand=""Toyota"", color=""red"" のオブジェクトが作成される！
✅ car1.brand を出力すると ""Toyota"" になる！

🔹 出力
Toyota

📌 クラスと self のポイント
✔ __init__() はオブジェクトが作られるときに実行される！
✔ self.brand = brand でオブジェクトごとのデータを保存できる！
✔ car1.brand のようにオブジェクトのデータを取得できる！

📌 複数のオブジェクトを作ると？
car1 = Car(""Toyota"", ""red"")
car2 = Car(""Honda"", ""blue"")

print(car1.brand, car1.color)  # ✅ Toyota red
print(car2.brand, car2.color)  # ✅ Honda blue

✅ 出力
Toyota red
Honda blue

✅ オブジェクトごとに異なるデータを持てる！",4,1,
227,"以下のコードを実行すると、出力されるのは？
```pyhon
class Person:
    def __init__(self, name, age):
        self.name = name
        self.age = age

    def greet(self):
        return f""こんにちは、私は {self.name} です。""

p = Person(""太郎"", 25)
print(p.greet())
```pyhon
1️⃣ ""こんにちは、私は 太郎 です。""
2️⃣ ""こんにちは、私は 25 です。""
3️⃣ エラーが発生する
4️⃣ None","1️⃣ ""こんにちは、私は 太郎 です。""","🔹 クラス内のメソッド（def greet(self):）とは？
クラスのメソッドは、オブジェクトごとに異なる動作を定義できる！
self を使うことで、オブジェクトのデータ（self.name など）を参照できる！

🔹 コードの流れ
```pyhon
class Person:
    def __init__(self, name, age):  # ✅ コンストラクタ（初期化メソッド）
        self.name = name  # ✅ 名前をセット
        self.age = age  # ✅ 年齢をセット

    def greet(self):  # ✅ インスタンスメソッド（挨拶を返す）
        return f""こんにちは、私は {self.name} です。""  # ✅ オブジェクトの `name` を参照

p = Person(""太郎"", 25)  # ✅ 「太郎, 25歳」のオブジェクトを作成
print(p.greet())  # ✅ greet() メソッドを実行
```pyhon
✅ greet() メソッドでは self.name を使って p.name を取得！
✅ p.greet() の戻り値は ""こんにちは、私は 太郎 です。"" になる！

🔹 出力
こんにちは、私は 太郎 です。

📌 クラスのメソッドのポイント
✔ def メソッド名(self): でメソッドを定義！
✔ メソッド内で self.変数名 を使うと、オブジェクトのデータを参照できる！
✔ self をつけると、異なるオブジェクトでも正しく動作する！

📌 複数のオブジェクトを作ると？
p1 = Person(""花子"", 30)
p2 = Person(""次郎"", 22)

print(p1.greet())  # ✅ こんにちは、私は 花子 です。
print(p2.greet())  # ✅ こんにちは、私は 次郎 です。
✅ 出力
こんにちは、私は 花子 です。
こんにちは、私は 次郎 です。

✅ オブジェクトごとに異なる self.name が使われる！",4,1,
228,"以下のコードを実行すると、出力されるのは？
```
class Counter:
    count = 0  

    def __init__(self):
        Counter.count += 1 

    def get_count(self):
        return Counter.count

c1 = Counter()
c2 = Counter()
c3 = Counter()
print(c3.get_count())
```
1️⃣ 1
2️⃣ 3
3️⃣ エラーが発生する
4️⃣ None","2️⃣ 3","🔹 クラス変数（Counter.count）とは？
クラス変数は、クラス全体で共有される変数！
Counter.count のように クラス名.変数名 でアクセスする！
self.count のように書くと、インスタンスごとの変数になってしまうので注意！

🔹 コードの流れ
```
class Counter:
    count = 0  # ✅ クラス変数（全インスタンスで共有）

    def __init__(self):
        Counter.count += 1  # ✅ インスタンスが作られるたびに count を +1

    def get_count(self):
        return Counter.count  # ✅ クラス変数を取得

c1 = Counter()  # ✅ インスタンスを作成 → count = 1
c2 = Counter()  # ✅ インスタンスを作成 → count = 2
c3 = Counter()  # ✅ インスタンスを作成 → count = 3
print(c3.get_count())  # ✅ count の現在の値を取得
```
✅ クラス変数 Counter.count はすべてのインスタンスで共通！
✅ c1, c2, c3 の作成ごとに count が増える！

🔹 出力
3

📌 クラス変数のポイント
✔ クラス全体で共有するデータはクラス変数を使う！
✔ self.count を使うと、インスタンスごとの変数になり、カウントが増えなくなる！
✔ クラス変数には クラス名.変数名 でアクセスする！

📌 クラス変数とインスタンス変数の違い
```
class Example:
    class_var = ""クラス変数""  # ✅ すべてのインスタンスで共有

    def __init__(self, value):
        self.instance_var = value  # ✅ インスタンスごとに異なる値を保持

e1 = Example(""インスタンス1"")
e2 = Example(""インスタンス2"")

print(e1.class_var, e1.instance_var)  # ✅ クラス変数: ""クラス変数"", インスタンス変数: ""インスタンス1""
print(e2.class_var, e2.instance_var)  # ✅ クラス変数: ""クラス変数"", インスタンス変数: ""インスタンス2""
```
✅ 出力
クラス変数 インスタンス1
クラス変数 インスタンス2

✅ クラス変数は共通、インスタンス変数は個別！",4,2,
229,"以下のコードを実行すると、出力されるのは？
```
class Animal:
    def __init__(self, name):
        self.name = name

    def speak(self):
        return ""何か音を出します""

class Dog(Animal):
    def speak(self):
        return ""ワンワン""

d = Dog(""ポチ"")
print(d.speak())
```
1️⃣ ""何か音を出します""
2️⃣ ""ワンワン""
3️⃣ ""ポチ""
4️⃣ エラーが発生する","2️⃣ ""ワンワン""","🔹 クラスの継承とは？
クラスの継承（class 子クラス(親クラス):）を使うと、親クラスの機能を引き継いで新しいクラスを作れる！
Dog(Animal) のように書くと、Animal クラスを継承して Dog クラスを作成できる！

🔹 コードの流れ
```
class Animal:  # ✅ 親クラス
    def __init__(self, name):
        self.name = name

    def speak(self):  # ✅ 共通のメソッド（継承される）
        return ""何か音を出します""

class Dog(Animal):  # ✅ 子クラス（Animal を継承）
    def speak(self):  # ✅ 親クラスのメソッドをオーバーライド
        return ""ワンワン""

d = Dog(""ポチ"")  # ✅ Dog クラスのインスタンスを作成
print(d.speak())  # ✅ `speak()` を実行
```
✅ 親クラス Animal の speak() は ""何か音を出します"" を返す！
✅ Dog クラスで speak() を上書き（オーバーライド）したので ""ワンワン"" が返る！

🔹 出力
ワンワン

📌 クラスの継承のポイント
✔ class 子クラス(親クラス): で継承を作成！
✔ 子クラスは親クラスのメソッドをそのまま使える！
✔ 同じ名前のメソッドを定義すると、親クラスのメソッドを上書き（オーバーライド）できる！

📌 親クラスのメソッドをそのまま使う場合
```
class Animal:
    def __init__(self, name):
        self.name = name

    def speak(self):
        return ""何か音を出します""

class Dog(Animal):
    def speak(self):
        return super().speak() + "" でも犬はワンワンと鳴く""

d = Dog(""ポチ"")
print(d.speak())
```
✅ 出力
何か音を出します でも犬はワンワンと鳴く

✅ super().speak() を使うと、親クラスの speak() を呼び出せる！",4,2,
230,"以下のコードを実行すると、出力されるのは？
```
class Parent:
    def __init__(self):
        print(""Parent のコンストラクタ"")

class Child(Parent):
    def __init__(self):
        print(""Child のコンストラクタ"")

c = Child()
```
1️⃣ ""Parent のコンストラクタ""
2️⃣ ""Child のコンストラクタ""
3️⃣ ""Parent のコンストラクタ"" と ""Child のコンストラクタ"" の両方
4️⃣ エラーが発生する","2️⃣ ""Child のコンストラクタ""","🔹 子クラスが __init__() を持っている場合、親クラスの __init__() は自動的に呼ばれない！
クラスの継承では、親クラスの __init__() が自動で実行されるわけではない！
子クラスで __init__() を定義すると、親クラスの __init__() は無視される！

🔹 コードの流れ
```
class Parent:
    def __init__(self):
        print(""Parent のコンストラクタ"")  # ✅ 親クラスの `__init__()`

class Child(Parent):
    def __init__(self):
        print(""Child のコンストラクタ"")  # ✅ 子クラスの `__init__()`

c = Child()  # ✅ 子クラスのインスタンスを作成
```
✅ Child クラスには __init__() があるので、Parent.__init__() は実行されない！

🔹 出力
Child のコンストラクタ

📌 親クラスの __init__() も実行したい場合
✅ super().__init__() を使うと、親クラスの __init__() も呼び出せる！

📌 親クラスの __init__() も実行するコード
```
class Parent:
    def __init__(self):
        print(""Parent のコンストラクタ"")

class Child(Parent):
    def __init__(self):
        super().__init__()  # ✅ 親クラスのコンストラクタを明示的に呼ぶ
        print(""Child のコンストラクタ"")

c = Child()
```
✅ 出力
Parent のコンストラクタ
Child のコンストラクタ

✅ super().__init__() を使えば、親クラスの __init__() も実行できる！",4,2,
231,"以下のコードを実行すると、出力されるのは？
```
class Example:
    class_var = ""クラス変数""

    def __init__(self, value):
        self.instance_var = value

    def show_vars(self):
        return f""{self.class_var}, {self.instance_var}""

e1 = Example(""インスタンス1"")
e2 = Example(""インスタンス2"")
e1.class_var = ""変更されたクラス変数""

print(e2.show_vars())
```
1️⃣ ""変更されたクラス変数, インスタンス2""
2️⃣ ""クラス変数, インスタンス2""
3️⃣ ""変更されたクラス変数, インスタンス1""
4️⃣ エラーが発生する","2️⃣ ""クラス変数, インスタンス2""","🔹 クラス変数 (class_var) と インスタンス変数 (self.instance_var) の違いとは？
クラス変数 は クラス全体で共有 される変数！
インスタンス変数 は オブジェクトごとに異なる値を持つ！
self.class_var とすると、クラス変数のコピーがインスタンスごとに作られる！

🔹 コードの流れ
```
class Example:
    class_var = ""クラス変数""  # ✅ クラス変数（すべてのインスタンスで共有）

    def __init__(self, value):
        self.instance_var = value  # ✅ インスタンス変数（オブジェクトごとに異なる）

    def show_vars(self):
        return f""{self.class_var}, {self.instance_var}""  # ✅ クラス変数 & インスタンス変数を表示

e1 = Example(""インスタンス1"")  # ✅ `e1` を作成
e2 = Example(""インスタンス2"")  # ✅ `e2` を作成
e1.class_var = ""変更されたクラス変数""  # ✅ `e1` のクラス変数を書き換え

print(e2.show_vars())  # ✅ `e2` のデータを表示
```
✅ ポイント
Example.class_var = ""クラス変数"" はクラス変数（全インスタンス共通）
e1.class_var = ""変更されたクラス変数"" は e1 専用の class_var を作成しただけ！
e2.show_vars() の self.class_var は変更されていないので ""クラス変数"" のまま！

🔹 出力
クラス変数, インスタンス2

📌 クラス変数とインスタンス変数のポイント
✔ クラス変数は クラス名.変数名 でアクセス！
✔ インスタンス変数は self.変数名 でオブジェクトごとに異なる値を保持！
✔ self.class_var を変更すると、そのインスタンスだけの新しい変数が作られる！（クラス変数には影響しない！）

📌 クラス変数をすべてのインスタンスで変更する方法
Example.class_var = ""全インスタンス変更""

✅ これをすると、すべてのインスタンスで class_var が変わる！",4,2,
232,"以下のコードを実行すると、出力されるのは？
```
class Example:
    @staticmethod
    def static_method():
        return ""これは静的メソッドです。""

e = Example()
print(e.static_method())
```
1️⃣ ""これは静的メソッドです。""
2️⃣ エラーが発生する
3️⃣ ""None""
4️⃣ ""これはインスタンスメソッドです。""","1️⃣ ""これは静的メソッドです。""","🔹 @staticmethod（静的メソッド）とは？
静的メソッド（@staticmethod）は、インスタンスやクラスに依存しないメソッド！
self（インスタンス）や cls（クラス）を使わずに、クラスの関数として機能する！

🔹 コードの流れ
```
class Example:
    @staticmethod  # ✅ 静的メソッドを定義
    def static_method():
        return ""これは静的メソッドです。""

e = Example()  # ✅ インスタンスを作成
print(e.static_method())  # ✅ 静的メソッドを呼び出す
```
✅ @staticmethod をつけたメソッドは、インスタンスを通じて呼び出せる！
✅ self や cls を使わないので、オブジェクトの状態に関係なく動作する！

🔹 出力
これは静的メソッドです。

📌 @staticmethod のポイント
✔ インスタンス（self）やクラス（cls）に依存しないメソッド！
✔ Example.static_method() のように、クラスから直接呼び出しも可能！
✔ クラスのデータにアクセスしない関数をクラスの一部としてまとめたいときに使う！

📌 静的メソッドの使い方
```
class MathUtils:
    @staticmethod
    def add(a, b):
        return a + b

print(MathUtils.add(5, 3))  # ✅ クラスから直接呼び出し
```
✅ 出力
8

✅ self を使わないので、計算処理などに適している！",4,3,
233,"以下のコードを実行すると、出力されるのは？
```
class Example:
    class_var = ""クラス変数""

    @classmethod
    def class_method(cls):
        return cls.class_var

e = Example()
print(e.class_method())
```
1️⃣ ""クラス変数""
2️⃣ ""None""
3️⃣ ""エラーが発生する""
4️⃣ ""インスタンス変数""","1️⃣ ""クラス変数""","🔹 @classmethod（クラスメソッド）とは？
クラスメソッドは、クラス全体に関わるメソッド！
インスタンス（self）ではなく、クラス（cls）を受け取る！
クラス変数（class_var）にアクセスできる！

🔹 コードの流れ
```
class Example:
    class_var = ""クラス変数""  # ✅ クラス変数（全インスタンスで共有）

    @classmethod
    def class_method(cls):  # ✅ クラスメソッド（`cls` を受け取る）
        return cls.class_var  # ✅ クラス変数を取得

e = Example()  # ✅ インスタンスを作成
print(e.class_method())  # ✅ クラスメソッドを呼び出す
```
✅ class_method(cls) は、cls.class_var を返すので ""クラス変数"" となる！
✅ クラスメソッドは、インスタンスを通じて呼び出しても動作する！

🔹 出力
クラス変数

📌 @classmethod のポイント
✔ cls を使うことで、クラス変数にアクセスできる！
✔ クラス自体を操作する処理に適している！
✔ インスタンスではなく、クラスそのものに対して影響を与える！

📌 クラスメソッドの活用例
```
class Counter:
    count = 0  # ✅ クラス変数

    @classmethod
    def increment(cls):
        cls.count += 1  # ✅ クラス変数を増やす
        return cls.count

print(Counter.increment())  # ✅ クラスメソッドを直接呼び出し（1）
print(Counter.increment())  # ✅ クラスメソッドを直接呼び出し（2）
```
✅ 出力
1
2

✅ クラス変数を使うので、すべてのインスタンスで値を共有できる！

*********さらに詳しく*****************

📌 クラスメソッドを使う意味
クラスメソッドを使うことで、「クラス変数を扱うメソッド」を安全に定義できる！

例えば、さっきのコードは、クラスメソッドがなくても動く。
けれど、クラス変数を変更する場合に @classmethod を使うと、インスタンスごとに影響されずに扱える！

📌 クラスメソッドの必要性を実感！
例えば、以下のように 「登録されたオブジェクトの数をカウントするクラス」 を作る場合を考えてみよう👇
```python
class Counter:
    count = 0  # クラス変数

    def __init__(self):
        Counter.count += 1  # インスタンスが作られるたびにカウントを増やす

    @classmethod
    def get_count(cls):
        return cls.count  # クラス変数を取得するクラスメソッド

# インスタンスを作成
a = Counter()
b = Counter()
c = Counter()

print(Counter.get_count())  # 3
print(a.get_count())  # 3（インスタンス経由でも呼び出せる）
```
📌 @classmethod のメリット
1️⃣ クラス変数を適切に管理できる！

get_count() を 「インスタンスなしで」 直接 Counter.get_count() として呼び出せる！
もし 通常のメソッド (self) にした場合、インスタンスを作らないと使えない！
2️⃣ インスタンスごとではなく、クラス全体のデータを操作できる！

count は 「すべてのインスタンスに共通」 のデータだから、クラスメソッドで管理するのが適切！

📌 クラスメソッドとインスタンスメソッドの違い
クラスメソッド (@classmethod)	インスタンスメソッド (self)
対象	クラス全体	インスタンス（オブジェクト）
引数	cls を受け取る	self を受け取る
使用目的	クラス変数の管理・操作	インスタンス変数の管理・操作
呼び出し	クラス名.メソッド名() でもOK！	インスタンス.メソッド名()

📌 まとめ
✔ 「クラス変数を扱うメソッド」には @classmethod を使うのが適切！
✔ 「インスタンスを作らずに使いたいメソッド」は @classmethod にする！
✔ 「インスタンスごとのデータを扱う場合」は普通の self を使う！",4,2,
234,"以下のコードを実行すると、出力されるのは？
```
class Example:
    def __private_method(self):
        return ""これは非公開メソッドです。""

    def public_method(self):
        return self.__private_method()

e = Example()
print(e.public_method())
```
1️⃣ ""これは非公開メソッドです。""
2️⃣ ""None""
3️⃣ ""エラーが発生する""
4️⃣ ""これは公開メソッドです。""","1️⃣ ""これは非公開メソッドです。""","🔹 非公開（プライベート）メソッドとは？
メソッド名の先頭に __（アンダースコア2つ）をつけると、クラスの外部からアクセスできない
ただし、クラス内部からは self.__メソッド名() で呼び出せる！

🔹 コードの流れ
```
class Example:
    def __private_method(self):  # ✅ 非公開メソッド（外部から直接呼び出せない）
        return ""これは非公開メソッドです。""

    def public_method(self):  # ✅ 公開メソッド
        return self.__private_method()  # ✅ クラス内部から非公開メソッドを呼び出し

e = Example()
print(e.public_method())  # ✅ `public_method()` を実行
```
✅ __private_method() は外部から e.__private_method() として呼び出せない！
✅ しかし public_method() の中から self.__private_method() を呼び出せるので、正常に動作する！

🔹 出力
これは非公開メソッドです。


📌 __（アンダースコア2つ） を使うと？
✔ 非公開メソッド（__メソッド名）は外部から直接呼び出せない！
✔ クラス内部からは self.__メソッド名() でアクセスできる！
✔ カプセル化（内部実装の隠蔽）に役立つ！

📌 外部から非公開メソッドにアクセスするとエラー！
```
e = Example()
print(e.__private_method())  # ❌ AttributeError: 'Example' object has no attribute '__private_method'
```
✅ __private_method() は外部から直接呼び出せない！

📌 どうしても外部からアクセスしたい場合
print(e._Example__private_method())  # ✅ クラス名を使うとアクセスできる（推奨されない）

✅ これは Python の名前マングリングという仕組みで、直接アクセスを防ぐための仕組み！
✅ ただし、この方法は推奨されないので、通常は public_method() を通じてアクセスすべき！",4,3,
235,"以下のコードを実行すると、出力されるのは？
```
class Example:
    def __init__(self, value):
        self._value = value

    @property
    def value(self):
        return self._value

e = Example(42)
print(e.value)
```
1️⃣ 42
2️⃣ ""エラーが発生する""
3️⃣ ""None""
4️⃣ ""値は 42 です""","1️⃣ 42","🔹 @property とは？
@property を使うと、メソッドを「プロパティ」のようにアクセスできる！
e.value のように、カッコなしで @property のメソッドを呼び出せる！

🔹 コードの流れ
```
class Example:
    def __init__(self, value):
        self._value = value  # ✅ インスタンス変数（`_` をつけて内部変数として扱う）

    @property
    def value(self):  # ✅ `@property` をつけると `e.value` でアクセスできる
        return self._value  # ✅ `_value` を返す

e = Example(42)  # ✅ `value=42` のオブジェクトを作成
print(e.value)  # ✅ `value` プロパティを取得
```
✅ @property をつけたメソッドは e.value() ではなく e.value として呼び出せる！
✅ self._value は value プロパティとして取得できる！

🔹 出力
42

📌 @property のポイント
✔ 通常のメソッドを「プロパティ」として使えるようにする！
✔ カッコなし（e.value）でアクセス可能！
✔ 内部変数を @property で公開することで、安全にデータを管理できる！

📌 @property を使わない場合
```
class Example:
    def __init__(self, value):
        self._value = value

    def get_value(self):
        return self._value

e = Example(42)
print(e.get_value())  # ✅ カッコが必要（メソッドとして扱う）
```
✅ 出力
42

✅ メソッドなので e.get_value() と書く必要がある！

📌 @property を使うと？
```
class Example:
    def __init__(self, value):
        self._value = value

    @property
    def value(self):
        return self._value

e = Example(42)
print(e.value)  # ✅ カッコなしでアクセス可能！
```
✅ 出力
42

✅ カッコなしで e.value としてアクセスできる！",4,3,
236,"以下のコードを実行すると、出力されるのは？

import math
print(math.pi)

1️⃣ 3.141592653589793
2️⃣ math.pi
3️⃣ エラーが発生する
4️⃣ None","1️⃣ 3.141592653589793","🔹 import math とは？
math モジュールは 数学関連の関数や定数を提供する標準ライブラリ！
math.pi は円周率（π）を表す定数で、約 3.141592653589793 の値を持つ！

🔹 コードの流れ
import math  # ✅ `math` モジュールをインポート
print(math.pi)  # ✅ math モジュールの `pi` を表示

✅ math.pi は 3.141592653589793 を返す！

🔹 出力
3.141592653589793

📌 math モジュールのポイント
✔ 数学関連の関数や定数を提供！
✔ math.pi は円周率（π）の値！
✔ math.sqrt(x) で平方根、math.sin(x) で三角関数も計算できる！

📌 math モジュールの便利な関数
import math

print(math.sqrt(16))  # → 4.0  （平方根）
print(math.sin(math.pi / 2))  # → 1.0  （サイン）
print(math.cos(0))  # → 1.0  （コサイン）
print(math.factorial(5))  # → 120  （階乗）

✅ 数学計算を簡単にできるので、math モジュールは覚えておくと便利！

",5,1,
237,"以下のコードを実行すると、出力されるのは？
但し、mymodule.py というファイルは存在しないものとする。

import mymodule

print(mymodule.hello())

1️⃣ ""Hello, World!""
2️⃣ エラーが発生する
3️⃣ ""None""
4️⃣ ""mymodule.hello()""","2️⃣ エラーが発生する","🔹 import mymodule とは？
mymodule は Python の標準モジュールではなく、外部ファイルとして作成する必要がある！
もし mymodule.py というファイルが存在しない場合、ModuleNotFoundError が発生する！

🔹 エラーが発生する理由
import mymodule  # ✅ `mymodule.py` がないとエラー！
print(mymodule.hello())

✅ mymodule.py というファイルが存在しないので、ModuleNotFoundError が発生する！

📌 エラーメッセージの例
ModuleNotFoundError: No module named 'mymodule'

📌 mymodule.py を作成すれば解決！
もし mymodule.py というファイルを作成して、以下のようなコードを書けばエラーは発生しない！

# mymodule.py
def hello():
    return ""Hello, World!""

# main.py
import mymodule
print(mymodule.hello())  # ✅ ""Hello, World!"" が出力される！

✅ このように、自作の .py ファイルを作って import すればモジュールとして使える！

🔹 出力
ModuleNotFoundError: No module named 'mymodule'

📌 import のポイント
✔ Python の標準ライブラリ以外のモジュールは .py ファイルとして作成する必要がある！
✔ モジュールがないと ModuleNotFoundError になる！
✔ 適切なディレクトリに .py ファイルを置いておくと、import して使える！

📌 モジュールを作成すると、関数や変数をまとめて再利用できる！
# utils.py （自作モジュール）
def greet(name):
    return f""こんにちは、{name} さん！""

# main.py
import utils
print(utils.greet(""太郎""))  # ✅ ""こんにちは、太郎 さん！""

✅ これで utils.py にある関数を import して使える！",5,2,
238,"以下のコードを実行すると、出力されるのは？
但し、mymodule.py というファイルは、同フォルダに以下の内容で存在するものとする。

from mymodule import hello
print(hello())

# mymodule.py
def hello():
    return ""Hello, World!""

1️⃣ ""Hello, World!""
2️⃣ エラーが発生する
3️⃣ ""None""
4️⃣ ""hello()""","1️⃣ ""Hello, World!""","🔹 from mymodule import hello とは？
from mymodule import hello を使うと、mymodule.py の hello() 関数だけをインポートできる！
mymodule.hello() と書かずに、hello() だけで関数を使える！

🔹 コードの流れ
# mymodule.py
def hello():
    return ""Hello, World!""

# main.py
from mymodule import hello  # ✅ `mymodule` から `hello()` 関数だけをインポート
print(hello())  # ✅ ""Hello, World!"" を出力

✅ hello() 関数は mymodule.py に定義されているので、正しく動作する！

🔹 出力
Hello, World!

📌 import の種類
・ モジュール全体をインポートする方法
import mymodule  # ✅ `mymodule` 全体をインポート
print(mymodule.hello())  # ✅ ""Hello, World!"" を表示
✅ この場合、mymodule.hello() のようにモジュール名をつける必要がある！

・ 特定の関数だけをインポートする方法
from mymodule import hello  # ✅ `hello` 関数だけをインポート
print(hello())  # ✅ ""Hello, World!"" を表示
✅ この場合、hello() だけで呼び出せるのでコードがスッキリする！

📌 すべての関数をインポートする方法
from mymodule import *  # ✅ `mymodule.py` 内のすべての関数をインポート
print(hello())  # ✅ ""Hello, World!"" を表示

✅ ただし、どの関数がインポートされたのか分かりにくくなるので、推奨されない！

",5,2,
239,"以下のコードを実行すると、出力されるのは？

if __name__ == ""__main__"":
    print(""このスクリプトは直接実行されました。"")

1️⃣ ""このスクリプトは直接実行されました。""
2️⃣ エラーが発生する
3️⃣ ""None""
4️⃣ 何も表示されない

答えを選んでください！😊","1️⃣ ""このスクリプトは直接実行されました。""","🔹 if __name__ == ""__main__"": とは？
Python スクリプトが「直接実行されたとき」にのみ、if ブロック内のコードが動く！
モジュールとして import された場合は、if の中のコードは実行されない！

🔹 コードの流れ
if __name__ == ""__main__"":
    print(""このスクリプトは直接実行されました。"")

✅ このスクリプトを「直接実行」すると、__name__ は ""__main__"" になる！
✅ そのため、print(""このスクリプトは直接実行されました。"") が実行される！

🔹 出力
このスクリプトは直接実行されました。

📌 if __name__ == ""__main__"" のポイント
✔ Python スクリプトが「直接実行されたとき」にだけコードを動かす仕組み！
✔ モジュールとして import された場合には動かない！
✔ スクリプトとモジュールの両方で使えるコードを書くときに便利！

📌 import された場合は？
# main.py
import mymodule

# mymodule.py のコード
print(""このスクリプトは直接実行されました。"")

✅ この場合、import するだけで print() が実行されてしまう！

📌 これを防ぐには if __name__ == ""__main__"" を使う！

# mymodule.py
if __name__ == ""__main__"":
    print(""このスクリプトは直接実行されました。"")

✅ これで import mymodule したときには print() されず、mymodule.py を直接実行したときだけ動く！

",5,2,
240,"以下のコードを実行すると、出力されるのは？

import sys
print(sys.version)

1️⃣ Python のバージョン情報が表示される
2️⃣ ""sys.version"" と表示される
3️⃣ エラーが発生する
4️⃣ None","1️⃣ Python のバージョン情報が表示される","🔹 sys.version とは？
sys モジュールは、Python のシステム情報を取得するための標準ライブラリ！
sys.version を使うと、現在使用している Python のバージョン情報が取得できる！

🔹 コードの流れ
import sys  # ✅ sys モジュールをインポート
print(sys.version)  # ✅ Python のバージョン情報を取得

✅ sys.version は、Python のバージョン情報を文字列として返す！

🔹 出力（例）
3.11.2 (main, Jan 10 2024, 10:35:00) [GCC 11.2.0]

✅ このように、Python のバージョン情報と、ビルド環境の情報が表示される！

📌 sys モジュールのポイント
✔ Python のバージョン情報を取得するには sys.version！
✔ sys.path を使うと、Python が検索するモジュールのパスを取得できる！
✔ sys.exit() を使うと、Python プログラムを強制終了できる！

📌 他の sys モジュールの便利な使い方
import sys

print(sys.version)  # ✅ Python のバージョンを取得
print(sys.platform)  # ✅ OS の種類を取得（例: ""win32"", ""linux"", ""darwin""）
print(sys.path)  # ✅ モジュール検索パスを表示
",5,2,
241,"以下のコードを実行すると、出力されるのは？

import time
print(time.time())

1️⃣ 現在の時刻（1970年1月1日からの経過秒数）が表示される
2️⃣ ""time.time()"" と表示される
3️⃣ エラーが発生する
4️⃣ None","1️⃣ 現在の時刻（1970年1月1日からの経過秒数）が表示される","🔹 time.time() とは？
time モジュールは、時間関連の処理を扱う Python の標準ライブラリ！
time.time() は、現在の時刻を「1970年1月1日 00:00:00 UTC（Unixエポック）」からの経過秒数として取得する！
この数値は「エポックタイム（Unixタイムスタンプ）」と呼ばれる！

🔹 コードの流れ
import time  # ✅ `time` モジュールをインポート
print(time.time())  # ✅ 現在の時刻を Unixタイムスタンプ で取得

✅ time.time() の返り値は、浮動小数点数（float）として現在の Unix 時間を返す！

🔹 出力（例）
1707459862.123456

✅ この値は、「1970年1月1日 00:00:00 UTC」からの経過秒数を表している！

📌 time モジュールのポイント
✔ time.time() で Unixタイムスタンプ（エポック秒）を取得！
✔ time.sleep(x) を使うと、プログラムを x 秒間停止できる！
✔ time.strftime() を使うと、日時を「YYYY-MM-DD HH:MM:SS」形式に変換できる！

📌 time モジュールの便利な使い方
import time

print(time.time())  # ✅ 現在の Unix タイムスタンプ
time.sleep(2)  # ✅ 2秒間プログラムを停止
print(""2秒後に表示される！"")

print(time.strftime(""%Y-%m-%d %H:%M:%S""))  # ✅ 現在の日時を人間が読める形式で取得

✅ このように、time モジュールを使うと「時間を取得・変換・遅延」などの処理が簡単にできる！

",5,2,
242,"以下のコードを実行すると、出力されるのは？

import shutil
shutil.copy(""source.txt"", ""destination.txt"")

1️⃣ source.txt の内容が destination.txt にコピーされる
2️⃣ ""shutil.copy()"" と表示される
3️⃣ エラーが発生する
4️⃣ None","1️⃣ source.txt の内容が destination.txt にコピーされる","🔹 shutil.copy() とは？
shutil モジュールは、ファイルやディレクトリを操作するための標準ライブラリ！
shutil.copy(src, dst) は、src（コピー元のファイル）を dst（コピー先のファイル）にコピーする！
ファイルの内容だけをコピーし、パーミッション（権限）は変更しない！

📌 shutil モジュールのポイント
✔ shutil.copy(src, dst) → ファイルをコピー（内容のみコピー）
✔ shutil.copy2(src, dst) → ファイルをコピー（タイムスタンプなどのメタデータもコピー）
✔ shutil.move(src, dst) → ファイルを移動
✔ shutil.rmtree(path) → ディレクトリを削除

📌 shutil の便利な使い方
import shutil

# ファイルをコピー
shutil.copy(""source.txt"", ""backup.txt"")  # ✅ ""source.txt"" を ""backup.txt"" にコピー

# ディレクトリごとコピー
shutil.copytree(""source_folder"", ""backup_folder"")  # ✅ フォルダ全体をコピー

# ファイルを移動
shutil.move(""old_file.txt"", ""new_location.txt"")  # ✅ ファイルを移動

# ディレクトリを削除
shutil.rmtree(""old_folder"")  # ✅ ディレクトリを削除

✅ ファイルのコピーや移動を効率的に行うために、shutil モジュールは便利！


",5,2,
243,"以下のコードを実行すると、出力されるのは？

import json
data = '{""name"": ""Alice"", ""age"": 25}'
parsed_data = json.loads(data)
print(parsed_data[""age""])

1️⃣ 25
2️⃣ ""age""
3️⃣ エラーが発生する
4️⃣ None","1️⃣ 25","🔹 json.loads() とは？
json モジュールは、Python で JSON データを扱うための標準ライブラリ！
json.loads(json文字列) は、JSON 形式の文字列を Python の辞書型（dict）に変換する！

🔹 コードの流れ
import json  # ✅ `json` モジュールをインポート

data = '{""name"": ""Alice"", ""age"": 25}'  # ✅ JSON 形式の文字列
parsed_data = json.loads(data)  # ✅ JSON型のdataを Python の辞書に変換
print(parsed_data[""age""])  # ✅ ""age"" の値を取得

✅ json.loads() を使うと、JSON の文字列データを Python の dict に変換できる！
✅ 辞書のキー [""age""] を指定すると、値 25 が取得できる！

🔹 出力
25

📌 json モジュールのポイント
✔ json.loads(json文字列) → JSON を Python の辞書に変換！
✔ json.dumps(dict) → Python の辞書を JSON 文字列に変換！
✔ json.load(ファイルオブジェクト) → JSON ファイルを Python の辞書に変換！
✔ json.dump(dict, ファイルオブジェクト) → Python の辞書を JSON ファイルに保存！

📌 json モジュールの便利な使い方
import json

# JSON 文字列を辞書に変換
json_data = '{""city"": ""Tokyo"", ""temperature"": 25}'
parsed_data = json.loads(json_data)
print(parsed_data[""city""])  # ✅ ""Tokyo""

# Python の辞書を JSON 文字列に変換
dict_data = {""name"": ""Bob"", ""age"": 30}
json_string = json.dumps(dict_data)
print(json_string)  # ✅ '{""name"": ""Bob"", ""age"": 30}'

✅ Python の辞書（dict）と JSON を相互変換するのに便利！

",5,2,
244,"以下のコードを実行すると、出力されるのは？

import random
random.seed(10)
print(random.randint(1, 100))

1️⃣ 毎回同じ乱数が表示される
2️⃣ 1 から 100 の間でランダムな整数が表示される（毎回異なる）
3️⃣ エラーが発生する
4️⃣ None","1️⃣ 毎回同じ乱数が表示される","🔹 random.seed(x) とは？
random.seed(x) を設定すると、乱数の「開始点（シード）」が固定される！
同じシード値を使うと、random モジュールで生成される乱数が毎回同じになる！

🔹 コードの流れ
import random  # ✅ `random` モジュールをインポート
random.seed(10)  # ✅ シード値を 10 に固定（これで毎回同じ乱数が出る！）
print(random.randint(1, 100))  # ✅ 1 から 100 の間のランダムな整数を生成

✅ random.seed(10) により、random.randint(1, 100) の結果が毎回同じ値になる！

🔹 出力（例）
73
✅ 実行するたびに 73 が出力される！（他の環境でも同じ）

📌 random.seed(x) のポイント
✔ random.seed(x) を設定すると、乱数の出力が毎回同じになる！
✔ random.randint(a, b) は a 以上 b 以下の整数をランダムに返す！
✔ random.random() を使うと 0.0 ～ 1.0 の間のランダムな浮動小数点数を取得できる！

📌 random モジュールの便利な使い方
import random

random.seed(42)  # ✅ シード値を 42 に固定
print(random.randint(1, 100))  # ✅ 毎回同じ乱数が出る

random.seed(42)
print(random.randint(1, 100))  # ✅ 同じ乱数が出る（上と同じ値）

# シードを設定しない場合（通常のランダム）

print(random.randint(1, 100))  # ✅ 実行するたびに異なる値が出る

✅ シードを設定しない場合は、実行するたびに異なる乱数が生成される！

",5,2,
245,"以下のコードを実行すると、出力されるのは？

import os
os.environ[""MY_VARIABLE""] = ""Hello""
print(os.getenv(""MY_VARIABLE""))

1️⃣ ""Hello""
2️⃣ ""MY_VARIABLE""
3️⃣ None
4️⃣ エラーが発生する","1️⃣ ""Hello""","🔹 os.environ と os.getenv() とは？
os.environ は、環境変数（システムの設定値）を操作する辞書のようなオブジェクト！
os.environ[""変数名""] = ""値"" で、新しい環境変数を設定できる！
os.getenv(""変数名"") を使うと、その環境変数の値を取得できる！
もし環境変数が存在しない場合は None を返す！

🔹 コードの流れ
import os  # ✅ `os` モジュールをインポート

# 環境変数を設定
os.environ[""MY_VARIABLE""] = ""Hello""  # ✅ 環境変数 ""MY_VARIABLE"" に ""Hello"" を設定

# 環境変数を取得
print(os.getenv(""MY_VARIABLE""))  # ✅ ""Hello"" を取得

✅ os.environ[""MY_VARIABLE""] = ""Hello"" によって、環境変数が設定される！
✅ その後、os.getenv(""MY_VARIABLE"") を使うと ""Hello"" が取得できる！

🔹 出力
Hello

📌 os.environ のポイント
✔ 環境変数の取得には os.getenv(""変数名"") を使う！
✔ 環境変数の設定には os.environ[""変数名""] = ""値"" を使う！
✔ 環境変数が存在しない場合、os.getenv() は None を返す！

📌 os.environ の便利な使い方
import os

# 環境変数を設定
os.environ[""API_KEY""] = ""12345""

# 環境変数を取得
print(os.getenv(""API_KEY""))  # ✅ ""12345""

# 存在しない環境変数を取得（デフォルト値を設定）
print(os.getenv(""UNKNOWN_VARIABLE"", ""デフォルト値""))  # ✅ ""デフォルト値""

✅ 環境変数を使うと、APIキーや設定値をコード内で管理しやすくなる！

",5,2,
246,"以下のコードを python script.py hello world のように実行した場合、出力されるのは？

import sys
print(sys.argv)

1️⃣ ['script.py', 'hello', 'world']
2️⃣ ""sys.argv""
3️⃣ エラーが発生する
4️⃣ None","1️⃣ ['script.py', 'hello', 'world']","🔹 sys.argv とは？
sys.argv は、Python スクリプトを実行するときに渡されたコマンドライン引数をリストとして取得する！
sys.argv[0] にはスクリプトのファイル名（script.py など）が入る！
sys.argv[1] 以降に、コマンドラインから渡された引数が順番に格納される！

🔹 コードの流れ
import sys  # ✅ `sys` モジュールをインポート
print(sys.argv)  # ✅ コマンドライン引数のリストを表示

✅ コマンドラインから次のように実行した場合：
python script.py hello world

✅ 出力
['script.py', 'hello', 'world']

✅ sys.argv はリストなので、各引数に sys.argv[1] などでアクセスできる！

📌 sys.argv のポイント
✔ sys.argv は、コマンドライン引数をリストで取得する！
✔ sys.argv[0] にはスクリプト名が入る！
✔ スクリプトに外部からパラメータを渡したいときに便利！

📌 sys.argv の便利な使い方
import sys

if len(sys.argv) < 2:
    print(""引数を指定してください！"")
else:
    print(f""最初の引数: {sys.argv[1]}"")

✅ python script.py test と実行すると
最初の引数: test

✅ 引数なしで実行すると
引数を指定してください！

✅ エラーハンドリングもできるので、スクリプトの柔軟性が増す！

",8,2,
247,"以下のコードを実行すると、出力されるのは？

import sys
print(sys.path)

1️⃣ Python がモジュールを探すパスのリストが表示される
2️⃣ ""sys.path"" と表示される
3️⃣ エラーが発生する
4️⃣ None","1️⃣ Python がモジュールを探すパスのリストが表示される","🔹 sys.path とは？
sys.path は、Python がモジュールを検索するときのパス（ディレクトリ）をリスト形式で保持している！
モジュールを import するとき、Python は sys.path に登録されているディレクトリの中から探す！
sys.path のリストにディレクトリを追加すれば、特定のフォルダ内のモジュールをインポート可能になる！

🔹 コードの流れ
import sys  # ✅ `sys` モジュールをインポート
print(sys.path)  # ✅ Python のモジュール検索パスを表示

✅ 出力（例）
[
    '/home/user/project', 
    '/usr/lib/python3.10', 
    '/usr/lib/python3.10/lib-dynload', 
    '/usr/local/lib/python3.10/site-packages'
]
✅ これが「Python がモジュールを探すパス一覧」！

📌 sys.path のポイント
✔ sys.path は、Python がモジュールを探すディレクトリ一覧をリスト形式で保持！
✔ 新しいフォルダを sys.path.append(""フォルダパス"") で追加すると、そのフォルダのモジュールを import 可能に！
✔ カスタムモジュールを特定の場所に置いて import する場合に便利！

📌 sys.path の便利な使い方
import sys

# モジュール検索パスを表示
print(sys.path)

# カスタムモジュールのあるディレクトリを追加
sys.path.append(""/home/user/my_modules"")

# 追加後、カスタムモジュールが import 可能に！
import mymodule  # ✅ ""/home/user/my_modules/mymodule.py"" をインポート可能に

✅ この方法を使うと、プロジェクト内の特定のフォルダにある Python スクリプトを import できる！

",8,2,
248,"以下のコードを実行すると、出力されるのは？

import json
data = {""name"": ""Alice"", ""age"": 25}
json_string = json.dumps(data)
print(json_string)

1️⃣ '{""name"": ""Alice"", ""age"": 25}'
2️⃣ {""name"": ""Alice"", ""age"": 25}
3️⃣ エラーが発生する
4️⃣ None","1️⃣ '{""name"": ""Alice"", ""age"": 25}'","🔹 json.dumps() とは？
Python の dict（辞書型）を JSON 形式の文字列に変換する関数！
出力結果は、シングルクォート（'）ではなくダブルクォート（""）で囲まれる！
Python の辞書は {'key': 'value'}（シングルクォート）
JSON は {""key"": ""value""}（ダブルクォート）
API やデータの保存時などで JSON 形式に変換するのに便利！

🔹 コードの流れ
import json  # ✅ `json` モジュールをインポート

# Python の辞書データ
data = {""name"": ""Alice"", ""age"": 25}

# JSON 形式の文字列に変換
json_string = json.dumps(data)

# 結果を出力
print(json_string)

✅ json.dumps(data) によって、Python の辞書 data が JSON 文字列に変換される！

🔹 出力
{""name"": ""Alice"", ""age"": 25}

📌 json.dumps() のポイント
✔ Python の dict → JSON 形式の str に変換する！
✔ 出力はシングルクォートではなく、ダブルクォート "" になる！
✔ API のリクエスト・レスポンスやファイル保存時によく使う！

📌 json.dumps() の便利な使い方
import json

# Python の辞書データ
data = {""city"": ""Tokyo"", ""temperature"": 30}

# JSON 形式の文字列に変換
json_str = json.dumps(data, indent=4)  # ✅ `indent=4` で整形表示
print(json_str)
✅ 整形して見やすい JSON を作れる！
{
    ""city"": ""Tokyo"",
    ""temperature"": 30
}
",8,2,
249,"以下のコードを実行すると、出力されるのは？

import sqlite3

conn = sqlite3.connect("":memory:"")  # ✅ メモリ上にデータベースを作成
cursor = conn.cursor()
cursor.execute(""CREATE TABLE users (id INTEGER, name TEXT)"")
cursor.execute(""INSERT INTO users VALUES (1, 'Alice')"")
conn.commit()

cursor.execute(""SELECT name FROM users WHERE id=1"")
result = cursor.fetchone()
print(result)
1️⃣ ('Alice',)
2️⃣ ""Alice""
3️⃣ エラーが発生する
4️⃣ None","1️⃣ ('Alice',)","🔹 cursor.fetchone() とは？
SQL クエリの実行結果を「1行だけ」取得するメソッド！
fetchone() の返り値は「タプル (tuple)」！
1つのカラム（列）しか取得しなくても、タプルで返ってくる！

🔹 コードの流れ
import sqlite3  # ✅ sqlite3 をインポート

# メモリ上にデータベースを作成
conn = sqlite3.connect("":memory:"")
cursor = conn.cursor()

# users テーブルを作成
cursor.execute(""CREATE TABLE users (id INTEGER, name TEXT)"")

# データを挿入
cursor.execute(""INSERT INTO users VALUES (1, 'Alice')"")
conn.commit()

# id = 1 のユーザーの name を取得
cursor.execute(""SELECT name FROM users WHERE id=1"")
result = cursor.fetchone()
print(result)

✅ 出力
('Alice',)

📌 fetchone() のポイント
✔ SQL クエリの結果を 1 行だけ取得！
✔ 返り値は「タプル (tuple)」になる！（1つのカラムでもタプル！）
✔ 値を直接取得したい場合は result[0] を使う！

📌 値を直接取得する方法
cursor.execute(""SELECT name FROM users WHERE id=1"")
result = cursor.fetchone()
print(result[0])  # ✅ ""Alice""

✅ こうすれば ""Alice"" だけを取得できる！

",8,2,
250,"以下のコードを実行すると、出力されるのは？
※ https://jsonplaceholder.typicode.com/todos/1 は JSON データを返すテスト用 API

import requests

response = requests.get(""https://jsonplaceholder.typicode.com/todos/1"")
print(response.status_code)

1️⃣ 200
2️⃣ ""OK""
3️⃣ エラーが発生する
4️⃣ None","1️⃣ 200","🔹 requests.get() とは？
requests は、Web API からデータを取得したり、Web サーバーと通信するためのライブラリ！
requests.get(URL) を使うと、指定した URL に GET リクエストを送信する！
response.status_code を使うと、HTTP ステータスコードを取得できる！

✅ HTTP ステータスコードとは？
200 OK → 正常にリクエストが成功した！
404 Not Found → 指定したページが見つからない！
500 Internal Server Error → サーバー側でエラーが発生！

🔹 コードの流れ
import requests  # ✅ requests モジュールをインポート

# Web API に GET リクエストを送信
response = requests.get(""https://jsonplaceholder.typicode.com/todos/1"")

# ステータスコードを表示
print(response.status_code)
✅ 出力
200

📌 requests のポイント
✔ requests.get(URL) → GET リクエストを送信！
✔ response.status_code → HTTP ステータスコードを取得！
✔ response.text や response.json() でレスポンスのデータを取得できる！

📌 requests の便利な使い方
import requests

# Web API から JSON データを取得
response = requests.get(""https://jsonplaceholder.typicode.com/todos/1"")

# JSON を Python の辞書に変換
data = response.json()
print(data)  # ✅ {'userId': 1, 'id': 1, 'title': 'delectus aut autem', 'completed': False}

✅ API のレスポンスを Python の辞書として取得し、扱いやすくできる！

",8,2,
251,"以下のコードを実行すると、出力されるのは？
※ https://jsonplaceholder.typicode.com/posts は JSON データを受け付けるテスト用 API

import requests

data = {""title"": ""Hello"", ""body"": ""This is a test"", ""userId"": 1}
response = requests.post(""https://jsonplaceholder.typicode.com/posts"", json=data)

print(response.status_code)

1️⃣ 201
2️⃣ 200
3️⃣ エラーが発生する
4️⃣ None","1️⃣ 201","🔹 requests.post() とは？
requests.post(URL, json=data) を使うと、Web API に POST リクエストを送信できる！
データを送信すると、新しいリソースが作成される！
POST リクエストが成功すると、HTTP ステータスコード 201 Created が返る！

🔹 コードの流れ
import requests  # ✅ `requests` モジュールをインポート

# 送信するデータ（JSON 形式）
data = {""title"": ""Hello"", ""body"": ""This is a test"", ""userId"": 1}

# API に POST リクエストを送信
response = requests.post(""https://jsonplaceholder.typicode.com/posts"", json=data)

# ステータスコードを表示
print(response.status_code)
✅ 出力
201

📌 requests.post() のポイント
✔ requests.post(URL, json=data) → POST リクエストでデータを送信！
✔ 成功すると HTTP ステータスコード 201 Created が返る！
✔ サーバーがデータを受け取り、リソース（データ）が作成されたことを示す！

📌 レスポンスの JSON を取得する方法
import requests

data = {""title"": ""Hello"", ""body"": ""This is a test"", ""userId"": 1}
response = requests.post(""https://jsonplaceholder.typicode.com/posts"", json=data)

# レスポンスデータ（JSON）を取得
response_data = response.json()
print(response_data)  # ✅ 新しく作成されたデータが表示される

✅ API にデータを送ると、サーバーから新しいデータの情報が JSON で返ってくる！",8,2,
252,"以下のコードを実行すると、出力されるのは？

import numpy as np

arr = np.array([1, 2, 3, 4, 5])
print(arr.shape)

1️⃣ (5,)
2️⃣ (1, 5)
3️⃣ (5, 1)
4️⃣ エラーが発生する","1️⃣ (5,)","🔹 np.array() とは？
NumPy の array を使うと、リストを NumPy 配列に変換 できる！
shape を使うと、配列の形状（次元数） を取得できる！

📌 ポイント
np.array([1, 2, 3, 4, 5]) は、1 次元配列（1D array）！
形状は (5,) で「長さ 5 の 1 次元配列」！
2 次元配列 (1, 5) や (5, 1) とは異なる！

📌 shape のポイント
✔ (5,) → 1 次元の配列（行・列の概念なし）
✔ (1, 5) → 2 次元の行列（1行5列の形）
✔ (5, 1) → 2 次元の行列（5行1列の形）

📌 2 次元に変換する方法
arr_2d = arr.reshape(1, 5)  # ✅ (1, 5) の形に変換
print(arr_2d.shape)  # → (1, 5)
",9,1,
253,"以下のコードを実行すると、出力されるのは？

import numpy as np

arr = np.array([[1, 2, 3], [4, 5, 6]])
print(arr.shape)

1️⃣ (3, 2)
2️⃣ (2, 3)
3️⃣ (1, 6)
4️⃣ エラーが発生する","2️⃣ (2, 3)","🔹 shape を使うと、NumPy 配列の形状（行数, 列数）を取得できる！

📌 コードの動作
import numpy as np

arr = np.array([[1, 2, 3],  # ✅ 1行目
                [4, 5, 6]]) # ✅ 2行目
print(arr.shape)
✅ 出力
(2, 3)

📌 この配列は
2行3列の形 をしている！
形状（行, 列）は (2, 3) になる！

📌 shape のポイント
✔ 1 次元配列 → (要素数,)
✔ 2 次元配列（行列） → (行数, 列数)
✔ 3 次元以上 → (深さ, 行数, 列数)

📌 他の例
arr_1d = np.array([1, 2, 3, 4])
print(arr_1d.shape)  # ✅ (4,)

arr_2d = np.array([[1, 2, 3], [4, 5, 6]])
print(arr_2d.shape)  # ✅ (2, 3)

arr_3d = np.array([[[1, 2], [3, 4]], [[5, 6], [7, 8]]])
print(arr_3d.shape)  # ✅ (2, 2, 2)

📌 まとめ
✔ shape を使うと配列の形状（行数・列数）を取得できる！
✔ 2 次元配列は (行数, 列数) で表される！
✔ reshape() を使うと配列の形を変えられる！

",9,1,
254,"以下のコードを実行すると、出力されるのは？

import numpy as np

arr = np.zeros((2, 3))
print(arr)

1️⃣ [[0, 0, 0], [0, 0, 0]]
2️⃣ [[0.0, 0.0, 0.0], [0.0, 0.0, 0.0]]
3️⃣ [0, 0, 0, 0, 0, 0]
4️⃣ エラーが発生する","2️⃣ [[0.0, 0.0, 0.0], [0.0, 0.0, 0.0]]","🔹 np.zeros(shape) は、指定した形状の「すべての要素が 0 の配列」を作る関数！
🔹 デフォルトのデータ型は float64（小数）なので、0.0 が出力される！

📌 コードの動作
import numpy as np

arr = np.zeros((2, 3))  # ✅ 2行3列のゼロ行列を作成
print(arr)

✅ 出力
[[0. 0. 0.]
 [0. 0. 0.]]

📌 ポイント
すべての要素が 0 の 2 次元配列が作られる！
デフォルトでは小数（0.0）になる！

📌 np.zeros() の使い方
✅ 整数の 0 にしたい場合は dtype=int を指定！
arr = np.zeros((2, 3), dtype=int)
print(arr)
✅ 出力
[[0 0 0]
 [0 0 0]]

📌 その他の類似関数

関数	説明	例
np.zeros((m, n))	m×n の全要素が 0.0 の配列を作成	np.zeros((2, 3))
np.ones((m, n))	m×n の全要素が 1.0 の配列を作成	np.ones((2, 3))
np.full((m, n), value)	m×n の全要素が value の配列を作成	np.full((2, 3), 5)
np.eye(n)	n×n の単位行列を作成	np.eye(3)


📌 まとめ
✔ np.zeros(shape) でゼロの配列が作れる！
✔ デフォルトは float64 なので 0.0 になる！（整数にしたい場合は dtype=int）
✔ 類似関数 np.ones(), np.full(), np.eye() も便利！",9,1,
255,"以下のコードを実行すると、出力されるのは？

import numpy as np

arr = np.array([10, 20, 30, 40, 50])
print(np.mean(arr))

1️⃣ 30
2️⃣ 30.0
3️⃣ [30.0]
4️⃣ エラーが発生する","2️⃣ 30.0","🔹 np.mean() は配列の平均値を計算する関数！
🔹 計算結果は float（小数）になる！

📌 コードの動作
import numpy as np

arr = np.array([10, 20, 30, 40, 50])
print(np.mean(arr))  # ✅ (10+20+30+40+50) ÷ 5 = 30.0

✅ 出力
30.0

📌 ポイント
np.mean(arr) は要素の合計を要素数で割った値を返す！
出力は float（30.0）！

📌 np.mean() の使い方
✅ 2 次元配列（行ごと・列ごと）
arr_2d = np.array([[1, 2, 3], 
                    [4, 5, 6]])

print(np.mean(arr_2d))       # ✅ すべての平均 → 3.5
print(np.mean(arr_2d, axis=0))  # ✅ 列ごとの平均 → [2.5 3.5 4.5]
print(np.mean(arr_2d, axis=1))  # ✅ 行ごとの平均 → [2. 5.]

✅ 出力
3.5
[2.5 3.5 4.5]
[2. 5.]

📌 axis=0 → 列ごとの平均（縦方向）
📌 axis=1 → 行ごとの平均（横方向）

📌 まとめ
✔ np.mean() は平均値を求める関数！
✔ 出力は float（小数）になる！
✔ axis=0 → 列ごとの平均、axis=1 → 行ごとの平均！

",9,1,
256,"以下のコードを実行すると、出力されるのは？

import numpy as np

arr = np.array([[1, 2], [3, 4]])
print(np.sum(arr))

1️⃣ 10
2️⃣ array([4, 6])
3️⃣ エラーが発生する
4️⃣ [[1, 2], [3, 4]]","1️⃣ 10","🔹 np.sum() は配列内のすべての要素の合計を求める関数！
🔹 axis を指定しない場合、全要素の合計が計算される！

📌 コードの動作
import numpy as np
arr = np.array([[1, 2], 
                [3, 4]])

print(np.sum(arr))  # ✅ 1 + 2 + 3 + 4 = 10

✅ 出力
10

📌 ポイント
np.sum(arr) は 1+2+3+4 = 10 を返す！
すべての要素の合計を計算する！

📌 axis を指定するとどうなる？
💡 行ごと・列ごとの合計を計算できる！

print(np.sum(arr, axis=0))  # ✅ 列ごとの合計 → [1+3, 2+4] = [4, 6]
print(np.sum(arr, axis=1))  # ✅ 行ごとの合計 → [1+2, 3+4] = [3, 7]
✅ 出力
[4 6]
[3 7]

📌 axis=0 → 列ごとの合計（縦方向）
📌 axis=1 → 行ごとの合計（横方向）

📌 まとめ
✔ np.sum() は配列内の合計を計算する関数！
✔ axis=None（デフォルト）なら全体の合計！
✔ axis=0 → 列ごとの合計（縦方向）、axis=1 → 行ごとの合計（横方向）！

",9,1,
257,"以下のコードを実行すると、出力されるのは？
import numpy as np

arr = np.array([1.1, 2.5, 3.9])
print(np.floor(arr))

1️⃣ [1.0, 2.0, 3.0]
2️⃣ [1, 2, 3]
3️⃣ [2.0, 3.0, 4.0]
4️⃣ エラーが発生する","1️⃣ [1.0, 2.0, 3.0]","🔹 np.floor() は「小数点以下を切り捨てる関数」！
🔹 小数を「最も近い小さい整数」に切り捨てる！
🔹 出力のデータ型は元の配列の型に影響される！

📌 コードの動作
import numpy as np
arr = np.array([1.1, 2.5, 3.9])
print(np.floor(arr))

✅ 出力
[1. 2. 3.]

📌 ポイント
小数部分を切り捨てて [1.0, 2.0, 3.0] を返す！
デフォルトの dtype は float64 なので、結果も float！

📌 まとめ
✔ np.floor() は小数部分を切り捨てる関数！
✔ 結果のデータ型は元の配列の型に依存する！
✔ NumPy の array は整数なら int、小数なら float になる！
✔ 計算の種類によって float に変換されることがある！（例：np.mean()）

",9,1,
258,"以下のコードを実行すると、出力されるのは？

import numpy as np

arr = np.array([1.1, 2.5, 3.9])
print(np.ceil(arr))

1️⃣ [1.0, 2.0, 3.0]
2️⃣ [2.0, 3.0, 4.0]
3️⃣ [1, 2, 3]
4️⃣ エラーが発生する","2️⃣ [2.0, 3.0, 4.0]","🔹 np.ceil() は「小数点以下を切り上げる関数」！
🔹 各要素を「最も近い大きい整数」に切り上げる！

📌 ポイント
1.1 → 2.0（切り上げ）
2.5 → 3.0（切り上げ）
3.9 → 4.0（切り上げ）

結果のデータ型は float（元の型に依存）！

📌 np.floor() との違い
関数	説明	例
np.floor(arr)	小数点以下を 切り捨てる	[1. 2. 3.]
np.ceil(arr)	小数点以下を 切り上げる	[2. 3. 4.]

✅ 例
arr = np.array([1.9, 2.1, 2.5])
print(np.floor(arr))  # ✅ [1. 2. 2.]
print(np.ceil(arr))   # ✅ [2. 3. 3.]

📌 floor() は「小さい整数」、ceil() は「大きい整数」に変換！

📌 まとめ
✔ np.ceil() は各要素を切り上げる！
✔ 結果のデータ型は float になる！
✔ np.floor() と組み合わせて使うことが多い！

",9,1,
259,"以下のコードを実行すると、出力されるのは？

import numpy as np

arr = np.array([1.1, 2.5, 3.9])
print(np.round(arr))

1️⃣ [1.0, 2.0, 3.0]
2️⃣ [1.0, 3.0, 4.0]
3️⃣ [1, 3, 4]
4️⃣ エラーが発生する","2️⃣ [1.0, 3.0, 4.0]","🔹 np.round() は「四捨五入する関数」！
🔹 通常の四捨五入と同じルールで、0.5 以上の値を切り上げ、それ以外は切り捨てる！

📌 ポイント
1.1 → 1.0（四捨五入で切り捨て）
2.5 → 3.0（四捨五入で切り上げ）
3.9 → 4.0（四捨五入で切り上げ）

結果のデータ型は float（元の型に依存）！

📌 np.floor(), np.ceil(), np.round() の違い
関数                 説明                    例
np.floor(arr)   小数点以下を 切り捨てる   [1. 2. 3.]
np.ceil(arr)    小数点以下を 切り上げる   [2. 3. 4.]
np.round(arr)   四捨五入する             [1. 3. 4.]

✅ 例
arr = np.array([1.4, 2.5, 3.6])
print(np.floor(arr))  # ✅ [1. 2. 3.]
print(np.ceil(arr))   # ✅ [2. 3. 4.]
print(np.round(arr))  # ✅ [1. 3. 4.]

📌 floor() → 小さい整数、ceil() → 大きい整数、round() → 四捨五入！

📌 まとめ
✔ np.round() は四捨五入する！
✔ floor(), ceil(), round() の違いを理解すると便利！
✔ round(arr, decimals=n) で小数点以下 n 桁までの四捨五入も可能！

",9,1,
260,"以下のコードを実行すると、出力されるのは？

import numpy as np

arr = np.array([[1, 2], [3, 4]])
print(np.transpose(arr))

1️⃣ [[1, 2], [3, 4]]
2️⃣ [[1, 3], [2, 4]]
3️⃣ [[2, 1], [4, 3]]
4️⃣ エラーが発生する","2️⃣ [[1, 3], [2, 4]]","🔹 np.transpose() は、行と列を入れ替える（転置）関数！
🔹 縦のデータを横に、横のデータを縦に変換する！

📌 コードの動作
import numpy as np

arr = np.array([[1, 2], 
                [3, 4]])

print(np.transpose(arr))

✅ 出力
[[1 3]
 [2 4]]

📌 ポイント
1  2
3  4

転置後：
1  3
2  4

行と列が入れ替わる！

📌 np.transpose() のポイント
✔ 行列の形 (m, n) を (n, m) に変換！
✔ 計算処理やデータの整形でよく使われる！

✅ T を使っても同じ
print(arr.T)  # ✅ [[1 3] [2 4]]

✅ 3次元以上の配列にも使える
arr_3d = np.array([[[1, 2], [3, 4]], 
                    [[5, 6], [7, 8]]])
print(np.transpose(arr_3d, (1, 0, 2)))
📌 (軸1, 軸0, 軸2) のように順番を指定できる！
✅ 出力
[[[1 2]
  [5 6]]

 [[3 4]
  [7 8]]]

📌 まとめ
✔ np.transpose() は行列の行と列を入れ替える！
✔ arr.T でも同じ結果！
✔ 3次元以上の配列にも適用できる！

",9,1,
261,"以下のコードを実行すると、出力されるのは？

import numpy as np

arr = np.array([1, 2, 3, 4, 5, 6])
print(arr.reshape(2, 3))

1️⃣ [[1, 2], [3, 4], [5, 6]]
2️⃣ [[1, 2, 3], [4, 5, 6]]
3️⃣ [1, 2, 3, 4, 5, 6]
4️⃣ エラーが発生する","2️⃣ [[1, 2, 3], [4, 5, 6]]","🔹 np.reshape() は配列の形（形状）を変更する関数！
🔹 データの並び順はそのままで、新しい行列の形に整形できる！

📌 ポイント

元の配列は 1 次元（6要素）

[1, 2, 3, 4, 5, 6]
これを 2 行 3 列の行列 (2, 3) に変換！

1  2  3
4  5  6

📌 np.reshape() のポイント
✔ 配列の形を (新しい行数, 新しい列数) に変更できる！
✔ 要素数が変わらない限り、好きな形に変換できる！
✔ データの並び順は「行優先（row-major）」で変わる！

✅ 他の変形例
arr = np.array([1, 2, 3, 4, 5, 6])

# 3行2列
print(arr.reshape(3, 2))  
# ✅ [[1 2]
#     [3 4]
#     [5 6]]

# 6行1列（縦ベクトル）
print(arr.reshape(6, 1))  
# ✅ [[1]
#     [2]
#     [3]
#     [4]
#     [5]
#     [6]]
✅ -1 を使って自動調整

print(arr.reshape(-1, 2))  # ✅ ？行 2列 → (3,2) に自動変換！

📌 -1 を指定すると、残りのサイズを NumPy が自動で調整！

📌 まとめ
✔ np.reshape() で配列の形を変更できる！
✔ 要素数は変更できない！（6個のデータ → 6個のまま）
✔ -1 を使うと NumPy による自動調整が可能！

",9,1,
262,"以下のコードを実行すると、出力されるのは？

import numpy as np

arr = np.array([[1, 2, 3], [4, 5, 6]])
print(arr.flatten())

1️⃣ [[1, 2, 3], [4, 5, 6]]
2️⃣ [1, 2, 3, 4, 5, 6]
3️⃣ [[1], [2], [3], [4], [5], [6]]
4️⃣ エラーが発生する","2️⃣ [1, 2, 3, 4, 5, 6]","🔹 np.flatten() は多次元配列を 1 次元配列に変換する関数！
🔹 すべての要素を 1 列に並べて返す！

📌 コードの動作
import numpy as np

arr = np.array([[1, 2, 3], 
                [4, 5, 6]])

print(arr.flatten())

✅ 出力
[1 2 3 4 5 6]

📌 ポイント

元の配列は 2 次元（2行3列）

1  2  3
4  5  6
これを 1 次元に変換！

[1, 2, 3, 4, 5, 6]

📌 flatten() のポイント
✔ 行列（多次元）→ 1 次元に変換する！
✔ 新しい配列を作成する（元の配列は変更されない）！

✅ 類似する ravel() との違い

arr = np.array([[1, 2, 3], [4, 5, 6]])

flat1 = arr.flatten()
flat2 = arr.ravel()

arr[0, 0] = 100

print(flat1)  # ✅ [1, 2, 3, 4, 5, 6]（元の変更の影響を受けない）
print(flat2)  # ✅ [100, 2, 3, 4, 5, 6]（元の変更が反映される）

📌 flatten() はコピーを作成するので元の配列の変更に影響されない！
📌 ravel() は元のデータを参照するので、元の変更が反映される！

📌 まとめ
✔ flatten() で多次元配列を 1 次元に変換できる！
✔ 元のデータは変更されない（コピーを作成する）！
✔ 元のデータをそのまま参照する場合は ravel() を使う！

",9,1,
263,"以下のコードを実行すると、出力されるのは？

import numpy as np

arr = np.array([10, 20, 30, 40, 50, 60])
print(arr[::2])

1️⃣ [10, 20, 30]
2️⃣ [10, 30, 50]
3️⃣ [30, 40, 50, 60]
4️⃣ エラーが発生する","2️⃣ [10, 30, 50]","🔹 スライシング [start:stop:step] を使うと、配列から一定の間隔で要素を取得できる！
🔹 ::2 は「先頭から 2 ステップずつスキップしながら取得する」という意味！

📌 ポイント
スライシング [::2] の動作
10（インデックス 0）
30（インデックス 2）
50（インデックス 4）

✅ [10, 30, 50] が取得される！

📌 arr[start:stop:step] のルール
スライス                 説明                         結果
arr[::2]       先頭から 2 ステップごとに取得      [10, 30, 50]
arr[1::2]      1 番目から 2 ステップごとに取得    [20, 40, 60]
arr[::-1]      逆順（リバース）	                [60, 50, 40, 30, 20, 10]

✅ 例
arr = np.array([0, 1, 2, 3, 4, 5])

print(arr[1::2])  # ✅ [1 3 5]
print(arr[::-1])  # ✅ [5 4 3 2 1 0]

📌 [::-1] を使うと、配列を逆順にできる！

📌 まとめ
✔ arr[start:stop:step] で、間隔を指定して要素を取得できる！
✔ ::2 → 2 ステップごとに取得！
✔ [::-1] → 配列を逆順にできる！

",9,2,
264,"以下のコードを実行すると、出力されるのは？

import numpy as np

arr = np.array([[1, 2, 3], [4, 5, 6]])
print(arr[:, 1])

1️⃣ [1, 4]
2️⃣ [2, 5]
3️⃣ [3, 6]
4️⃣ エラーが発生する","2️⃣ [2, 5]","🔹 arr[:, 1] の意味 → 「すべての行（:）の 1 列目を取得」
🔹 : は「すべての行を対象」とするスライス記法！
🔹 1 は「1列目（0始まり）」を指定！

📌 コードの動作
import numpy as np
arr = np.array([[1, 2, 3],  # 1行目
                [4, 5, 6]]) # 2行目

print(arr[:, 1])
✅ 出力
[2 5]

📌 ポイント

配列の構造
1  2  3
4  5  6

「すべての行」の「1列目（0始まり）」を取得
2（1行目の 1 列目）
5（2行目の 1 列目）

✅ [2, 5] が出力！

📌 arr[:, n] のルール
スライス	説明	結果
arr[:, 0]	すべての行の 0 列目	[1, 4]
arr[:, 1]	すべての行の 1 列目	[2, 5]
arr[:, 2]	すべての行の 2 列目	[3, 6]
arr[0, :]	0 行目のすべての列	[1, 2, 3]
arr[1, :]	1 行目のすべての列	[4, 5, 6]

✅ 例
arr = np.array([[10, 20, 30], 
                [40, 50, 60]])

print(arr[:, 0])  # ✅ [10 40]（0列目）
print(arr[:, 2])  # ✅ [30 60]（2列目）
print(arr[1, :])  # ✅ [40 50 60]（1行目）

📌 まとめ
✔ arr[:, n] は「すべての行」の n 列目を取得！
✔ arr[m, :] は「すべての列」の m 行目を取得！
✔ 行列データの処理でよく使う！

",9,2,
265,"以下のコードを実行すると、出力されるのは？

import numpy as np

arr = np.array([[1, 2, 3], [4, 5, 6]])
print(arr[1, 2])

1️⃣ 1
2️⃣ 2
3️⃣ 6
4️⃣ エラーが発生する","3️⃣ 6","🔹 arr[1, 2] の意味 → 「1 行目（0始まり）の 2 列目（0始まり）の要素を取得」
🔹 NumPy のインデックスは 0 から始まる！

📌 コードの動作
import numpy as np

arr = np.array([[1, 2, 3],  # 0 行目
                [4, 5, 6]]) # 1 行目

print(arr[1, 2])
✅ 出力
6

📌 ポイント

配列の構造
1  2  3  ← 0 行目
4  5  6  ← 1 行目

1行目（4 5 6）の 2列目（6）を取得！
✅ 6 が出力！

📌 インデックスのルール
記述	説明	結果
arr[0, 0]	0行目の0列目	1
arr[0, 1]	0行目の1列目	2
arr[0, 2]	0行目の2列目	3
arr[1, 0]	1行目の0列目	4
arr[1, 1]	1行目の1列目	5
arr[1, 2]	1行目の2列目	6

✅ 例
print(arr[0, 1])  # ✅ 2
print(arr[1, 0])  # ✅ 4
print(arr[1, 2])  # ✅ 6

📌 行・列の位置を意識すると分かりやすい！

📌 まとめ
✔ arr[m, n] で m 行目の n 列目の要素を取得！
✔ NumPy のインデックスは 0 から始まる！
✔ リストのインデックスと同じ考え方！

",9,2,
266,"以下のコードを実行すると、出力されるのは？

import numpy as np

arr = np.array([[1, 2, 3], [4, 5, 6]])
print(arr[-1, -2])

1️⃣ 1
2️⃣ 2
3️⃣ 5
4️⃣ エラーが発生する","3️⃣ 5","🔹 負のインデックス（-1, -2）を使うと、後ろから数えて要素を取得できる！
🔹 arr[-1, -2] の意味 → 「最後の行（-1）の最後から 2 番目の列（-2）」

📌 コードの動作
import numpy as np

arr = np.array([[1, 2, 3],  # 0 行目
                [4, 5, 6]]) # 1 行目（= -1 行目）

print(arr[-1, -2])
✅ 出力
5

📌 ポイント

配列の構造
1  2  3  ←  0 行目
4  5  6  ← -1 行目（最後の行）

arr[-1, -2] の意味

-1 → 最後の行（1行目 = 4, 5, 6）
-2 → 後ろから 2 番目の要素（5）

✅ 5 が出力される！

📌 負のインデックスのルール
記述	説明	結果
arr[-1, -1]	最後の行の最後の列	6
arr[-1, -2]	最後の行の最後から 2 番目の列	5
arr[-2, -1]	最初の行の最後の列	3
arr[-2, -2]	最初の行の最後から 2 番目の列	2

✅ 例
print(arr[-1, -1])  # ✅ 6
print(arr[-1, -2])  # ✅ 5
print(arr[-2, -1])  # ✅ 3
print(arr[-2, -2])  # ✅ 2

📌 リストの負のインデックスと同じ感覚で使える！

📌 まとめ
✔ 負のインデックス（-1, -2）を使うと、後ろから要素を取得できる！
✔ arr[-1, -2] は「最後の行の最後から 2 番目の列」！
✔ 通常のインデックスと組み合わせて使うと便利！

",9,2,
267,"以下のコードを実行すると、出力されるのは？

import numpy as np

arr = np.array([[10, 20, 30], [40, 50, 60]])
mask = arr > 30
print(arr[mask])

1️⃣ [40, 50, 60]
2️⃣ [10, 20, 30]
3️⃣ [10, 40]
4️⃣ エラーが発生する","1️⃣ [40, 50, 60]","🔹 ブールインデックス（mask = 条件）を使うと、条件に合う要素だけを抽出できる！
🔹 arr[mask] のように使うと、True の要素だけが選択される！

📌 コードの動作
import numpy as np

arr = np.array([[10, 20, 30], 
                [40, 50, 60]])

mask = arr > 30  # ✅ 各要素が 30 より大きいかを判定
print(arr[mask])

✅ 出力
[40 50 60]

📌 ポイント

配列の構造
10  20  30
40  50  60

mask = arr > 30 の結果

[[False False False]
 [ True  True  True]]
True の要素だけ抽出！

✅ [40, 50, 60] が選ばれる！

📌 ブールインデックスのポイント
✔ 条件を満たす要素だけを取得できる！
✔ 複数の条件も組み合わせられる！

✅ 複数条件の例
arr = np.array([[10, 20, 30], [40, 50, 60]])

mask = (arr > 20) & (arr < 50)  # ✅ 20 より大きく、50 より小さい要素を取得
print(arr[mask])  

✅ 出力
[30 40]

✅ or の場合は | を使う！
mask = (arr == 10) | (arr == 60)  # ✅ 10 または 60 を取得
print(arr[mask])  

✅ 出力
[10 60]

📌 & → AND（かつ）, | → OR（または）

📌 まとめ
✔ ブールインデックスを使うと、条件に合う要素を抽出できる！
✔ mask = arr > n のように書くと、True の要素だけ取得できる！
✔ 複数条件 &（AND）や |（OR）も使える！

",9,2,
268,"以下のコードを実行すると、出力されるのは？

import numpy as np

arr = np.array([[1, 2, 3], [4, 5, 6]])
arr[arr % 2 == 0] = 0
print(arr)

1️⃣ [[1, 2, 3], [4, 5, 6]]
2️⃣ [[1, 0, 3], [0, 5, 0]]
3️⃣ [[0, 2, 0], [4, 0, 6]]
4️⃣ エラーが発生する","2️⃣ [[1, 0, 3], [0, 5, 0]]","🔹 ブールインデックスを使って、条件に一致する要素を変更することができる！
🔹 arr[arr % 2 == 0] = 0 → 偶数の要素を 0 に置き換える！

📌 コードの動作
import numpy as np

arr = np.array([[1, 2, 3], 
                [4, 5, 6]])

arr[arr % 2 == 0] = 0  # ✅ 偶数の要素を 0 にする
print(arr)

✅ 出力
[[1 0 3]
 [0 5 0]]

📌 ポイント

配列の構造
1  2  3
4  5  6

arr % 2 == 0 の結果

[[False  True False]
 [ True False  True]]

True の位置（偶数）を 0 に置き換える！

1  0  3
0  5  0

📌 ブールインデックスでの要素の置き換え
記述	説明	結果
arr[arr % 2 == 0] = 0	偶数を 0 にする	[[1, 0, 3], [0, 5, 0]]
arr[arr > 3] = -1	3 より大きい値を -1 にする	[[1, 2, 3], [-1, -1, -1]]
arr[arr < 2] = 100	2 未満の値を 100 にする	[[100, 2, 3], [4, 5, 6]]

✅ 例
arr = np.array([[1, 2, 3], [4, 5, 6]])
arr[arr > 3] = 99  # ✅ 3 より大きい値を 99 にする
print(arr)

✅ 出力
[[ 1  2  3]
 [99 99 99]]

📌 ブールインデックスを使うと、条件を満たす要素だけ変更できる！

📌 まとめ
✔ ブールインデックスを使うと、条件に一致する要素だけを変更できる！
✔ arr[条件] = 値 の形式で要素の置き換えができる！
✔ 条件式を変えることで、特定の値を一括で変更可能！

",9,2,
269,"以下のコードを実行すると、出力されるのは？

import numpy as np

arr = np.array([1, 2, 3, 4, 5, 6])
new_arr = arr.reshape(3, 2).copy()
new_arr[0, 0] = 99
print(arr)

1️⃣ [99, 2, 3, 4, 5, 6]
2️⃣ [1, 2, 3, 4, 5, 6]
3️⃣ [[99, 2], [3, 4], [5, 6]]
4️⃣ エラーが発生する","2️⃣ [1, 2, 3, 4, 5, 6]","🔹 reshape() で形を変更すると、新しいビュー（参照）を作る！
🔹 しかし、copy() を使うと新しい独立した配列を作成する！
🔹 new_arr に変更を加えても、arr には影響しない！

📌 コードの動作
import numpy as np

arr = np.array([1, 2, 3, 4, 5, 6])  # 元の配列
new_arr = arr.reshape(3, 2).copy()   # ✅ 3行2列に変換し、コピーを作成

new_arr[0, 0] = 99  # ✅ `new_arr` の値を変更（元の `arr` は変更されない）

print(arr)  # ✅ `[1, 2, 3, 4, 5, 6]` のまま！

✅ 出力
[1 2 3 4 5 6]

📌 ポイント
reshape(3, 2) → 形を変更した「ビュー（参照）」を作成
copy() を使うと「完全に新しい独立した配列」を作成
new_arr に変更を加えても、arr は影響を受けない！

📌 reshape() の copy() なしとの違い
記述                              説明                    arr への影響
arr.reshape(3, 2)          ビュー（参照）を作る              影響あり
arr.reshape(3, 2).copy()   完全に独立したコピーを作る         影響なし

✅ 例（copy() なしの場合）
arr = np.array([1, 2, 3, 4, 5, 6])
new_arr = arr.reshape(3, 2)  # ✅ ビュー（参照）

new_arr[0, 0] = 99  # ✅ `new_arr` を変更
print(arr)  # ✅ `[99, 2, 3, 4, 5, 6]`（影響を受ける！）

📌 ビュー（参照）の場合、元の arr に影響が出る！

✅ 例（copy() ありの場合）
arr = np.array([1, 2, 3, 4, 5, 6])
new_arr = arr.reshape(3, 2).copy()  # ✅ 完全に独立したコピー

new_arr[0, 0] = 99  # ✅ `new_arr` を変更
print(arr)  # ✅ `[1, 2, 3, 4, 5, 6]`（元の `arr` はそのまま！）

📌 copy() を使うと、元の arr は影響を受けない！

📌 まとめ
✔ reshape() で形を変更すると、元のデータのビュー（参照）が作成される！
✔ copy() を使うと、新しい独立した配列になる！
✔ copy() なし → 元の arr に影響あり、copy() あり → 影響なし！

",9,2,
270,"以下のコードを実行すると、出力されるのは？

import numpy as np

arr1 = np.array([1, 2, 3])
arr2 = np.array([4, 5, 6])
print(np.concatenate((arr1, arr2)))

1️⃣ [5, 7, 9]
2️⃣ [1, 2, 3, 4, 5, 6]
3️⃣ [[1, 2, 3], [4, 5, 6]]
4️⃣ エラーが発生する","2️⃣ [1, 2, 3, 4, 5, 6]","🔹 np.concatenate() は配列を結合する関数！
🔹 同じ次元の配列をつなげることができる！

📌 ポイント
arr1 → [1, 2, 3]
arr2 → [4, 5, 6]

np.concatenate((arr1, arr2)) で 1 次元配列同士を結合！

✅ [1, 2, 3, 4, 5, 6] になる！

📌 np.concatenate() のポイント
✔ 配列の次元が同じなら、簡単に結合できる！
✔ axis を指定することで、2次元以上の配列も結合可能！

✅ 2次元配列の結合
arr1 = np.array([[1, 2], [3, 4]])
arr2 = np.array([[5, 6], [7, 8]])

# 縦方向（行方向）に結合（デフォルトの `axis=0`）
print(np.concatenate((arr1, arr2), axis=0))

✅ 出力
[[1 2]
 [3 4]
 [5 6]
 [7 8]]

✅ 横方向（列方向）に結合
print(np.concatenate((arr1, arr2), axis=1))

✅ 出力
[[1 2 5 6]
 [3 4 7 8]]

📌 axis=0 → 縦に結合、axis=1 → 横に結合！

📌 まとめ
✔ np.concatenate() で同じ次元の配列を結合できる！
✔ 1次元配列はそのままつなげる！
✔ 2次元以上の配列は axis を指定して結合方向を決める！

",9,2,
271,"以下のコードを実行すると、出力されるのは？

import numpy as np

arr1 = np.array([[1, 2], [3, 4]])
arr2 = np.array([[5, 6]])
print(np.vstack((arr1, arr2)))

1️⃣ [[1, 2], [3, 4], [5, 6]]
2️⃣ [[1, 2, 5], [3, 4, 6]]
3️⃣ [[1, 2], [3, 4]], [[5, 6]]
4️⃣ エラーが発生する","1️⃣ [[1, 2], [3, 4], [5, 6]]","🔹 np.vstack() は「縦（行）方向に配列を結合」する関数！
🔹 配列の列数（横の長さ）が同じなら、縦に結合できる！

📌 コードの動作
import numpy as np

arr1 = np.array([[1, 2], 
                 [3, 4]])
arr2 = np.array([[5, 6]])

print(np.vstack((arr1, arr2)))

✅ 出力
[[1 2]
 [3 4]
 [5 6]]

📌 ポイント
arr1 → [[1, 2], [3, 4]]
arr2 → [[5, 6]]（1行2列の配列）
np.vstack((arr1, arr2)) で縦に結合！
✅ [[1, 2], [3, 4], [5, 6]] になる！
📌 np.vstack() のポイント
✔ 縦方向（行方向）に結合！
✔ arr1 の列数と arr2 の列数が一致している必要がある！
✔ 縦にデータを追加するときに便利！

✅ np.hstack() との違い
print(np.hstack((arr1, arr2.T)))  # ✅ 横方向に結合

✅ 出力
[[1 2 5]
 [3 4 6]]

📌 vstack() → 縦に結合、hstack() → 横に結合！

📌 まとめ
✔ np.vstack() で縦方向に配列を結合できる！
✔ np.hstack() を使うと横方向に結合できる！
✔ データの追加や前処理でよく使う関数！

",9,2,
272," 以下のコードを実行すると、出力されるのは？

import pandas as pd

data = [3, 6, 9, 12]
s = pd.Series(data, index=[""A"", ""B"", ""C"", ""D""])
print(s[""C""])

1️⃣ 6
2️⃣ 9
3️⃣ ""C""
4️⃣ エラーが発生する","2️⃣ 9","🔹 Series ではインデックスを指定して特定のデータを取得できる！
🔹 ラベル付きインデックス (""A"", ""B"", ""C"", ""D"") を使って値を参照できる！

📌 コードの動作
import pandas as pd

data = [3, 6, 9, 12]  # リスト
s = pd.Series(data, index=[""A"", ""B"", ""C"", ""D""])  # Series を作成

print(s[""C""])  #  ""C"" のインデックスに対応する値を取得
✅ 出力
9
📌 ポイント
s[""C""] を指定すると、対応する値 9 が取得される！
Series のインデックスは 0, 1, 2, 3 の連番ではなく、[""A"", ""B"", ""C"", ""D""] に変更されている
ラベルを指定することで、簡単にデータを取り出せる！

📌 Series のデータ取得方法
記述                   説明                             結果
s[""C""]             インデックス ""C"" の値を取得            9
s[2]               2番目の要素を取得                      9
s[:2]              最初の 2 つの要素を取得              A 3, B 6
s[[""B"", ""D""]]      ""B"" と ""D"" の値を取得                6, 12
✅ 例
print(s[2])  # ✅ 9（2番目のデータ）
print(s[:2])  # ✅ A 3, B 6（スライス）
print(s[[""B"", ""D""]])  # ✅ B 6, D 12（複数の要素）

📌 まとめ
✔ Series のインデックスはデフォルトの数字以外に、カスタムラベルも使える！
✔ s[""C""] のようにラベルを指定してデータを取得可能！
✔ 通常のリストのように s[2] で取得することもできる！

",9,1,
273,"以下のコードを実行すると、出力されるのは？

import pandas as pd

data = {
    ""名前"": [""太郎"", ""花子"", ""次郎""],
    ""年齢"": [25, 30, 22],
    ""得点"": [80, 90, 85]
}

df = pd.DataFrame(data, index=[""A"", ""B"", ""C""])

print(df.loc[""B"", ""得点""])

1️⃣ 30
2️⃣ 90
3️⃣ ""花子""
4️⃣ エラーが発生する","2️⃣ 90","📌 DataFrame における辞書の構造
🔹 DataFrame を作るときに辞書 {} を渡すと、
辞書のキー（""名前"", ""年齢"", ""得点""）が列名（カラム名） になる！
辞書の値（リスト）が行ごとのデータ になる！

📌 コードの動作
import pandas as pd

data = {
    ""名前"": [""太郎"", ""花子"", ""次郎""],  # 各キー（列）に対してリストを渡す
    ""年齢"": [25, 30, 22],
    ""得点"": [80, 90, 85]
}

df = pd.DataFrame(data, index=[""A"", ""B"", ""C""])  # インデックス（行ラベル）を指定

print(df)
✅ 出力
   名前  年齢  得点
A  太郎  25  80
B  花子  30  90
C  次郎  22  85

📌 ポイント
""名前"", ""年齢"", ""得点"" がカラム（列）
[""A"", ""B"", ""C""] が行のインデックス
各リストの 1 番目の要素（""太郎"", 25, 80）が 1 行目になる！
📌 行・列を指定してデータを取得

🔹 df.loc[行, 列] を使うと、特定のデータを取得できる！

df.loc[""B"", ""得点""] → ""B""（花子）の ""得点"" を取得
print(df.loc[""B"", ""得点""])  # ✅ 90

✅ 出力
90

📌 「行ラベル」と「列ラベル」を指定することで、DataFrame から値を取得！

📌 まとめ
✔ 辞書 {} を DataFrame にすると、キーが「列名」になる！
✔ 各リストの 1 番目、2 番目…が、それぞれの行のデータになる！
✔ df.loc[""B"", ""得点""] で「B（花子）の得点 90」を取得できる！

",9,1,
274,"以下のコードを実行すると、出力されるのは？
import pandas as pd

data = {
    ""名前"": [""太郎"", ""花子"", ""次郎""],
    ""年齢"": [25, 30, 22],
    ""得点"": [80, 90, 85]
}

df = pd.DataFrame(data, index=[""A"", ""B"", ""C""])

print(df.loc[[""A"", ""C""], [""名前"", ""得点""]])

1️⃣
   名前  得点
A  太郎  80
C  次郎  85

2️⃣
   名前  年齢  得点
A  太郎  80
C  次郎  85

3️⃣
   名前  得点
A  25  80
C  22  85

4️⃣ エラーが発生する","1️⃣
   名前  得点
A  太郎  80
C  次郎  85","🔹 df.loc[[行ラベル], [列ラベル]] を使うと、複数の行や列を同時に取得できる！

📌 コードの動作
import pandas as pd

data = {
    ""名前"": [""太郎"", ""花子"", ""次郎""],
    ""年齢"": [25, 30, 22],
    ""得点"": [80, 90, 85]
}

df = pd.DataFrame(data, index=[""A"", ""B"", ""C""])

print(df.loc[[""A"", ""C""], [""名前"", ""得点""]])
✅ 出力
   名前  得点
A  太郎  80
C  次郎  85

📌 ポイント
df.loc[[""A"", ""C""], [""名前"", ""得点""]] → ""A"" と ""C"" の ""名前"" と ""得点""` のデータだけを取得！
✅ ""花子"" のデータは取得していない（""B"" のデータを除外）
✅ ""年齢"" のデータも取得していない

📌 loc[] を使った複数データの取得
🔹 df.loc[[""行1"", ""行2""], [""列1"", ""列2""]] のようにリスト [] を使うと、複数の行や列を同時に取得 できる！

✅ 行を複数選択
print(df.loc[[""A"", ""C""]])  # ✅ AとCの全データを取得

✅ 出力
   名前  年齢  得点
A  太郎  25  80
C  次郎  22  85

📌 すべての列を含む A と C のデータを取得！

✅ 列を複数選択
print(df.loc[:, [""名前"", ""得点""]])  # ✅ すべての行の ""名前"" と ""得点"" を取得

✅ 出力
   名前  得点
A  太郎  80
B  花子  90
C  次郎  85

📌 すべての行の ""名前"" と ""得点"" を取得！

✅ 行と列を同時に指定
print(df.loc[[""A"", ""C""], [""名前"", ""得点""]])  # ✅ A と C の ""名前"" と ""得点"" だけを取得

✅ 出力
   名前  得点
A  太郎  80
C  次郎  85

📌 行 ""A"", ""C"" の ""名前"" と ""得点"" だけを抽出！

📌 まとめ
✔ df.loc[""行ラベル"", ""列ラベル""] でデータを取得！
✔ df.loc[[""行1"", ""行2""], [""列1"", ""列2""]] で複数行・複数列を取得できる！
✔ すべての行を取得する場合は : を使う → df.loc[:, [""列1"", ""列2""]]

",9,1,
275,"以下のコードを実行すると、出力されるのは？

import pandas as pd

data = {
    ""名前"": [""太郎"", ""花子"", ""次郎""],
    ""年齢"": [25, 30, 22],
    ""得点"": [80, 90, 85]
}

df = pd.DataFrame(data, index=[""A"", ""B"", ""C""])

print(df.iloc[1, 2])

1️⃣ 30
2️⃣ 90
3️⃣ ""花子""
4️⃣ エラーが発生する","2️⃣ 90","🔹 iloc[] は「行番号」と「列番号」を使ってデータを取得する！
🔹 「ラベル（行名・列名）」ではなく、 「数値インデックス」 を指定する！

📌 コードの動作
import pandas as pd

data = {
    ""名前"": [""太郎"", ""花子"", ""次郎""],
    ""年齢"": [25, 30, 22],
    ""得点"": [80, 90, 85]
}

df = pd.DataFrame(data, index=[""A"", ""B"", ""C""])

print(df.iloc[1, 2])  # ✅ どの値が出力される？

✅ 出力
90

📌 ポイント
iloc[1, 2] は「1行目 & 2列目」のデータを取得
行番号は 0 から始まる
列番号も 0 から始まる
""B"" は 1番目の行（0,1,2 の 1）
""得点"" は 2番目の列（0,1,2 の 2）
よって 90 が出力される！

📌 iloc[] を使ったデータ取得
記述	説明	出力される値
df.iloc[1, 2]	1行目 & 2列目のデータ	90
df.iloc[0, 0]	0行目 & 0列目のデータ	""太郎""
df.iloc[:, 2]	すべての行の 2列目のデータ	[80, 90, 85]
df.iloc[1, :]	1行目のすべてのデータ	[""花子"", 30, 90]

✅ 例
print(df.iloc[:, 2])  # ✅ すべての行の 2列目（得点）を取得

✅ 出力
A    80
B    90
C    85

Name: 得点, dtype: int64

📌 loc[] と iloc[] の違い
loc[]（ラベル指定）	iloc[]（数値インデックス指定）
指定方法	df.loc[""B"", ""得点""]	df.iloc[1, 2]
使い方	行名・列名 でデータ取得	行番号・列番号 でデータ取得
メリット	人間にわかりやすい	シンプルで高速

📌 「ラベルで指定するなら loc[]、数値インデックスなら iloc[]」と覚えておけばOK！

📌 まとめ
✔ iloc[] は数値インデックス（行番号・列番号）を指定してデータを取得する！
✔ iloc[1, 2] は「1行目 & 2列目」のデータを取得！
✔ 行や列をスライスして一部のデータだけを抽出することも可能！
✔ ラベルで取得するときは loc[] を使う！",9,1,
276,"以下のコードを実行すると、出力されるのは？
import pandas as pd

data = {
    ""名前"": [""太郎"", ""花子"", ""次郎""],
    ""年齢"": [25, 30, 22],
    ""得点"": [80, 90, 85]
}

df = pd.DataFrame(data, index=[""A"", ""B"", ""C""])

print(df.iloc[[0, 2], [1, 2]])
1️⃣
   年齢  得点
A  25  80
C  22  85

2️⃣
   名前  得点
A  太郎  80
C  次郎  85

3️⃣
   年齢  得点
B  30  90
C  22  85

4️⃣ エラーが発生する","1️⃣
   年齢  得点
A  25  80
C  22  85","🔹 iloc[[行番号のリスト], [列番号のリスト]] を使うと、複数の行・列を取得できる！
🔹 行番号・列番号は 0 から始まるので注意！

📌 コードの動作
import pandas as pd

data = {
    ""名前"": [""太郎"", ""花子"", ""次郎""],
    ""年齢"": [25, 30, 22],
    ""得点"": [80, 90, 85]
}

df = pd.DataFrame(data, index=[""A"", ""B"", ""C""])

print(df.iloc[[0, 2], [1, 2]])  # ✅ A, C の ""年齢"" と ""得点"" を取得
✅ 出力
   年齢  得点
A  25  80
C  22  85

📌 ポイント
行番号 [0, 2] → 1行目 (A), 3行目 (C) を取得
列番号 [1, 2] → 2列目 (""年齢"") と 3列目 (""得点"") を取得
よって ""A"" と ""C"" の ""年齢"" と ""得点"" のみが抽出される！

📌 iloc[] を使った複数データの取得
記述	説明	出力
df.iloc[[0, 2], [1, 2]]	A, C の ""年齢"" と ""得点"" を取得	年齢    25, 22, 得点 80, 85
df.iloc[:, [1, 2]]	すべての行の ""年齢"" と ""得点"" を取得	A 25 80, B 30 90, C 22 85
df.iloc[[1, 2], :]	 B, C のすべてのデータを取得	""花子"" 30 90, ""次郎"" 22 85

✅ 例
print(df.iloc[:, [1, 2]])  # ✅ すべての行の ""年齢"" と ""得点"" を取得

✅ 出力
   年齢  得点
A  25  80
B  30  90
C  22  85

📌 まとめ
✔ iloc[] を使うと「行番号」と「列番号」を指定してデータを取得できる！
✔ 複数の行や列をリスト [] でまとめて指定できる！
✔ 行や列をスライスして取得することも可能！
✔ ラベル指定（loc[]）と違って、インデックスではなく数値指定！",9,1,
277,"以下のコードを実行すると、出力されるのは？

import pandas as pd

data = {
    ""名前"": [""太郎"", ""花子"", ""次郎""],
    ""年齢"": [25, 30, 22],
    ""得点"": [80, 90, 85]
}

df = pd.DataFrame(data, index=[""A"", ""B"", ""C""])

print(df[df[""得点""] > 85])

1️⃣
   名前  年齢  得点
B  花子  30  90

2️⃣
   名前  年齢  得点
A  太郎  25  80
C  次郎  22  85

3️⃣
   名前  年齢  得点
A  太郎  25  80
B  花子  30  90
C  次郎  22  85

4️⃣ エラーが発生する","1️⃣
   名前  年齢  得点
B  花子  30  90","🔹 df[df[""列""] 条件] を使うと、条件に合うデータだけを抽出できる！
🔹 フィルタリングのような動作をする！

📌 コードの動作
import pandas as pd

data = {
    ""名前"": [""太郎"", ""花子"", ""次郎""],
    ""年齢"": [25, 30, 22],
    ""得点"": [80, 90, 85]
}

df = pd.DataFrame(data, index=[""A"", ""B"", ""C""])

print(df[df[""得点""] > 85])  # ✅ 得点が 85 より大きいデータだけを取得！

✅ 出力
   名前  年齢  得点
B  花子  30  90

📌 ポイント
df[""得点""] > 85 は、得点 が 85 より大きいデータを取得！
""A"" の 80 と ""C"" の 85 は 条件に合わない ので除外！
条件に合う ""B"" のデータのみが抽出される！

📌 pandas の条件フィルタ
🔹 条件を使ってデータを絞り込む方法！
条件指定  説明                              例
df[df[""得点""] > 85]        ""得点"" が 85 より大きいデータを取得     ✅ ""B"" だけが残る
df[df[""年齢""] < 30]        ""年齢"" が 30 未満のデータを取得         ✅ ""A"" と ""C""
df[df[""名前""] == ""次郎""]   ""名前"" が ""次郎"" のデータを取得          ✅ ""C""
✅ 例
print(df[df[""年齢""] < 30])  # ✅ 30未満のデータを取得！

✅ 出力
   名前  年齢  得点
A  太郎  25  80
C  次郎  22  85

📌 ""B"" の 年齢 30 は条件に合わないので除外！

📌 まとめ
✔ df[df[""列""] 条件] で、条件に合うデータだけを抽出できる！
✔ フィルタリングのようにデータを絞り込むのに便利！
✔ df[df[""得点""] > 85] は 得点 > 85 のデータを取得！
✔ 複数条件を組み合わせることも可能！（次の問題でやるよ！）

",9,1,
278,"以下のコードを実行すると、出力されるのは？
import pandas as pd

data = {
    ""名前"": [""太郎"", ""花子"", ""次郎""],
    ""年齢"": [25, 30, 22],
    ""得点"": [80, 90, 85]
}

df = pd.DataFrame(data, index=[""A"", ""B"", ""C""])

print(df[(df[""得点""] > 80) & (df[""年齢""] < 30)])

1️⃣
   名前  年齢  得点
C  次郎  22  85

2️⃣
   名前  年齢  得点
B  花子  30  90
C  次郎  22  85

3️⃣
   名前  年齢  得点
A  太郎  25  80
C  次郎  22  85

4️⃣ エラーが発生する","1️⃣
   名前  年齢  得点
C  次郎  22  85","🔹 &（かつ） と |（または） を使って複数の条件を組み合わせることができる！
🔹 df[(条件1) & (条件2)] で両方の条件を満たすデータだけを取得！

📌 コードの動作
import pandas as pd

data = {
    ""名前"": [""太郎"", ""花子"", ""次郎""],
    ""年齢"": [25, 30, 22],
    ""得点"": [80, 90, 85]
}

df = pd.DataFrame(data, index=[""A"", ""B"", ""C""])

print(df[(df[""得点""] > 80) & (df[""年齢""] < 30)])  # ✅ 条件を満たすデータを抽出

✅ 出力
   名前  年齢  得点
C  次郎  22  85

📌 ポイント
(df[""得点""] > 80) → ""得点"" が 80 より大きいデータだけを取得
→ ""B: 90"", ""C: 85""（""A: 80"" は除外）
(df[""年齢""] < 30) → ""年齢"" が 30 未満のデータだけを取得
→ ""A: 25"", ""C: 22""（""B: 30"" は除外）
両方の条件を満たすデータだけが取得される！
→ ""C"" の ""次郎"" だけが該当！
""A""（太郎, 25, 80）は得点が条件を満たさないので除外！
""B""（花子, 30, 90）は年齢が条件を満たさないので除外！

📌 & と | を使った複数条件のフィルタ
条件	説明	取得するデータ
df[(df[""得点""] > 80) & (df[""年齢""] < 30)]	得点 > 80 かつ 年齢 < 30	 C（次郎）
`df[(df[""得点""] > 80)	(df[""年齢""] < 30)]`	得点 > 80 または 年齢< 30
df[(df[""得点""] == 85) & (df[""名前""] == ""次郎"")]	得点 85 かつ 名前 ""次郎""	C（次郎）

✅ 例
print(df[(df[""得点""] > 80) | (df[""年齢""] < 30)])  # ✅ 得点 > 80 または 年齢 < 30 のデータを取得

✅ 出力
   名前  年齢  得点
A  太郎  25  80
B  花子  30  90
C  次郎  22  85

📌 |（または）を使うと、どちらかの条件を満たせばOK！

📌 まとめ
✔ &（かつ）： 両方の条件を満たすデータを取得！
✔ |（または）： どちらかの条件を満たせば取得！
✔ df[(条件1) & (条件2)] のように () を使うことを忘れない！
✔ データ分析でよく使うので必須スキル！",9,1,
279,"以下のコードを実行すると、出力されるのは？

import pandas as pd

data = {
    ""名前"": [""太郎"", ""花子"", ""次郎""],
    ""年齢"": [25, 30, 22],
    ""得点"": [80, 90, 85]
}

df = pd.DataFrame(data, index=[""A"", ""B"", ""C""])

print(df.sort_values(by=""年齢""))

1️⃣
   名前  年齢  得点
C  次郎  22  85
A  太郎  25  80
B  花子  30  90

2️⃣
   名前  年齢  得点
B  花子  30  90
A  太郎  25  80
C  次郎  22  85

3️⃣
   名前  年齢  得点
B  花子  30  90
C  次郎  22  85
A  太郎  25  80

4️⃣ エラーが発生する","1️⃣
   名前  年齢  得点
C  次郎  22  85
A  太郎  25  80
B  花子  30  90","🔹 df.sort_values(by=""列名"") を使うと、指定した列を基準にデータを並び替えられる！
🔹 デフォルトでは「昇順（小さい順）」に並び替えられる！

📌 コードの動作
import pandas as pd

data = {
    ""名前"": [""太郎"", ""花子"", ""次郎""],
    ""年齢"": [25, 30, 22],
    ""得点"": [80, 90, 85]
}

df = pd.DataFrame(data, index=[""A"", ""B"", ""C""])

print(df.sort_values(by=""年齢""))  # ✅ 年齢順にソート
✅ 出力
   名前  年齢  得点
C  次郎  22  85
A  太郎  25  80
B  花子  30  90

📌 ポイント

sort_values(by=""年齢"") → ""年齢"" の値を基準に並び替え！
デフォルトは昇順（小さい順）
""C（次郎, 22）"" → ""A（太郎, 25）"" → ""B（花子, 30）"" の順番になる！

📌 データを降順（大きい順）に並び替える
🔹 ascending=False を指定すると、降順（大きい順）になる！
print(df.sort_values(by=""年齢"", ascending=False))  # ✅ 年齢の降順（大きい順）

✅ 出力
   名前  年齢  得点
B  花子  30  90
A  太郎  25  80
C  次郎  22  85

📌 昇順（小さい順）が ascending=True（デフォルト）、降順（大きい順）が ascending=False

📌 複数の列で並び替え
🔹 by=[""列1"", ""列2""] を指定すると、複数の列を基準に並び替えができる！

print(df.sort_values(by=[""得点"", ""年齢""]))  # ✅ 得点で昇順, 同じなら年齢で昇順

✅ 出力
   名前  年齢  得点
A  太郎  25  80
C  次郎  22  85
B  花子  30  90

📌 「得点」が小さい順で並び、同じ得点なら「年齢」が小さい順に並ぶ！

📌 まとめ
✔ df.sort_values(by=""列名"") でデータを並び替えられる！
✔ デフォルトは昇順（小さい順）！
✔ ascending=False で降順（大きい順）にできる！
✔ 複数の列で並び替えも可能！

",9,1,
280,"以下のコードを実行すると、出力されるのは？

import pandas as pd

data = {
    ""名前"": [""太郎"", ""花子"", ""次郎""],
    ""年齢"": [25, 30, 22],
    ""得点"": [80, 90, 85]
}

df = pd.DataFrame(data, index=[""A"", ""B"", ""C""])

print(df.describe())

1️⃣
         年齢        得点
count   3.0   3.000000
mean   25.67  85.000000
std     4.04  5.000000
min    22.00  80.000000
25%    23.50  82.50
50%    25.00  85.000000
75%    27.50  87.50
max    30.00  90.000000

2️⃣
   名前  年齢  得点
A  太郎  25  80
B  花子  30  90
C  次郎  22  85

3️⃣
   名前  年齢  得点
B  花子  30  90
C  次郎  22  85
A  太郎  25  80

4️⃣ エラーが発生する","1️⃣
         年齢        得点
count   3.0   3.000000
mean   25.67  85.000000
std     4.04  5.000000
min    22.00  80.000000
25%    23.50  82.50
50%    25.00  85.000000
75%    27.50  87.50
max    30.00  90.000000","🔹 df.describe() を使うと、数値データの統計情報（平均、最大値など）が一括で取得できる！
🔹 デフォルトでは 数値データ（int, float） のみが対象になる！

📌 コードの動作
import pandas as pd

data = {
    ""名前"": [""太郎"", ""花子"", ""次郎""],
    ""年齢"": [25, 30, 22],
    ""得点"": [80, 90, 85]
}

df = pd.DataFrame(data, index=[""A"", ""B"", ""C""])

print(df.describe())  # ✅ 統計情報を取得

✅ 出力
         年齢        得点
count   3.0   3.000000
mean   25.67  85.000000
std     4.04  5.000000
min    22.00  80.000000
25%    23.50  82.50
50%    25.00  85.000000
75%    27.50  87.50
max    30.00  90.000000

📌 ポイント
count → データの数（行数）
mean → 平均値
std → 標準偏差（データのばらつき）
min → 最小値
25% 50% 75% → 四分位数（データを4分割したときの値）
max → 最大値

📌 describe() のオプション

🔹 すべてのデータ（文字列データ含む）を取得したい場合
print(df.describe(include=""all""))

✅ 出力
r
          名前        年齢        得点
count     3.0   3.000000   3.000000
unique    3.0        NaN        NaN
top      太郎        NaN        NaN
freq      1.0        NaN        NaN
mean      NaN   25.666667   85.000000
std       NaN    4.041452    5.000000
min       NaN   22.000000   80.000000
25%       NaN   23.500000   82.500000
50%       NaN   25.000000   85.000000
75%       NaN   27.500000   87.500000
max       NaN   30.000000   90.000000

📌 文字列データ（名前）については unique や top などの情報が出力される！

📌 まとめ
✔ df.describe() で数値データの統計情報を取得できる！
✔ 平均 (mean), 最大 (max), 最小 (min), 標準偏差 (std) などの統計情報が得られる！
✔ describe(include=""all"") で文字列データの統計情報も取得できる！

",9,1,
281,"以下のコードを実行すると、出力されるのは？

import pandas as pd

data = {
    ""名前"": [""太郎"", ""花子"", ""次郎"", ""三郎""],
    ""性別"": [""男"", ""女"", ""男"", ""男""],
    ""得点"": [80, 90, 85, 75]
}

df = pd.DataFrame(data)

print(df.groupby(""性別"")[""得点""].mean())

1️⃣
性別
女    90.0
男    80.0
Name: 得点, dtype: float64

2️⃣
性別  得点
女    90.0
男    80.0

3️⃣
性別
男    85.0
女    90.0
Name: 得点, dtype: float64

4️⃣ エラーが発生する","1️⃣
性別
女    90.0
男    80.0
Name: 得点, dtype: float64","🔹 df.groupby(""列名"") を使うと、指定した列ごとにデータをグループ化できる！
🔹 [""得点""].mean() を使うと、グループごとの平均値を計算できる！

📌 コードの動作
import pandas as pd

data = {
    ""名前"": [""太郎"", ""花子"", ""次郎"", ""三郎""],
    ""性別"": [""男"", ""女"", ""男"", ""男""],
    ""得点"": [80, 90, 85, 75]
}

df = pd.DataFrame(data)

print(df.groupby(""性別"")[""得点""].mean())  # ✅ ""性別"" ごとの ""得点"" の平均を計算

✅ 出力
性別
女    90.0
男    80.0
Name: 得点, dtype: float64

📌 ポイント
df.groupby(""性別"") → ""性別"" ごとにデータをグループ化！
[""得点""].mean() → ""得点"" の平均値を計算！
""男"" の得点平均 → (80 + 85 + 75) / 3 = 80.0
""女"" の得点平均 → 90.0（データ1つだけなのでそのまま）

📌 groupby() の基本的な使い方
記述	説明	出力
df.groupby(""性別"")[""得点""].sum()	性別ごとの得点合計を計算	男: 240, 女: 90
df.groupby(""性別"")[""得点""].count()	性別ごとの人数を計算	男: 3, 女: 1
df.groupby(""性別"").mean()	性別ごとのすべての数値データの平均を計算	男: (得点 80.0), 女: (得点 90.0)

✅ 例
print(df.groupby(""性別"").count())  # ✅ 性別ごとのデータ数

✅ 出力
    名前  得点
性別          
男    3   3
女    1   1
📌 ""男"" が 3 人、 ""女"" が 1 人いることが分かる！

📌 まとめ
✔ df.groupby(""列名"") でデータをグループ化できる！
✔ [""列名""].mean() を使うと、グループごとの平均を計算！
✔ sum() や count() も使える！
✔ データ分析や集計に必須の機能！",9,1,
282,"以下のコードを実行すると、出力されるのは？

import pandas as pd

data = {
    ""名前"": [""健太"", ""美咲"", ""翔太""],
    ""年齢"": [28, 32, 24],
    ""得点"": [75, 88, 90]
}

df = pd.DataFrame(data, index=[""A"", ""B"", ""C""])

print(df.loc[""B"", ""得点""])

1️⃣ 75
2️⃣ 88
3️⃣ 90
4️⃣ エラーが発生する","2️⃣ 88","🔹 loc[] を使うと、""行ラベル"" と ""列ラベル"" を指定してデータを取得できる！

📌 コードの動作
import pandas as pd

data = {
    ""名前"": [""健太"", ""美咲"", ""翔太""],
    ""年齢"": [28, 32, 24],
    ""得点"": [75, 88, 90]
}

df = pd.DataFrame(data, index=[""A"", ""B"", ""C""])

print(df.loc[""B"", ""得点""])  # ✅ ""B"" 行の ""得点"" の値を取得

✅ 出力
88

📌 ポイント

df.loc[""B"", ""得点""]
→ ""B"" の ""得点"" の値を取得！
→ ""美咲"" の得点は 88 なので、出力は 88！

📌 loc[] の基本的な使い方
記述	説明	出力
df.loc[""B"", ""得点""]	""B"" の ""得点"" を取得	88
df.loc[""A"", ""名前""]	""A"" の ""名前"" を取得	""健太""
df.loc[:, ""得点""]	すべての行の ""得点"" を取得	[75, 88, 90]

✅ 例
print(df.loc[:, ""得点""])  # ✅ すべての行の ""得点"" を取得

✅ 出力
A    75
B    88
C    90

Name: 得点, dtype: int64

📌 : を使うと「すべての行」を指定できる！

📌 まとめ
✔ df.loc[""行ラベル"", ""列ラベル""] でデータを取得できる！
✔ 複数行や複数列を取得することも可能！
✔ ラベルを使ってデータを指定できるので、わかりやすい！",9,1,
283,"以下のコードを実行すると、出力されるのは？

import pandas as pd

data = {
    ""名前"": [""健太"", ""美咲"", ""翔太""],
    ""年齢"": [28, 32, 24],
    ""得点"": [75, 88, 90]
}

df = pd.DataFrame(data, index=[""A"", ""B"", ""C""])

print(df.iloc[2, 1])
1️⃣ 健太
2️⃣ 24
3️⃣ 90
4️⃣ エラーが発生する","2️⃣ 24","🔹 iloc[] は、""数値インデックス""（行番号・列番号）を指定してデータを取得する！
🔹 Python のインデックスは 0 から始まるので注意！

📌 コードの動作
import pandas as pd

data = {
    ""名前"": [""健太"", ""美咲"", ""翔太""],
    ""年齢"": [28, 32, 24],
    ""得点"": [75, 88, 90]
}

df = pd.DataFrame(data, index=[""A"", ""B"", ""C""])

print(df.iloc[2, 1])  # ✅ 2行目 & 1列目のデータを取得
✅ 出力
24

📌 ポイント
iloc[2, 1]
→ ""2行目（インデックス 2）"" の ""1列目（インデックス 1）"" のデータを取得！
→ ""翔太"" の ""年齢"" は 24 なので、出力は 24！

📌 iloc[] の基本的な使い方
記述	説明	出力
df.iloc[2, 1]	2行目 & 1列目のデータ	24
df.iloc[0, 0]	0行目 & 0列目のデータ	""健太""
df.iloc[:, 2]	すべての行の 2列目のデータ	[75, 88, 90]
df.iloc[1, :]	1行目のすべてのデータ	[""美咲"", 32, 88]

✅ 例
print(df.iloc[:, 2])  # ✅ すべての行の ""得点"" を取得
✅ 出力
A    75
B    88
C    90
Name: 得点, dtype: int64

📌 : を使うと「すべての行」を指定できる！

📌 loc[] と iloc[] の違い
loc[]（ラベル指定）	iloc[]（数値インデックス指定）
指定方法	df.loc[""B"", ""得点""]	df.iloc[1, 2]
使い方	行名・列名 でデータ取得	行番号・列番号 でデータ取得
メリット	人間にわかりやすい	シンプルで高速

📌 「ラベルで指定するなら loc[]、数値インデックスなら iloc[]」と覚えておけばOK！

📌 まとめ
✔ iloc[] は数値インデックス（行番号・列番号）を指定してデータを取得する！
✔ 行番号 & 列番号は 0 から始まるので注意！
✔ df.iloc[2, 1] は「2行目 & 1列目」のデータを取得！
✔ ラベルで取得するときは loc[] を使う！

",9,1,
284,"以下のコードを実行すると、出力されるのは？

import pandas as pd

data = {
    ""名前"": [""健太"", ""美咲"", ""翔太""],
    ""年齢"": [28, 32, 24],
    ""得点"": [75, 88, 90]
}

df = pd.DataFrame(data, index=[""A"", ""B"", ""C""])

print(df[df[""得点""] > 80])

1️⃣
   名前  年齢  得点
B  美咲  32  88
C  翔太  24  90

2️⃣
   名前  年齢  得点
A  健太  28  75
B  美咲  32  88

3️⃣
   名前  年齢  得点
C  翔太  24  90

4️⃣ エラーが発生する","1️⃣
   名前  年齢  得点
B  美咲  32  88
C  翔太  24  90","🔹 df[df[""列""] 条件] を使うと、特定の条件を満たすデータだけを抽出できる！
🔹 フィルタリング（データの絞り込み）によく使われる！

📌 コードの動作
import pandas as pd

data = {
    ""名前"": [""健太"", ""美咲"", ""翔太""],
    ""年齢"": [28, 32, 24],
    ""得点"": [75, 88, 90]
}

df = pd.DataFrame(data, index=[""A"", ""B"", ""C""])

print(df[df[""得点""] > 80])  # ✅ ""得点"" が 80 を超えるデータを抽出

✅ 出力
   名前  年齢  得点
B  美咲  32  88
C  翔太  24  90

📌 ポイント
df[""得点""] > 80 → ""得点"" が 80` より大きいデータを取得
""A""（健太, 75）"" は 得点 75 なので除外！
""B""（美咲, 88）"" と ""C""（翔太, 90）"" は 得点 80 超えなので取得！

📌 df[df[""列""] 条件] の基本
記述	説明	取得するデータ
df[df[""得点""] > 80]	得点が 80 より大きいデータを取得	B（美咲）, C（翔太）
df[df[""年齢""] < 30]	年齢が 30 未満のデータを取得	A（健太）, C（翔太）
df[df[""名前""] == ""翔太""]	名前が ""翔太"" のデータを取得	C（翔太）

✅ 例
print(df[df[""年齢""] < 30])  # ✅ 年齢が 30 未満のデータを取得

✅ 出力
   名前  年齢  得点
A  健太  28  75
C  翔太  24  90

📌 `""B"" の 美咲（32歳） は条件に合わないので除外！**

📌 まとめ
✔ df[df[""列""] 条件] で、条件に合うデータだけを抽出できる！
✔ データのフィルタリングや検索に便利！
✔ 複数条件 (&, |) も使える！（次の問題でやるよ！）

",9,1,
285,"以下のコードを実行すると、出力されるのは？

import pandas as pd

data = {
    ""名前"": [""健太"", ""美咲"", ""翔太""],
    ""年齢"": [28, 32, 24],
    ""得点"": [75, 88, 90]
}

df = pd.DataFrame(data, index=[""A"", ""B"", ""C""])

print(df[(df[""得点""] > 80) & (df[""年齢""] < 30)])

1️⃣
   名前  年齢  得点
C  翔太  24  90

2️⃣
   名前  年齢  得点
B  美咲  32  88
C  翔太  24  90

3️⃣
   名前  年齢  得点
A  健太  28  75
C  翔太  24  90

4️⃣ エラーが発生する","1️⃣
   名前  年齢  得点
C  翔太  24  90","🔹 &（かつ） と |（または） を使って、複数の条件を組み合わせられる！
🔹 df[(条件1) & (条件2)] を使うと、両方の条件を満たすデータだけを取得！

📌 コードの動作
import pandas as pd

data = {
    ""名前"": [""健太"", ""美咲"", ""翔太""],
    ""年齢"": [28, 32, 24],
    ""得点"": [75, 88, 90]
}

df = pd.DataFrame(data, index=[""A"", ""B"", ""C""])

print(df[(df[""得点""] > 80) & (df[""年齢""] < 30)])  # ✅ 両方の条件を満たすデータを取得

✅ 出力
   名前  年齢  得点
C  翔太  24  90

📌 ポイント
(df[""得点""] > 80) → ""得点"" が 80 より大きいデータを取得
→ ""B: 88"", ""C: 90""（""A: 75"" は除外）
(df[""年齢""] < 30) → ""年齢"" が 30 未満のデータを取得
→ ""A: 28"", ""C: 24""（""B: 32"" は除外）
両方の条件を満たすデータだけが取得される！
→ ""C""（翔太, 24, 90） だけが該当！
""A""（健太, 28, 75）は得点が条件を満たさないので除外！
""B""（美咲, 32, 88）は年齢が条件を満たさないので除外！

📌 & と | を使った複数条件のフィルタ
条件	説明	取得するデータ
df[(df[""得点""] > 80) & (df[""年齢""] < 30)]	得点 > 80 かつ 年齢 < 30	C（翔太）
`df[(df[""得点""] > 80)	(df[""年齢""] < 30)]`	得点 > 80 または 年齢 < 30
df[(df[""得点""] == 90) & (df[""名前""] == ""翔太"")]	得点 90 かつ 名前 ""翔太""	C（翔太）

✅ 例
print(df[(df[""得点""] > 80) | (df[""年齢""] < 30)])  # ✅ 得点 > 80 または 年齢 < 30 のデータを取得

✅ 出力
   名前  年齢  得点
A  健太  28  75
B  美咲  32  88
C  翔太  24  90

📌 |（または）を使うと、どちらかの条件を満たせばOK！

📌 まとめ
✔ &（かつ）： 両方の条件を満たすデータを取得！
✔ |（または）： どちらかの条件を満たせば取得！
✔ df[(条件1) & (条件2)] のように () を使うことを忘れない！
✔ データ分析でよく使うので必須スキル！

",9,1,
286,"以下のコードを実行すると、出力されるのは？

nums = [1, 2, 3, 4, 5, 6]
even_nums = list(filter(lambda x: x % 2 == 0, nums))
print(even_nums)

1️⃣ [1, 3, 5]
2️⃣ [2, 4, 6]
3️⃣ [0, 2, 4, 6]
4️⃣ エラーが発生する","2️⃣ [2, 4, 6]","🔹 filter() は、リストなどのデータから特定の条件を満たす要素だけを抽出する関数！
🔹 lambda 関数と組み合わせると、短く簡潔に条件を指定できる！

📌 コードの動作
nums = [1, 2, 3, 4, 5, 6]
even_nums = list(filter(lambda x: x % 2 == 0, nums))  # ✅ 偶数だけを抽出
print(even_nums)

✅ 出力
[2, 4, 6]

📌 ポイント
lambda x: x % 2 == 0
→ x を 2 で割った余りが 0 のとき True（偶数） を返す！
filter() は、リストの各要素を lambda 関数でチェックし、True になったものだけを残す！
list() で filter の結果をリスト化！

📌 filter() の基本
記述	説明	出力
filter(lambda x: x % 2 == 0, nums)	偶数だけを抽出	[2, 4, 6]
filter(lambda x: x > 3, nums)	3 より大きい数を抽出	[4, 5, 6]
filter(lambda s: ""a"" in s, words)	""a"" を含む文字列を抽出	[""apple"", ""banana""]

✅ 例
words = [""apple"", ""banana"", ""cherry"", ""date""]
filtered_words = list(filter(lambda s: ""a"" in s, words))  # ✅ ""a"" を含む単語を抽出
print(filtered_words)

✅ 出力
['apple', 'banana']
📌 ""a"" を含む単語 ""apple"" と ""banana"" が抽出される！

📌 map() と filter() の違い
関数	目的	例
map()	すべての要素を変換する	map(lambda x: x * 2, nums) → [2, 4, 6, 8, 10, 12]
filter()	特定の条件を満たすものだけ残す	filter(lambda x: x % 2 == 0, nums) → [2, 4, 6]

📌 「すべてのデータに処理を適用するなら map()」「条件に合うものだけを残すなら filter()」！

📌 まとめ
✔ filter() を使うと、リストなどから条件を満たすデータだけを抽出できる！
✔ lambda と組み合わせると、短く簡潔に記述できる！
✔ map() との違いは、「変換」ではなく「抽出」！

",3,2,
287,"以下のコードを実行すると、出力されるのは？ただし、mymodule.py は main.py と同じディレクトリ内に存在し、次の内容を持つものとする。
```PYTHON
# mymodule.py
def greet(name):
    return f""こんにちは、{name} さん！""
```PYTHON
```PYTHON
# main.py
import mymodule

print(mymodule.greet(""太郎""))
```PYTHON

1️⃣ ""こんにちは、太郎 さん！""
2️⃣ ""mymodule.greet()""
3️⃣ None
4️⃣ エラーが発生する","1️⃣ ""こんにちは、太郎 さん！""","🔹 Python では import を使って外部のモジュールを読み込める！
🔹 import モジュール名 を使うと、モジュール内の関数や変数を モジュール名.関数名() の形式で呼び出せる！

📌 コードの動作
🔹 mymodule.py（モジュール）

# mymodule.py
def greet(name):
    return f""こんにちは、{name} さん！""

🔹 main.py（実行するコード）

import mymodule  # ✅ mymodule をインポート

print(mymodule.greet(""太郎""))  # ✅ mymodule の greet() を呼び出す

✅ 出力

こんにちは、太郎 さん！
📌 import の基本 🔸 書き方の違い

記述	説明	例
import mymodule	mymodule.py をインポート	mymodule.greet(""太郎"")
from mymodule import greet	mymodule の greet 関数だけをインポート	greet(""太郎"")
from mymodule import *	mymodule のすべての関数をインポート	greet(""太郎"")

✅ 例（from mymodule import greet を使う場合）
from mymodule import greet  # ✅ greet 関数だけをインポート

print(greet(""花子""))  # ✅ mymodule. をつけずに呼び出せる！

✅ 出力
こんにちは、花子 さん！

💡from mymodule import 関数名 を使うと、モジュール名を省略できる！

📌 まとめ
✔ import を使うと、外部の Python ファイル（モジュール）を読み込める！
✔ mymodule.関数名() の形式で関数を呼び出せる！
✔ from モジュール import 関数 を使うと、モジュール名を省略できる！",5,3,
288,"以下のコードを実行すると、出力されるのは？

# 📌 `/home/user/mymodules/mymodule.py` というモジュールファイルが存在する

# mymodule.py の内容
def greet(name):
    return f""こんにちは、{name} さん！""

# main.py の内容
import sys
sys.path.append(""/home/user/mymodules"")  # ✅ モジュールの検索パスを追加

import mymodule
print(mymodule.greet(""太郎""))

1️⃣ ""こんにちは、太郎 さん！""
2️⃣ ""sys.path の一覧が表示される""
3️⃣ エラーが発生する
4️⃣ None","1️⃣ ""こんにちは、太郎 さん！""","💡 Python は import でモジュールを探すときに、sys.path に登録されたディレクトリを検索する！

👉 sys.path.append(""パス"") を使うと、カスタムモジュールのあるディレクトリを追加できる！

🔹 コードの動作

# 📌 `/home/user/mymodules/mymodule.py` というモジュールファイルが存在する

# mymodule.py の内容
def greet(name):
    return f""こんにちは、{name} さん！""

# main.py の内容
import sys
sys.path.append(""/home/user/mymodules"")  # ✅ モジュールの検索パスを追加

import mymodule
print(mymodule.greet(""太郎""))  # ✅ mymodule.py の greet() を実行
✅ 出力
こんにちは、太郎 さん！

🔹 ポイント
1️⃣ sys.path.append(""パス"") を使うと、カスタムモジュールのあるディレクトリを Python の検索パスに追加できる！
2️⃣ import mymodule で、/home/user/mymodules/mymodule.py を読み込める！
3️⃣ mymodule.greet(""太郎"") を呼び出して ""こんにちは、太郎 さん！"" を表示！

📌 sys.path の基本
記述	説明	例
import sys	sys モジュールをインポート	-
sys.path.append(""パス"")	モジュール検索パスを追加	sys.path.append(""/home/user/mymodules"")
sys.path	モジュール検索パス一覧を取得	print(sys.path)
✅ 検索パスを確認する
import sys
print(sys.path)  # ✅ Python がモジュールを探すパス一覧を表示

✅ カスタムモジュールのパスを追加
import sys
sys.path.append(""/home/user/mymodules"")  # ✅ 独自モジュールのパスを追加

📌 このように sys.path.append() を使うことで、Python のデフォルトの検索パスにないモジュールもインポートできる！

📌 まとめ
✔ Python は sys.path に登録されたディレクトリを検索して import を実行する！
✔ sys.path.append(""パス"") を使うと、独自のディレクトリを追加できる！
✔ import mymodule で、カスタムモジュールを読み込める！",5,3,
289,"以下のコードを実行すると、出力されるのは？

```python
# 📌 mymodule.py の内容
def greet():
    return ""こんにちは！""

if __name__ == ""__main__"":
    print(""mymodule.py が直接実行されました"")

# 📌 main.py の内容
import mymodule
print(mymodule.greet())
```python

1️⃣ ""こんにちは！""
2️⃣ ""mymodule.py が直接実行されました""
3️⃣ 両方とも表示される
4️⃣ エラーが発生する","1️⃣ ""こんにちは！""","💡 __name__ == ""__main__"" は、そのスクリプトが「直接実行された」か「他のファイルからインポートされた」かを判定する仕組み！
👉 import mymodule すると、if __name__ == ""__main__"" の部分は実行されない！

🔹 コードの動作
```python
# 📌 mymodule.py の内容
def greet():
    return ""こんにちは！""

if __name__ == ""__main__"":  # ✅ 直接実行されたときだけ実行
    print(""mymodule.py が直接実行されました"")

# 📌 main.py の内容
import mymodule
print(mymodule.greet())  # ✅ greet() を呼び出す
```python

✅ 出力
こんにちは！
🔹 なぜ ""mymodule.py が直接実行されました"" は表示されない？
　🔸 if __name__ == ""__main__"" の意味
　　 if __name__ == ""__main__"":
    print(""mymodule.py が直接実行されました"")

💡 このコードは、「直接実行されたときのみ実行」される！

👉 mymodule.py を直接実行すると、__name__ は ""__main__"" になり、print(""mymodule.py が直接実行されました"") が実行される！
👉 しかし、import mymodule すると mymodule.py は「インポートされた状態」なので、この部分はスキップされる！

📌 まとめ
✔ __name__ == ""__main__"" を使うと、スクリプトが「直接実行された」ときだけ特定のコードを実行できる！
✔ import mymodule すると、if __name__ == ""__main__"" の部分は実行されず、mymodule.greet() だけが呼び出される！
✔ この仕組みを使うことで、モジュールを「直接実行するとき」と「インポートするとき」で処理を分けることができる！",5,3,
290,"以下のコードを実行すると、出力されるのは？

```python
import importlib

module_name = ""math""
math_module = importlib.import_module(module_name)

print(math_module.sqrt(25))
```python

1️⃣ 5.0
2️⃣ ""math""
3️⃣ エラーが発生する
4️⃣ None","1️⃣ 5.0","💡 importlib.import_module() を使うと、文字列で指定したモジュールを動的にインポートできる！
👉 通常の import math の代わりに、importlib.import_module(""math"") で math モジュールを読み込む！

🔹 コードの動作
```python
import importlib  # ✅ importlib をインポート

module_name = ""math""  # ✅ インポートするモジュール名を文字列で指定
math_module = importlib.import_module(module_name)  # ✅ 動的にインポート

print(math_module.sqrt(25))  # ✅ math.sqrt(25) と同じ
```python

✅ 出力
5.0
🔹 importlib.import_module() の仕組み

🔸 通常の import との違い
import math
print(math.sqrt(25))  # ✅ 通常のインポート
👉 通常の import math は、直接 math をインポートする！

🔸 importlib を使った動的インポート
import importlib

module_name = ""math""  # ✅ 文字列で指定
math_module = importlib.import_module(module_name)  # ✅ 動的にインポート

print(math_module.sqrt(25))  # ✅ math.sqrt(25) と同じ

👉 importlib.import_module(""math"") を使うと、math を「文字列で指定して」インポートできる！

📌 importlib.import_module() の使い方
記述	説明	例
importlib.import_module(""math"")	""math"" モジュールをインポート	math_module.sqrt(25)
importlib.import_module(""os"")	""os"" モジュールをインポート	os_module.getcwd()
✅ 例えば、ユーザー入力でインポートするモジュールを決めることも可能！
```python
import importlib

module_name = input(""インポートするモジュール名を入力: "")  # 例: ""math""
module = importlib.import_module(module_name)

print(module.sqrt(16))  # ""math"" を選んだ場合、4.0 が出力される
```python

📌 ユーザーが入力したモジュール名をインポートできる！ 💡

📌 まとめ
✔ importlib.import_module(""モジュール名"") を使うと、文字列で指定したモジュールをインポートできる！
✔ 通常の import とは異なり、動的にモジュールを読み込める！
✔ ユーザーの入力に応じてモジュールを決定する場合などに便利！",5,3,
291,"以下のコードを実行すると、出力されるのは？

```python
import pkgutil

package_name = ""collections""
modules = [mod.name for mod in pkgutil.iter_modules() if mod.name.startswith(package_name)]

print(modules)
```python
1️⃣ [""collections.abc""]
2️⃣ ""collections""
3️⃣ エラーが発生する
4️⃣ None","1️⃣ [""collections.abc""]","💡 pkgutil.iter_modules() を使うと、Python にインストールされているモジュールをリストとして取得できる！
👉 その中から ""collections"" で始まるモジュール名を探すと ""collections.abc"" が見つかる！

🔹 コードの動作
```python
import pkgutil  # ✅ パッケージ内のモジュールを検索するためのモジュール

package_name = ""collections""  # ✅ 探したいパッケージ名を指定
modules = [mod.name for mod in pkgutil.iter_modules() if mod.name.startswith(package_name)]  # ✅ 一致するモジュールをリストに格納

print(modules)  # ✅ 出力
```python

✅ 出力
[""collections.abc""]

🔹 pkgutil.iter_modules() の仕組み
🔸 全てのインストール済みモジュールをリスト化
```python
import pkgutil

modules = [mod.name for mod in pkgutil.iter_modules()]
print(modules)  # ✅ 全てのインストール済みモジュールがリストとして出力される
```python

📌 このコードを実行すると、システムにインストールされているモジュール一覧が取得できる！

🔸 特定のパッケージ内のモジュールを検索
```python
import pkgutil

package_name = ""collections""
modules = [mod.name for mod in pkgutil.iter_modules() if mod.name.startswith(package_name)]

print(modules)  # ✅ [""collections.abc""]
```python

💡 このコードは ""collections"" で始まるモジュールを検索する！
👉 ""collections.abc"" が見つかるので、リストに追加される！

📌 pkgutil.iter_modules() の使い方
記述	説明	例
pkgutil.iter_modules()	インストールされているモジュールを取得	[""os"", ""sys"", ""math"", ...]
pkgutil.iter_modules([""collections""])	""collections"" パッケージのモジュールを取得	[""collections.abc""]
mod.name.startswith(""collections"")	""collections"" で始まるモジュールのみ抽出	[""collections.abc""]
✅ 例えば、標準ライブラリのモジュールをすべてリスト化する
```python
import pkgutil

standard_modules = [mod.name for mod in pkgutil.iter_modules()]
print(standard_modules)  # ✅ インストール済みモジュールの一覧を取得
```python

📌 どのモジュールがインストールされているか確認できる！ 💡

📌 まとめ
✔ pkgutil.iter_modules() を使うと、インストールされているモジュールをリストとして取得できる！
✔ 特定のパッケージ名でフィルタリングすると、パッケージ内のモジュールを検索できる！
✔ 標準ライブラリやカスタムモジュールの一覧を取得するときに便利！",5,3,
292,"以下のコードを実行すると、出力されるのは？
ただし、example.txt というファイルは存在しないものとする。

```python
from pathlib import Path

path = Path(""example.txt"")
print(path.exists())
```python
1️⃣ True
2️⃣ False
3️⃣ ""example.txt""
4️⃣ エラーが発生する","2️⃣ False","💡 Path(""example.txt"").exists() は、指定したファイル example.txt が存在するかをチェックする！
👉 ファイルが存在しない場合、False を返す！

🔹 コードの動作
```python
from pathlib import Path  # ✅ pathlib をインポート

path = Path(""example.txt"")  # ✅ ""example.txt"" のパスを作成
print(path.exists())  # ✅ ファイルの存在を確認
```python

✅ 出力
False

📌 なぜ False なのか？

Path(""example.txt"") は、""example.txt"" というファイルのパスオブジェクトを作成するだけ
path.exists() は、そのパスが実際に存在するかをチェックする！
ファイルが存在しない場合、False を返す！

🔹 pathlib の基本操作
記述	説明	例
Path(""file.txt"")	""file.txt"" のパスオブジェクトを作成	path = Path(""file.txt"")
path.exists()	ファイルやディレクトリが存在するかチェック	True / False
path.is_file()	パスがファイルかどうかチェック	True / False
path.is_dir()	パスがディレクトリかどうかチェック	True / False

📌 例: ファイルの存在チェック

✅ ファイルがあるか確認
```python
from pathlib import Path

path = Path(""example.txt"")

if path.exists():
    print(""ファイルが存在します！"")
else:
    print(""ファイルは存在しません！"")
```python
📌 ファイルが存在すれば ""ファイルが存在します！"" を表示！

📌 まとめ
✔ Path(""example.txt"").exists() は、ファイルの存在をチェックする！
✔ ファイルが存在しない場合は False を返す！
✔ is_file() や is_dir() を使うと、ファイルかディレクトリかを判別できる！",5,3,
293,"以下のコードを実行すると、出力されるのは？
ただし、source.txt というファイルは存在しているものとする。

```python
import shutil

shutil.copy(""source.txt"", ""destination.txt"")

print(""コピー完了！"")
```python

1️⃣ ""コピー完了！""
2️⃣ エラーが発生する
3️⃣ ""source.txt"" の内容が ""destination.txt"" にコピーされる
4️⃣ 1️⃣ と 3️⃣ の両方","4️⃣ 1️⃣ と 3️⃣ の両方","💡 shutil.copy(""source.txt"", ""destination.txt"") を実行すると、source.txt の内容が destination.txt にコピーされる！
👉 コピーが完了すると、次の print(""コピー完了！"") が実行される！

🔹 コードの動作
```python
import shutil  # ✅ shutil モジュールをインポート

shutil.copy(""source.txt"", ""destination.txt"")  # ✅ ファイルをコピー

print(""コピー完了！"")  # ✅ コピーが完了したら表示
```python

✅ 出力
コピー完了！

📌 この時、source.txt の内容が destination.txt にそのままコピーされる！

🔹 shutil.copy() の基本
記述	説明	例
shutil.copy(src, dst)	src の内容を dst にコピー	shutil.copy(""source.txt"", ""backup.txt"")
shutil.copy2(src, dst)	copy() と同じだが、タイムスタンプもコピー	shutil.copy2(""source.txt"", ""backup.txt"")
shutil.move(src, dst)	src を dst に移動（ファイルを切り取り＆貼り付け）	shutil.move(""source.txt"", ""archive/"")

📌 shutil.copy() の動作

✅ ファイルをコピー

```python
import shutil

shutil.copy(""original.txt"", ""copy.txt"")  # ✅ original.txt を copy.txt にコピー
```python

✅ ディレクトリのコピー

```python
import shutil

shutil.copytree(""source_folder"", ""backup_folder"")  # ✅ フォルダごとコピー
```python

✅ ファイルの移動

```python
import shutil

shutil.move(""old.txt"", ""new_folder/"")  # ✅ old.txt を new_folder に移動
```python

📌 ファイルのバックアップや整理に便利！

📌 まとめ
✔ shutil.copy() は、指定したファイルを別の場所にコピーする！
✔ shutil.copy2() を使うと、ファイルのタイムスタンプも保持！
✔ shutil.move() を使えば、ファイルやフォルダの移動も可能！",5,3,
294,"以下のコードを実行すると、出力されるのは？

```python
import tempfile

with tempfile.TemporaryFile(mode=""w+"") as temp:
    temp.write(""一時データ"")
    temp.seek(0)
    print(temp.read())
```python

1️⃣ ""一時データ""
2️⃣ 一時ファイルのパスが表示される
3️⃣ エラーが発生する
4️⃣ None","1️⃣ ""一時データ""","💡 tempfile.TemporaryFile() を使うと、一時的なファイルを作成してデータを書き込める！
👉 mode=""w+"" を指定すると、ファイルを「書き込み & 読み取り」モードで開く！

🔹 コードの動作
```python
import tempfile  # ✅ tempfile モジュールをインポート

with tempfile.TemporaryFile(mode=""w+"") as temp:  # ✅ 一時ファイルを作成
    temp.write(""一時データ"")  # ✅ ファイルに書き込み
    temp.seek(0)  # ✅ 読み取り位置を先頭に戻す
    print(temp.read())  # ✅ ファイルの内容を出力
```python

✅ 出力
一時データ

🔹 tempfile.TemporaryFile() の動作
🔸 一時ファイルの作成
```python
import tempfile

with tempfile.TemporaryFile(mode=""w+"") as temp:
    temp.write(""テストデータ"")
    temp.seek(0)
    print(temp.read())  # ✅ ""テストデータ"" が表示される
```python

📌 with を使うことで、ファイルは自動的に閉じられる！

🔸 一時ファイルの名前を取得
```python
import tempfile

with tempfile.NamedTemporaryFile(delete=False) as temp:
    print(temp.name)  # ✅ 一時ファイルのフルパスを表示
```python

📌 一時ファイルの名前が必要な場合は NamedTemporaryFile() を使う！

🔸 一時ディレクトリの作成

```python
import tempfile

with tempfile.TemporaryDirectory() as temp_dir:
    print(f""一時ディレクトリ: {temp_dir}"")  # ✅ 一時ディレクトリのパスを表示
```python

📌 一時ディレクトリを作成する場合は TemporaryDirectory() を使う！

📌 まとめ
✔ tempfile.TemporaryFile() は、プログラム実行中のみ有効な一時ファイルを作成できる！
✔ NamedTemporaryFile(delete=False) を使うと、一時ファイルの名前を取得できる！
✔ TemporaryDirectory() を使うと、一時ディレクトリを作成できる！

",5,3,
295,"以下のコードを実行すると、出力されるのは？
ただし、スクリプトは python script.py --name 太郎 のように実行されるものとする。

```python
import argparse

parser = argparse.ArgumentParser()
parser.add_argument(""--name"", type=str, required=True)
args = parser.parse_args([""--name"", ""太郎""])

print(f""こんにちは、{args.name} さん！"")
```python

1️⃣ ""こんにちは、太郎 さん！""
2️⃣ エラーが発生する
3️⃣ ""--name 太郎""
4️⃣ None","1️⃣ ""こんにちは、太郎 さん！""","💡 argparse は、コマンドライン引数を簡単に処理できる標準ライブラリ！
👉 スクリプトを python script.py --name 太郎 のように実行すると、--name の値 ""太郎"" を取得できる！

✅ 「コマンドライン引数」って何？
Python のスクリプト（.py ファイル）を 実行するときに、追加で指定できるデータ のこと！

📌 例：普通の実行
```python
python script.py
```python
👉 何も引数を渡さない普通の実行方法

📌 例：引数を渡す
```python
python script.py --name 太郎
```python
👉 --name という引数を渡して、「太郎」というデータを受け取る！

🔹 argparse を実際に試してみよう！
💡 実際に簡単なコードを作ってみるのが、一番わかりやすいよ！

📌 まずは「基本の形」を知ろう
```python
import argparse

# ✅ 引数を処理する準備
parser = argparse.ArgumentParser()

# ✅ --name というオプションを定義
parser.add_argument(""--name"", type=str, required=True)

# ✅ コマンドライン引数を解析
args = parser.parse_args([""--name"", ""太郎""])

# ✅ 結果を表示
print(f""こんにちは、{args.name} さん！"")
```python

✅ 実行結果
こんにちは、太郎 さん！

📌 まとめ
✅ argparse は「コマンドラインからデータを受け取るための仕組み」
✅ parser.add_argument(""--name"", type=str, required=True) で、引数を定義する
✅ args = parser.parse_args([""--name"", ""太郎""]) で、引数を取得する！


*****もっと詳しく*****

🔹 argparse の仕組み
🔸 通常のスクリプト実行
```python
python script.py --name 太郎
```python
📌 --name の後に ""太郎"" を渡すと、args.name に ""太郎"" が入る！

🔸 コマンドライン引数の処理
```python
import argparse

parser = argparse.ArgumentParser()
parser.add_argument(""--age"", type=int, required=True)  # ✅ --age 引数を定義
args = parser.parse_args([""--age"", ""30""])  # ✅ コマンドライン引数を解析

print(f""あなたは {args.age} 歳です！"")
```python
📌 python script.py --age 30 のように実行すると、args.age に 30 が入る！

✅ 出力

あなたは 30 歳です！
🔸 デフォルト値を設定

```python
parser.add_argument(""--city"", type=str, default=""東京"")  # ✅ --city にデフォルト値を設定
```python

📌 引数が指定されなかった場合は ""東京"" になる！

📌 argparse の基本
記述	説明	例
parser.add_argument(""--name"", type=str, required=True)	文字列型の --name 引数を定義	--name 太郎
parser.add_argument(""--age"", type=int, default=20)	整数型の --age 引数を定義（デフォルト値あり）	--age 30
args = parser.parse_args()	コマンドライン引数を解析	-
print(args.name)	--name の値を取得	""太郎""

📌 まとめ
✔ argparse を使うと、コマンドライン引数を簡単に処理できる！
✔ add_argument() を使って、引数の型や必須/省略可能を設定できる！
✔ parse_args() を呼び出すと、引数が args.変数名 で取得できる！",5,3,
296,"以下のコードを実行すると、出力されるのは？
ただし、環境によって ""ls"" コマンドは ""dir"" に置き換えられる場合がある。

```python
import subprocess

result = subprocess.run([""ls""], capture_output=True, text=True)
print(result.stdout)
```python
1️⃣ 現在のディレクトリ内のファイル一覧が表示される
2️⃣ エラーが発生する
3️⃣ [""ls""] がそのまま出力される
4️⃣ None","1️⃣ 現在のディレクトリ内のファイル一覧が表示される","💡 subprocess.run() を使うと、Python から外部コマンド（ターミナル/コマンドプロンプトのコマンド）を実行できる！
👉 このコードでは ls コマンドを実行して、現在のディレクトリ内のファイル一覧を取得する！

🔹 コードの動作
```python
import subprocess  # ✅ subprocess モジュールをインポート

result = subprocess.run([""ls""], capture_output=True, text=True)  # ✅ ""ls"" コマンドを実行し、出力を取得
print(result.stdout)  # ✅ コマンドの出力を表示
```python

✅ 出力（例）
file1.txt
file2.py
directory/

📌 このように、現在のフォルダ内のファイル・フォルダが一覧表示される！

🔹 subprocess.run() の基本
記述	説明	例
subprocess.run([""ls""])	""ls"" コマンドを実行	ファイル一覧を表示
subprocess.run([""dir""], shell=True)	""dir"" コマンドを実行（Windows用）	ファイル一覧を表示
subprocess.run([""python"", ""script.py""])	""script.py"" を実行	Python スクリプトの実行
result = subprocess.run([""ls""], capture_output=True, text=True)	ls コマンドの結果を変数に格納	result.stdout で出力を取得

🔹 capture_output=True の意味

💡 通常、subprocess.run() でコマンドを実行すると、出力は直接ターミナルに表示される。
👉 capture_output=True を指定すると、出力を result.stdout に保存できる！

📌 例：ターミナルに直接出力

```python
import subprocess

subprocess.run([""ls""])  # ✅ 出力は直接ターミナルに表示される
```python

📌 例：出力を変数に格納

```python
import subprocess

result = subprocess.run([""ls""], capture_output=True, text=True)  # ✅ 出力を変数に保存
print(""取得した出力:"", result.stdout)  # ✅ 変数から出力を取得
```python

✅ この場合、出力を Python 内で処理できる！

📌 subprocess.run() の応用
🔸 コマンドの実行結果を Python 内で使う

```python
import subprocess

result = subprocess.run([""ls""], capture_output=True, text=True)
files = result.stdout.split(""\n"")  # ✅ ファイル名のリストを取得
print(files)  # ✅ ['file1.txt', 'file2.py', 'directory/', '']
```python

📌 split(""\n"") で改行区切りのリストに変換できる！

📌 まとめ
✔ subprocess.run() を使うと、Python から外部コマンドを実行できる！
✔ capture_output=True を指定すると、コマンドの出力を Python で処理できる！
✔ Windows の場合は [""dir""], shell=True を使うと ""ls"" の代わりになる！",5,3,
297,"以下のコードを実行すると、出力されるのは？

```python
import logging

logging.basicConfig(level=logging.INFO)
logging.info(""これは情報ログです"")
```python

1️⃣ ""INFO:root:これは情報ログです""
2️⃣ ""これは情報ログです""
3️⃣ エラーが発生する
4️⃣ None","1️⃣ ""INFO:root:これは情報ログです""","💡 logging モジュールを使うと、プログラムの実行状況を記録（ログ出力）できる！
👉 デフォルトでは INFO レベルのログは表示されないが、basicConfig(level=logging.INFO) を指定すると INFO ログも出力される！

🔹 コードの動作
```python
import logging  # ✅ logging モジュールをインポート

logging.basicConfig(level=logging.INFO)  # ✅ INFO レベルのログを表示する設定
logging.info(""これは情報ログです"")  # ✅ INFO レベルのログを記録
```python

✅ 出力
INFO:root:これは情報ログです

📌 INFO:root: の部分は、ログのレベル（INFO）とロガー名（root）を示している！

🔹 logging の基本
記述	説明	例
logging.debug(""デバッグ情報"")	デバッグ用 のログを記録	DEBUG:root:デバッグ情報
logging.info(""情報ログ"")	通常の情報 を記録	INFO:root:情報ログ
logging.warning(""警告メッセージ"")	警告レベルのログ を記録	WARNING:root:警告メッセージ
logging.error(""エラーメッセージ"")	エラーが発生 したときのログ	ERROR:root:エラーメッセージ
logging.critical(""致命的エラー"")	重大なエラー のログを記録	CRITICAL:root:致命的エラー

🔹 basicConfig() でログの設定
💡 logging.basicConfig() を使うと、ログの設定を変更できる！

📌 ログレベルを INFO 以上にする

```python
logging.basicConfig(level=logging.INFO)  # ✅ INFO 以上のログを表示
```python

📌 ログのフォーマットを指定

```python
logging.basicConfig(
    level=logging.INFO,
    format=""%(asctime)s - %(levelname)s - %(message)s""
)
```python

✅ 出力
2024-02-07 12:34:56 - INFO - これは情報ログです

📌 日時を含めたログ出力も可能！

📌 まとめ
✔ logging を使うと、プログラムの動作ログを記録できる！
✔ basicConfig(level=logging.INFO) を指定すると、INFO 以上のログが出力される！
✔ ログのレベル（DEBUG, INFO, WARNING, ERROR, CRITICAL）を使い分ける！

",5,3,
298,"以下のコードを実行すると、出力されるのは？
ただし、config.ini というファイルには以下の内容が書かれているものとする。

[settings]
username = admin
password = secret

```python
import configparser

config = configparser.ConfigParser()
config.read(""config.ini"")

print(config[""settings""][""username""])
```python

1️⃣ ""admin""
2️⃣ ""secret""
3️⃣ エラーが発生する
4️⃣ None","1️⃣ ""admin""","💡 configparser を使うと、.ini 形式の設定ファイルを簡単に読み込める！
👉 このコードでは config.ini の [settings] セクションから ""username"" の値を取得している！

🔹 コードの動作
```python
import configparser  # ✅ configparser モジュールをインポート

config = configparser.ConfigParser()  # ✅ 設定ファイルのパーサーを作成
config.read(""config.ini"")  # ✅ 設定ファイルを読み込む

print(config[""settings""][""username""])  # ✅ ""username"" の値を取得
```python

✅ 出力
admin

📌 config.ini 内の [settings] セクションにある ""username"" の値 ""admin"" が表示される！

🔹 configparser の基本
記述	説明	例
config.read(""config.ini"")	設定ファイルを読み込む	config.ini を読み込む
config[""セクション名""][""キー名""]	指定したキーの値を取得	config[""settings""][""username""]
config.get(""セクション名"", ""キー名"")	get() を使って値を取得	config.get(""settings"", ""password"")
config.sections()	すべてのセクションを取得	[""settings""]

📌 config.ini ファイルの例
📌 INI ファイルは [セクション] と キー = 値 の形式で記述する！v
```python
[settings]
username = admin
password = secret

[database]
host = localhost
port = 3306
```python
📌 この config.ini を Python で読み込む！

```python
import configparser

config = configparser.ConfigParser()
config.read(""config.ini"")

print(config[""settings""][""username""])  # ✅ ""admin""
print(config[""database""][""host""])  # ✅ ""localhost""
```python

✅ 出力
admin
localhost

📌 まとめ
✔ configparser を使うと、設定ファイル (.ini 形式) を簡単に扱える！
✔ config.read(""config.ini"") で設定ファイルを読み込む！
✔ config[""セクション名""][""キー名""] で値を取得できる！
✔ 設定ファイルを使うと、Python のコードを変更せずに設定を切り替えられる！",5,3,
299,"以下のコードを実行すると、出力されるのは？

```python
import threading
import time

def print_message():
    time.sleep(2)
    print(""スレッド終了"")

thread = threading.Thread(target=print_message)
thread.start()

print(""メインスレッド終了"")
```python

1️⃣ ""メインスレッド終了"" の後に ""スレッド終了"" が表示される
2️⃣ ""スレッド終了"" の後に ""メインスレッド終了"" が表示される
3️⃣ ""スレッド終了"" だけが表示される
4️⃣ エラーが発生する","1️⃣ ""メインスレッド終了"" の後に ""スレッド終了"" が表示される
","💡 threading.Thread() を使うと、Python で並列処理（マルチスレッド）ができる！
👉 このコードでは、print_message() を別のスレッドで実行することで、メインスレッドと並行処理している！

🔹 コードの動作

```python
import threading  # ✅ threading モジュールをインポート
import time

def print_message():  # ✅ スレッドで実行する関数
    time.sleep(2)  # ✅ 2秒待機
    print(""スレッド終了"")  # ✅ メッセージを表示

# ✅ スレッドを作成して実行
thread = threading.Thread(target=print_message)
thread.start()

print(""メインスレッド終了"")  # ✅ メインスレッドの処理を実行
```python

✅ 出力
メインスレッド終了
スレッド終了

📌 thread.start() によって print_message() がバックグラウンドで動き、メインスレッドはそのまま実行を続ける！ 📌 メインスレッドが先に ""メインスレッド終了"" を表示し、2秒後に ""スレッド終了"" が出力される！

🔹 threading.Thread() の基本
記述	説明	例
threading.Thread(target=関数)	新しいスレッドを作成	thread = threading.Thread(target=func)
thread.start()	スレッドを開始	thread.start()
thread.join()	メインスレッドが終了する前にスレッドの完了を待つ	thread.join()
📌 join() を使うと？
📌 join() を使うと、スレッドの処理が終わるまで待つ！

```python
import threading
import time

def print_message():
    time.sleep(2)
    print(""スレッド終了"")

thread = threading.Thread(target=print_message)
thread.start()
thread.join()  # ✅ スレッドの完了を待つ！

print(""メインスレッド終了"")
```python

✅ 出力
スレッド終了
メインスレッド終了

📌 thread.join() を入れることで、スレッドが終了するまでメインスレッドの処理が止まる！

📌 まとめ
✔ threading.Thread() を使うと、Python でマルチスレッド処理ができる！
✔ thread.start() でスレッドを開始すると、メインスレッドと並行して動作する！
✔ thread.join() を使うと、スレッドが完了するまでメインスレッドを待機させられる！

",5,3,
300,"以下のコードを実行すると、出力されるのは？

```python
import multiprocessing
import time

def worker():
    time.sleep(1)
    print(""プロセス終了"")

if __name__ == ""__main__"":
    process = multiprocessing.Process(target=worker)
    process.start()

    print(""メインプロセス終了"")
```python

1️⃣ ""メインプロセス終了"" の後に ""プロセス終了"" が表示される
2️⃣ ""プロセス終了"" の後に ""メインプロセス終了"" が表示される
3️⃣ ""プロセス終了"" だけが表示される
4️⃣ エラーが発生する","1️⃣ ""メインプロセス終了"" の後に ""プロセス終了"" が表示される","💡 multiprocessing.Process() を使うと、Python でマルチプロセス（並列処理）ができる！
👉 スレッド (threading) と違い、プロセスごとに独立したメモリ空間で処理が行われる！

🔹 コードの動作
```python
import multiprocessing  # ✅ multiprocessing モジュールをインポート
import time

def worker():  # ✅ 別プロセスで実行する関数
    time.sleep(1)  # ✅ 1秒待機
    print(""プロセス終了"")  # ✅ メッセージを表示

if __name__ == ""__main__"":  # ✅ Windows の場合、マルチプロセス実行に必須
    process = multiprocessing.Process(target=worker)  # ✅ プロセスを作成
    process.start()  # ✅ プロセスを開始

    print(""メインプロセス終了"")  # ✅ メインプロセスの処理を実行
```python

✅ 出力
メインプロセス終了
プロセス終了

📌 process.start() によって worker() がバックグラウンドで動き、メインプロセスはそのまま実行を続ける！
📌 メインプロセスが先に ""メインプロセス終了"" を表示し、1秒後に ""プロセス終了"" が出力される！

🔹 multiprocessing.Process() の基本
記述	説明	例
multiprocessing.Process(target=関数)	新しいプロセスを作成	process = multiprocessing.Process(target=func)
process.start()	プロセスを開始	process.start()
process.join()	メインプロセスが終了する前にプロセスの完了を待つ	process.join()

📌 join() を使うと？
📌 join() を使うと、プロセスの処理が終わるまでメインプロセスが待機する！
```python
import multiprocessing
import time

def worker():
    time.sleep(1)
    print(""プロセス終了"")

if __name__ == ""__main__"":
    process = multiprocessing.Process(target=worker)
    process.start()
    process.join()  # ✅ プロセスの完了を待つ！

    print(""メインプロセス終了"")
```python

✅ 出力
メインプロセス終了

📌 process.join() を入れることで、プロセスが終了するまでメインプロセスの処理が止まる！

📌 threading.Thread() と multiprocessing.Process() の違い
機能	threading.Thread()	multiprocessing.Process()
メモリ共有	同じメモリ空間 を共有	別々のメモリ空間 を使う
並列処理	マルチスレッド	マルチプロセス
join() の動作	スレッドの完了を待つ	プロセスの完了を待つ
使い方	軽い並列処理に適している	CPU 負荷が高い処理に適している
📌 CPU 負荷の高い処理なら multiprocessing、軽い並列処理なら threading を使おう！

📌 まとめ
✔ multiprocessing.Process() を使うと、Python でマルチプロセス処理ができる！
✔ process.start() でプロセスを開始すると、メインプロセスと並行して動作する！
✔ process.join() を使うと、プロセスが完了するまでメインプロセスを待機させられる！
✔ threading.Thread() はメモリ共有、multiprocessing.Process() は独立したプロセスで動作する！

",5,3,
301,"以下のコードを実行すると、出力されるのは？

```python
import time
import functools

@functools.lru_cache(maxsize=2)
def slow_function(x):
    time.sleep(2)  # ✅ 2秒間スリープ
    return x * 2

print(slow_function(3))  # ✅ 計算される
print(slow_function(3))  # ✅ キャッシュから取得
```python

1️⃣ 最初の呼び出しは 2 秒かかり、次の呼び出しはすぐに 6 が表示される
2️⃣ どちらの呼び出しも 2 秒かかる
3️⃣ エラーが発生する
4️⃣ 何も出力されない","1️⃣ 最初の呼び出しは 2 秒かかり、次の呼び出しはすぐに 6 が表示される","💡 functools.lru_cache() を使うと、関数の実行結果をキャッシュ（保存）して、同じ計算を繰り返さないようにできる！
👉 2回目以降の呼び出しでは、キャッシュされた値を返すので、計算が高速になる！

🔹 コードの動作
```python
import time
import functools

@functools.lru_cache(maxsize=2)  # ✅ 最大2個までキャッシュ
def slow_function(x):
    time.sleep(2)  # ✅ 2秒待機（重い処理をシミュレーション）
    return x * 2

print(slow_function(3))  # ✅ 最初の呼び出し → 計算に 2 秒かかる
print(slow_function(3))  # ✅ キャッシュから取得 → 即座に 6 を表示
```python
✅ 出力
（2秒待機）
6  # ✅ 計算された値
6  # ✅ キャッシュされた値

📌 1回目の slow_function(3) は2秒かかるが、2回目はキャッシュされているので即座に 6 を返す！

🔹 lru_cache の仕組み
📌 lru_cache() は、指定した個数 (maxsize) まで過去の計算結果を保存する！
📌 同じ引数で関数を呼び出した場合、再計算せずにキャッシュを利用する！

🔸 キャッシュの動作例
```python
import functools
import time

@functools.lru_cache(maxsize=3)  # ✅ キャッシュの最大サイズを3に設定
def compute(x):
    time.sleep(1)
    return x * 2

print(compute(1))  # ✅ 1秒待機 → 2
print(compute(2))  # ✅ 1秒待機 → 4
print(compute(3))  # ✅ 1秒待機 → 6
print(compute(1))  # ✅ キャッシュから取得 → 即座に 2
print(compute(4))  # ✅ 1秒待機 → 8（最も古いキャッシュ（2）が削除される）
print(compute(2))  # ✅ キャッシュから削除されたため再計算
```python
📌 ステップごとの動き
1️⃣ compute(1) を実行
📌 キャッシュなし → 計算が必要

compute(1) が初めて呼び出されたので、計算が必要
1 * 2 = 2 を計算して返す

キャッシュに追加
キャッシュ: {1: 2}

✅ 出力
（1秒待機） 2

2️⃣ compute(2) を実行
📌 キャッシュなし → 計算が必要

compute(2) も初めて呼び出されたので、計算が必要
2 * 2 = 4 を計算して返す

キャッシュに追加
キャッシュ: {1: 2, 2: 4}

✅ 出力
（1秒待機） 4

3️⃣ compute(3) を実行
📌 キャッシュなし → 計算が必要

compute(3) も初めて呼び出されたので、計算が必要
3 * 2 = 6 を計算して返す
キャッシュに追加
キャッシュ: {1: 2, 2: 4, 3: 6}

✅ 出力
（1秒待機） 6

4️⃣ compute(1) をもう一度実行
📌 キャッシュあり → 即座に返す

compute(1) はすでにキャッシュされている！
計算せずにキャッシュの値 2 を返す

キャッシュ: {1: 2, 2: 4, 3: 6}

✅ 出力
2  # キャッシュから取得（計算なし）

5️⃣ compute(4) を実行
📌 キャッシュなし → 計算が必要

compute(4) は初めて呼び出されたので、計算が必要
4 * 2 = 8 を計算して返す
キャッシュに追加 → maxsize=3 を超えたので、最も古い compute(2) が削除される

キャッシュ: {1: 2, 3: 6, 4: 8}  # 👈 `2: 4` が削除される！

✅ 出力
（1秒待機） 8

6️⃣ compute(2) をもう一度実行
📌 キャッシュから削除されたので再計算

compute(2) は前にキャッシュされていたが、削除されている
もう一度 2 * 2 = 4 を計算する
キャッシュに追加 → 最も古い compute(1) が削除される
キャッシュ: {3: 6, 4: 8, 2: 4}  # 👈 `1: 2` が削除される！

✅ 出力
（1秒待機） 4  # キャッシュから削除されていたので再計算

✅ 出力
（1秒待機） 2
（1秒待機） 4
（1秒待機） 6
2  # ✅ キャッシュから取得
（1秒待機） 8  # ✅ キャッシュから溢れたので再計算
（1秒待機） 4  # ✅ 再計算
📌 まとめ
✔ lru_cache() は最大 maxsize 件までキャッシュする
✔ キャッシュがいっぱいになると、最も古いデータから削除される（LRU = Least Recently Used）
✔ キャッシュにあるデータは計算せず即座に返せるので、処理が速くなる！



📌 まとめ
✔ functools.lru_cache() を使うと、関数の計算結果をキャッシュできる！
✔ 同じ引数で関数を呼び出した場合、キャッシュされた値を即座に返す！
✔ maxsize を指定すると、保存できるキャッシュの数を制限できる！（デフォルトは 128）
✔ CPU負荷の高い計算を効率化するのに便利！",5,3,
302,"以下のコードを実行すると、出力されるのは？
```python
class Animal:
    def __init__(self, name):
        self.name = name

    def speak(self):
        return f""{self.name} は鳴きます！""

dog = Animal(""犬"")
print(dog.speak())
```python
1️⃣ ""犬 は鳴きます！""
2️⃣ ""犬 は吠えます！""
3️⃣ None
4️⃣ エラーが発生する","1️⃣ ""犬 は鳴きます！""","✅ クラス Animal の __init__ メソッド
```python
def __init__(self, name):
    self.name = name
```python
📌 オブジェクト（dog）が作られるときに name を受け取り、それを self.name に格納！
📌 つまり、dog = Animal(""犬"") を実行すると self.name = ""犬"" になる！

✅ speak メソッドの動作
def speak(self):
    return f""{self.name} は鳴きます！""

📌 dog.speak() を呼び出すと、self.name に ""犬"" が入っているため、 📌 ""犬 は鳴きます！"" を返す！

📌 まとめ
✔ クラスは「設計図」、オブジェクトは「実体化されたデータ」
✔ __init__ メソッドで、オブジェクトの初期値を設定できる！
✔ self を使うと、クラスの中でオブジェクトのデータを扱える！",4,1,
303,"以下のコードを実行すると、出力されるのは？
```python
class Counter:
    count = 0  # クラス変数

    def __init__(self):
        Counter.count += 1

    def get_count(self):
        return Counter.count

a = Counter()
b = Counter()
c = Counter()

print(a.get_count())
```python
1️⃣ 1
2️⃣ 2
3️⃣ 3
4️⃣ エラーが発生する","3️⃣ 3","このコードでは、クラス変数 count を使って、オブジェクトの生成回数をカウント しています。

✅ クラス変数 count とは？
class Counter:
    count = 0  # ✅ クラス変数

📌 count はクラス全体で共有される変数！
📌 インスタンス（オブジェクト）ごとに別の値を持つのではなく、クラス全体で同じ count を参照する！

✅ __init__ の処理
def __init__(self):
    Counter.count += 1

📌 新しい Counter オブジェクトが作られるたびに、count を 1 増やす！

✅ オブジェクトの作成
a = Counter()  # ✅ `count` が 1 になる
b = Counter()  # ✅ `count` が 2 になる
c = Counter()  # ✅ `count` が 3 になる

📌 Counter のオブジェクトを 3 回作成したので、 count は 3 になる！

✅ get_count() メソッドの処理
```python
def get_count(self):
    return Counter.count  # ✅ クラス変数 `count` の値を返す
```python
📌 a.get_count() を実行すると、Counter.count の現在の値 (3) を返す！

📌 まとめ
✔ クラス変数は、すべてのインスタンス（オブジェクト）で共有される！
✔ インスタンスが生成されるたびに Counter.count が増える！
✔ get_count() は Counter.count の現在の値（3）を返す！",4,2,
304,"以下のコードを実行すると、出力されるのは？
```python
class Sample:
    def __init__(self, value):
        self.__value = value  # ✅ 非公開変数（プライベート変数）

    def get_value(self):
        return self.__value

obj = Sample(10)
print(obj.get_value())
```python
1️⃣ 10
2️⃣ None
3️⃣ エラーが発生する
4️⃣ __value","1️⃣ 10","このコードでは、「プライベート変数（非公開変数）」 について学びます！

✅ __value は「非公開変数（プライベート変数）」
self.__value = value  # ✅ `__`（アンダースコア2つ）で始まると非公開変数

📌 クラスの外から直接アクセスできない変数！
📌 ただし、クラス内のメソッド (get_value) を使えばアクセスできる！

✅ get_value() メソッド
```python
def get_value(self):
    return self.__value  # ✅ 非公開変数 `__value` を返す
```python
📌 このメソッドを使うことで、__value の値を取得できる！

✅ オブジェクトの作成
obj = Sample(10)  # ✅ `__value = 10` が設定される

📌 obj というオブジェクトが作られ、__value に 10 が格納される！

✅ print(obj.get_value()) の動作
print(obj.get_value())  # ✅ `10` が表示される！

📌 get_value() を呼び出すと self.__value の値（10）が返される！

📌 まとめ
✔ __変数名 とすると、その変数は「非公開（プライベート変数）」になる！
✔ プライベート変数は、クラスの外部から直接アクセスできない！
✔ get_value() のような「ゲッターメソッド」を使うと、値を取得できる！",4,2,
305,"以下のコードを実行すると、出力されるのは？
```python
class Parent:
    def show(self):
        return ""親クラスのメソッド""

class Child(Parent):
    pass

obj = Child()
print(obj.show())
```python
1️⃣ ""親クラスのメソッド""
2️⃣ ""子クラスのメソッド""
3️⃣ エラーが発生する
4️⃣ None","1️⃣ ""親クラスのメソッド""","このコードでは、「クラスの継承」 について学びます！ 🚀

✅ 継承とは？
📌 class 子クラス(親クラス): とすることで、親クラスの機能を引き継ぐことができる！
📌 子クラスは親クラスのメソッドをそのまま使える！

✅ コードの動作
📌 Parent クラス（親クラス）
```python
class Parent:
    def show(self):
        return ""親クラスのメソッド""
```python
📌 show() メソッドを持つクラス

📌 Child クラス（子クラス）
```python
class Child(Parent):
    pass
```python
📌 Parent を継承しているが、新しい処理は追加されていない！
📌 pass は「何もしない」ことを意味する！

✅ オブジェクトの作成
```python
obj = Child()
```python
📌 Child クラスのオブジェクトを作成！
📌 Child は Parent を継承しているので、Parent のメソッドをそのまま使える！

✅ print(obj.show()) の動作
```python
print(obj.show())  # ✅ ""親クラスのメソッド""
```python
📌 Child クラスには show() がない！でも Parent から継承しているので、Parent.show() を実行する！

✅ 結果
親クラスのメソッド

📌 継承によって、子クラスでも親クラスのメソッドを呼び出せる！

📌 まとめ
✔ クラスの継承 (class 子クラス(親クラス):) を使うと、親クラスのメソッドをそのまま利用できる！
✔ 子クラスに show() メソッドがない場合、親クラスの show() メソッドが呼ばれる！
✔ pass を使うことで、子クラスに特に変更を加えずに継承だけできる！

",4,2,
306,"以下のコードを実行すると、出力されるのは？
```PYTHON
class Parent:
    def show(self):
        return ""親クラスのメソッド""

class Child(Parent):
    def show(self):
        return ""子クラスのメソッド""

obj = Child()
print(obj.show())
```PYTHON
1️⃣ ""親クラスのメソッド""
2️⃣ ""子クラスのメソッド""
3️⃣ エラーが発生する
4️⃣ None","2️⃣ ""子クラスのメソッド""","このコードでは、「オーバーライド（メソッドの上書き）」 について学びます！ 🚀

✅ オーバーライド（メソッドの上書き）とは？
📌 子クラスで親クラスと同じ名前のメソッドを定義すると、親クラスのメソッドを上書きできる！
📌 子クラスのメソッドが優先され、親クラスのメソッドは実行されない！

✅ コードの動作
📌 Parent クラス（親クラス）
```PYTHON
class Parent:
    def show(self):
        return ""親クラスのメソッド""
```PYTHON
📌 show() メソッドを持つクラス

📌 Child クラス（子クラス）
```PYTHON
class Child(Parent):
    def show(self):
        return ""子クラスのメソッド""
```PYTHON
📌 show() メソッドを「親クラスと同じ名前」で定義
📌 これにより、「親クラスの show() メソッド」をオーバーライド（上書き）！
📌 子クラス Child では、親クラスの show() は使われず、子クラスの show() が実行される！

✅ オブジェクトの作成
```PYTHON
obj = Child()
```PYTHON
📌 Child クラスのオブジェクトを作成！
📌 Child クラスは show() を独自に定義しているため、それが使われる！

✅ print(obj.show()) の動作
```PYTHON
print(obj.show())  # ✅ ""子クラスのメソッド""
```PYTHON
📌 子クラス Child の show() が実行される！
📌 親クラスの show() はオーバーライドされているため、呼び出されない！

✅ 結果
子クラスのメソッド

📌 まとめ
✔ 「オーバーライド」とは、親クラスのメソッドを子クラスで上書きすること！
✔ 子クラスに同じ名前のメソッドを定義すると、親クラスのメソッドは無視される！
✔ Child クラスの show() が優先されるため、 ""子クラスのメソッド"" が出力される！

",5,2,
307,"以下のコードを実行すると、出力されるのは？
```PYTHON
class Parent:
    def show(self):
        return ""親クラスのメソッド""

class Child(Parent):
    def show(self):
        return super().show() + "" → 子クラスの処理""

obj = Child()
print(obj.show())
```PYTHON
1️⃣ ""親クラスのメソッド → 子クラスの処理""
2️⃣ ""子クラスの処理""
3️⃣ ""親クラスのメソッド""
4️⃣ エラーが発生する

","1️⃣ ""親クラスのメソッド → 子クラスの処理""","このコードでは、super() を使って「親クラスのメソッドを呼び出す」方法 を学びます！ 🚀

✅ super() とは？
📌 super() を使うと、子クラスの中で親クラスのメソッドを呼び出せる！
📌 オーバーライドしたメソッドの中で、親クラスのメソッドも実行できる！

✅ コードの動作
📌 Parent クラス（親クラス）
```PYTHON
class Parent:
    def show(self):
        return ""親クラスのメソッド""
```PYTHON
📌 show() メソッドを持つクラス！

📌 Child クラス（子クラス）
```PYTHON
class Child(Parent):
    def show(self):
        return super().show() + "" → 子クラスの処理""
```PYTHON
📌 super().show() を使って、Parent クラスの show() を呼び出す！
📌 その後 "" → 子クラスの処理"" を追加！

✅ オブジェクトの作成
obj = Child()
📌 Child クラスのオブジェクトを作成！

✅ print(obj.show()) の動作
print(obj.show())  # ✅ ""親クラスのメソッド → 子クラスの処理""

📌 super().show() によって Parent.show() が実行される！
📌 その結果 ""親クラスのメソッド"" が返る！
📌 さらに "" → 子クラスの処理"" を追加して出力！

✅ 結果
親クラスのメソッド → 子クラスの処理

📌 まとめ
✔ super() を使うと、親クラスのメソッドを呼び出せる！
✔ 子クラスでメソッドをオーバーライドしても、super() を使えば親クラスの処理を継続できる！
✔ super().メソッド名() の形式で親クラスのメソッドを実行！

",4,2,
308,"以下のコードを実行すると、出力されるのは？
```python
class A:
    def __init__(self):
        print(""Aのコンストラクタ"")

class B(A):
    def __init__(self):
        super().__init__()
        print(""Bのコンストラクタ"")

obj = B()
```python

1️⃣
Aのコンストラクタ
Bのコンストラクタ

2️⃣
Bのコンストラクタ

3️⃣
Aのコンストラクタ

4️⃣ エラーが発生する","1️⃣
Aのコンストラクタ
Bのコンストラクタ","このコードでは、コンストラクタの「継承」と super() の動作 について学びます！🚀

✅ コンストラクタとは？
📌 __init__() は、オブジェクトが作成されるときに自動的に実行される特別なメソッド！
📌 クラスが継承されると、親クラスの __init__() も呼び出せる！

✅ コードの動作
📌 A クラス（親クラス）
```python
class A:
    def __init__(self):
        print(""Aのコンストラクタ"")
```python
📌 __init__() により、オブジェクトが作成されると ""Aのコンストラクタ"" を出力する！

📌 B クラス（子クラス）
```python
class B(A):
    def __init__(self):
        super().__init__()
        print(""Bのコンストラクタ"")
```python
📌 super().__init__() を使って、親クラス (A) の __init__() を呼び出す！
📌 その後 ""Bのコンストラクタ"" を出力！

✅ オブジェクトの作成
```python
obj = B()
```python
📌 B クラスのインスタンス obj を作成すると…

super().__init__() によって A の __init__() が実行される！
""Aのコンストラクタ"" が出力される！
次に B の __init__() の処理が実行される！
""Bのコンストラクタ"" が出力される！

✅ 結果
Aのコンストラクタ
Bのコンストラクタ

📌 まとめ
✔ super().__init__() を使うと、親クラスのコンストラクタも実行される！
✔ 子クラスの __init__() では、親クラスの __init__() を明示的に呼び出さないと実行されない！
✔ 子クラスの処理は、super().__init__() の後に続く！

",4,2,
309,"以下のコードを実行すると、出力されるのは？
```python
class A:
    def __init__(self, x):
        self.x = x
        print(f""Aのコンストラクタ: x = {self.x}"")

class B(A):
    def __init__(self, x, y):
        super().__init__(x)
        self.y = y
        print(f""Bのコンストラクタ: y = {self.y}"")

obj = B(10, 20)
```python

1️⃣
Aのコンストラクタ: x = 10
Bのコンストラクタ: y = 20

2️⃣
Bのコンストラクタ: y = 20
Aのコンストラクタ: x = 10

3️⃣
Aのコンストラクタ: x = 20
Bのコンストラクタ: y = 10

4️⃣ エラーが発生する

","1️⃣
Aのコンストラクタ: x = 10
Bのコンストラクタ: y = 20","このコードでは、super() を使って親クラスのコンストラクタに引数を渡す方法 を学びます！🚀

✅ コードの動作
📌 A クラス（親クラス）
```python
class A:
    def __init__(self, x):
        self.x = x
        print(f""Aのコンストラクタ: x = {self.x}"")
```python
📌 A のコンストラクタは x を受け取る！
📌 self.x = x で x の値をオブジェクトに保存！
📌 print(f""Aのコンストラクタ: x = {self.x}"") によって x の値を表示！

📌 B クラス（子クラス）
```python
class B(A):
    def __init__(self, x, y):
        super().__init__(x)  # ✅ `A` のコンストラクタを実行！
        self.y = y
        print(f""Bのコンストラクタ: y = {self.y}"")
```python

📌 B のコンストラクタは x と y の2つの引数を受け取る！
📌 super().__init__(x) によって A のコンストラクタが実行される！
📌 その後 self.y = y で y の値を保存し、表示する！

✅ オブジェクトの作成
```python
obj = B(10, 20)
```python
📌 B(10, 20) のインスタンスを作成すると…

super().__init__(x) により A.__init__(10) が実行される！
""Aのコンストラクタ: x = 10"" が出力される！
その後 B の __init__() の処理が続く！
""Bのコンストラクタ: y = 20"" が出力される！

✅ 結果
Aのコンストラクタ: x = 10
Bのコンストラクタ: y = 20

📌 まとめ
✔ super().__init__(引数) を使うと、親クラスのコンストラクタに引数を渡せる！
✔ 親クラスの __init__() が実行された後に、子クラスの __init__() の処理が続く！
✔ self.x や self.y でオブジェクトの属性を保存できる！

",4,2,
310,"以下のコードを実行すると、出力されるのは？
```python
class A:
    def __init__(self):
        print(""Aのコンストラクタ"")

class B(A):
    pass

obj = B()
```python

1️⃣ Aのコンストラクタ

2️⃣ 何も出力されない

3️⃣ エラーが発生する

4️⃣ Bのコンストラクタ
","1️⃣ Aのコンストラクタ","このコードでは、pass を使った継承時の動作 について学びます！🚀

✅ コードの動作
📌 A クラス（親クラス）
```python
class A:
    def __init__(self):
        print(""Aのコンストラクタ"")
```python

📌 A のコンストラクタ __init__() は、オブジェクトが作成されると ""Aのコンストラクタ"" を出力！

📌 B クラス（子クラス）
```python
class B(A):
    pass
```python

📌 B クラスは A を継承しているが、pass しかない！
📌 pass は「何もしない」という意味！
📌 つまり B は A の機能をそのまま継承し、独自の __init__() を持たない！

✅ オブジェクトの作成
```python
obj = B()
```python

📌 B のインスタンスを作成すると、B に __init__() がないので、親クラス A の __init__() が実行される！
📌 その結果 ""Aのコンストラクタ"" が出力される！

✅ 結果
Aのコンストラクタ

📌 まとめ
✔ pass を使うと、親クラスのメソッドをそのまま継承できる！
✔ 子クラスに __init__() がない場合、親クラスの __init__() が自動的に実行される！
✔ 継承だけして、まだ何も追加しないときに pass を使うことがある！

",4,2,
311,"以下のコードを実行すると、出力されるのは？
```python
class A:
    x = 10

class B(A):
    x = 20

obj = B()
print(obj.x)
```python

1️⃣ 10
2️⃣ 20
3️⃣ エラーが発生する
4️⃣ 何も出力されない","2️⃣ 20","このコードでは、クラス変数の「オーバーライド（上書き）」 について学びます！🚀

✅ コードの動作

📌 A クラス（親クラス）
```python
class A:
    x = 10
```python
📌 A クラスの変数 x は 10 に設定されている！
📌 これは「クラス変数」と呼ばれ、インスタンス間で共有される！

📌 B クラス（子クラス）
```python
class B(A):
    x = 20
```python
📌 B クラスは A を継承しているが、x を 20 に再定義している！
📌 このように、親クラスの変数を「オーバーライド（上書き）」できる！

✅ オブジェクトの作成
```python
obj = B()
print(obj.x)
```python

📌 obj は B クラスのインスタンスなので、B の x = 20 を参照する！
📌 その結果 20 が出力される！

✅ 結果
20

📌 まとめ
✔ クラス変数は、クラス内で共有される変数！
✔ 子クラスで同じ名前の変数を定義すると、親クラスの変数は上書きされる！（オーバーライド）
✔ 子クラスが独自の値を持つ場合、親クラスの変数は影響を受けない！

",4,2,
312,"以下のコードを実行すると、出力されるのは？
```python
class A:
    def method(self):
        print(""Aのメソッド"")

class B(A):
    def method(self):
        print(""Bのメソッド"")

obj = B()
obj.method()
```python

1️⃣ Aのメソッド
2️⃣ Bのメソッド
3️⃣ エラーが発生する
4️⃣ 何も出力されない","2️⃣ Bのメソッド","このコードでは、メソッドの「オーバーライド（上書き）」 について学びます！🚀

✅ コードの動作
📌 A クラス（親クラス）
```python
class A:
    def method(self):
        print(""Aのメソッド"")
```python
📌 A クラスには method() というメソッドが定義されている！
📌 A のインスタンスを作成すると、このメソッドが呼び出される！

📌 B クラス（子クラス）
```python
class B(A):
    def method(self):
        print(""Bのメソッド"")
```python

📌 B クラスは A を継承しているが、method() を再定義している！
📌 このように、親クラスのメソッドを「オーバーライド（上書き）」できる！

✅ オブジェクトの作成
```python
obj = B()
obj.method()
```python

📌 obj は B クラスのインスタンスなので、B の method() を実行する！
📌 その結果 Bのメソッド が出力される！

✅ 結果
Bのメソッド

📌 まとめ
✔ メソッドのオーバーライドを使うと、親クラスのメソッドを子クラスで上書きできる！
✔ 親クラスのメソッドを呼び出したい場合は super().method() を使う！
✔ 子クラスのメソッドが優先されるため、obj.method() で Bのメソッド が実行される！

",4,2,
313,"以下のコードを実行すると、出力されるのは？
```python
class A:
    def __init__(self):
        self.value = 10

class B(A):
    def __init__(self):
        super().__init__()
        self.value += 5

obj = B()
print(obj.value)
```python

1️⃣ 5
2️⃣ 10
3️⃣ 15
4️⃣ エラーが発生する

","3️⃣ 15","このコードでは、super() を使って親クラスのコンストラクタを呼び出し、その値を変更する 方法について学びます！🚀

✅ コードの動作
📌 A クラス（親クラス）
```python
class A:
    def __init__(self):
        self.value = 10
```python
📌 A クラスの __init__() は self.value を 10 に初期化する！

📌 B クラス（子クラス）
```python
class B(A):
    def __init__(self):
        super().__init__()
        self.value += 5
```python
📌 super().__init__() により、親クラス A の __init__() を実行！
📌 その結果 self.value = 10 になる！
📌 その後 self.value += 5 で self.value に 5 を加算し、15 になる！

✅ オブジェクトの作成
```python
obj = B()
print(obj.value)
```python

📌 B のインスタンス obj を作成すると…

super().__init__() により A.__init__() が実行される
self.value = 10
その後 self.value += 5 によって 15 に更新される！
print(obj.value) の結果 15 が出力される！

✅ 結果
15

📌 まとめ
✔ super().__init__() を使うと、親クラスのコンストラクタを実行できる！
✔ 親クラスの変数を子クラスで変更することができる！
✔ このように親クラスのデータを利用しつつ、子クラスで拡張する方法はよく使われる！

",4,2,
314,"以下のコードを実行すると、出力されるのは？
```python
class A:
    def show(self):
        print(""Aのメソッド"")

class B(A):
    def show(self):
        print(""Bのメソッド"")
        super().show()

obj = B()
obj.show()
```python

1️⃣
Bのメソッド

2️⃣
Aのメソッド
Bのメソッド

3️⃣
Bのメソッド
Aのメソッド

4️⃣ エラーが発生する

","3️⃣
Bのメソッド
Aのメソッド","このコードでは、super() を使って親クラスのメソッドを呼び出す方法 を学びます！🚀

✅ コードの動作
📌 A クラス（親クラス）
```python
class A:
    def show(self):
        print(""Aのメソッド"")
```python
📌 A クラスには show() というメソッドがある！
📌 このメソッドを呼び出すと ""Aのメソッド"" が出力される！

📌 B クラス（子クラス）
```python
class B(A):
    def show(self):
        print(""Bのメソッド"")
        super().show()
```python
📌 B クラスは A を継承しているが、show() をオーバーライドしている！
📌 print(""Bのメソッド"") を実行した後、super().show() によって親クラス A の show() を実行！

✅ オブジェクトの作成
```python
obj = B()
obj.show()
```python

📌 B のインスタンス obj を作成し、obj.show() を実行すると…

B の show() が実行される！
print(""Bのメソッド"") によって ""Bのメソッド"" を出力！
super().show() によって A の show() が実行される！
print(""Aのメソッド"") によって ""Aのメソッド"" を出力！

✅ 結果
Bのメソッド
Aのメソッド

📌 まとめ
✔ super().メソッド名() を使うと、親クラスのメソッドを呼び出せる！
✔ 子クラスのメソッド内で super() を使うことで、処理を拡張できる！
✔ B の show() は、まず B の処理を実行し、その後 A の処理を実行する！

",4,2,
315,"以下のコードを実行すると、出力されるのは？
```python
class A:
    def __init__(self):
        print(""Aのコンストラクタ"")

class B(A):
    def __init__(self):
        print(""Bのコンストラクタ"")

obj = B()
```python

1️⃣ Aのコンストラクタ
    Bのコンストラクタ

2️⃣ Bのコンストラクタ

3️⃣ エラーが発生する

4️⃣ 何も出力されない

","2️⃣ Bのコンストラクタ","このコードでは、子クラスが親クラスの __init__() を引き継がないケース を学びます！🚀

✅ コードの動作
📌 A クラス（親クラス）
```python
class A:
    def __init__(self):
        print(""Aのコンストラクタ"")
```python
📌 A クラスには __init__() メソッドがあり、オブジェクトが作成されると ""Aのコンストラクタ"" を出力！

📌 B クラス（子クラス）
```python
class B(A):
    def __init__(self):
        print(""Bのコンストラクタ"")
```python
📌 B クラスは A を継承しているが、__init__() をオーバーライドしている！
📌 super().__init__() を書いていないので、親クラス A の __init__() は実行されない！

✅ オブジェクトの作成
```python
obj = B()
```python

📌 B のインスタンス obj を作成すると…

B の __init__() が実行される！
""Bのコンストラクタ"" が出力される！
A の __init__() は実行されない！
super().__init__() がないため、親クラスの __init__() は呼び出されない！

✅ 結果
Bのコンストラクタ

📌 まとめ
✔ 子クラスで __init__() を定義すると、親クラスの __init__() は自動的に呼び出されない！
✔ 親クラスの __init__() を実行したい場合は、super().__init__() を明示的に書く必要がある！
✔ オーバーライドした場合、親のコンストラクタは継承されないことに注意！

",4,2,
316,"以下のコードを実行すると、出力されるのは？
```python
class A:
    def __init__(self):
        print(""Aのコンストラクタ"")

class B(A):
    def __init__(self):
        super().__init__()
        print(""Bのコンストラクタ"")

obj = B()
```python

1️⃣
Aのコンストラクタ
Bのコンストラクタ

2️⃣
Bのコンストラクタ

3️⃣ エラーが発生する

4️⃣ 何も出力されない

","1️⃣
Aのコンストラクタ
Bのコンストラクタ","このコードでは、super().__init__() を使って親クラスの __init__() を呼び出す方法 を学びます！🚀

✅ コードの動作
📌 A クラス（親クラス）
```python
class A:
    def __init__(self):
        print(""Aのコンストラクタ"")
```python
📌 A クラスには __init__() メソッドがあり、オブジェクトが作成されると ""Aのコンストラクタ"" を出力！

📌 B クラス（子クラス）
```python
class B(A):
    def __init__(self):
        super().__init__()
        print(""Bのコンストラクタ"")
```python
📌 B クラスは A を継承している！
📌 super().__init__() を使って、A の __init__() を実行！
📌 その後、B のコンストラクタの処理が続き ""Bのコンストラクタ"" を出力！

✅ オブジェクトの作成
```python
obj = B()
```python
📌 B のインスタンス obj を作成すると…

super().__init__() により A.__init__() が実行される
""Aのコンストラクタ"" が出力される！
次に B の __init__() の処理が実行される
""Bのコンストラクタ"" が出力される！

✅ 結果
Aのコンストラクタ
Bのコンストラクタ

📌 まとめ
✔ super().__init__() を使うと、親クラスの __init__() を明示的に呼び出せる！
✔ 親クラスの __init__() を実行した後、子クラスの __init__() の処理が続く！
✔ 親クラスの処理を維持しつつ、子クラスで拡張する際に super() を使う！

",4,2,
317,"以下のコードを実行すると、出力されるのは？
```python
class A:
    def __init__(self):
        print(""Aのコンストラクタ"")

class B(A):
    def __init__(self):
        print(""Bのコンストラクタ"")

class C(B):
    def __init__(self):
        super().__init__()
        print(""Cのコンストラクタ"")

obj = C()
```python

1️⃣
Aのコンストラクタ
Bのコンストラクタ
Cのコンストラクタ

2️⃣
Bのコンストラクタ
Cのコンストラクタ

3️⃣ エラーが発生する

4️⃣
Cのコンストラクタ","2️⃣
Bのコンストラクタ
Cのコンストラクタ","このコードでは、super() を使った多階層の継承の動作 を学びます！🚀

✅ コードの動作
📌 A クラス（親クラス）
```python
class A:
    def __init__(self):
        print(""Aのコンストラクタ"")
```python

📌 A クラスには __init__() があり、オブジェクトが作成されると ""Aのコンストラクタ"" を出力する！

📌 B クラス（A を継承）
```python
class B(A):
    def __init__(self):
        print(""Bのコンストラクタ"")
```python
📌 B クラスは A を継承しているが、独自の __init__() を定義している！
📌 super().__init__() を書いていないため、親クラス A の __init__() は実行されない！
📌 つまり、B のオブジェクトを作成しても Aのコンストラクタ は出力されない！

📌 C クラス（B を継承）
```python
class C(B):
    def __init__(self):
        super().__init__()
        print(""Cのコンストラクタ"")
```python

📌 C クラスは B を継承し、super().__init__() を使って B の __init__() を実行！
📌 その後 ""Cのコンストラクタ"" を出力！

✅ オブジェクトの作成
```python
obj = C()
```python

📌 C のインスタンス obj を作成すると…

super().__init__() により B.__init__() が実行される
""Bのコンストラクタ"" が出力される！
次に C の __init__() の処理が実行される
""Cのコンストラクタ"" が出力される！
B の __init__() は super() を使って A の __init__() を呼び出していないため、Aのコンストラクタ は出力されない！

✅ 結果
Bのコンストラクタ
Cのコンストラクタ

📌 まとめ
✔ super() を使うと、親クラスの __init__() を明示的に呼び出せる！
✔ super() を使わなければ、親クラスの __init__() は自動的には実行されない！
✔ C → B の順に __init__() が実行され、A の __init__() は呼ばれない！",4,2,
318,"以下のコードを実行すると、出力されるのは？
```python
class A:
    def __init__(self):
        print(""Aのコンストラクタ"")

class B(A):
    def __init__(self):
        super().__init__()
        print(""Bのコンストラクタ"")

class C(B):
    def __init__(self):
        super().__init__()
        print(""Cのコンストラクタ"")

obj = C()
```python

1️⃣
Aのコンストラクタ
Bのコンストラクタ
Cのコンストラクタ

2️⃣
Bのコンストラクタ
Cのコンストラクタ

3️⃣ 
エラーが発生する

4️⃣
Cのコンストラクタ","1️⃣
Aのコンストラクタ
Bのコンストラクタ
Cのコンストラクタ","このコードでは、super() を使った多階層の継承とコンストラクタの呼び出し順 を学びます！🚀

✅ コードの動作
📌 A クラス（親クラス）
```python
class A:
    def __init__(self):
        print(""Aのコンストラクタ"")
```python
📌 A クラスには __init__() メソッドがあり、オブジェクトが作成されると ""Aのコンストラクタ"" を出力！

📌 B クラス（A を継承）
```python
class B(A):
    def __init__(self):
        super().__init__()
        print(""Bのコンストラクタ"")
```python
📌 B クラスは A を継承し、super().__init__() を使って A の __init__() を呼び出している！
📌 その後 ""Bのコンストラクタ"" を出力！

📌 C クラス（B を継承）
```python
class C(B):
    def __init__(self):
        super().__init__()
        print(""Cのコンストラクタ"")
```python
📌 C クラスは B を継承し、super().__init__() を使って B の __init__() を呼び出している！
📌 その後 ""Cのコンストラクタ"" を出力！

✅ オブジェクトの作成
```python
obj = C()
```python

📌 C のインスタンス obj を作成すると…

C の __init__() が実行される！
super().__init__() により B の __init__() が呼び出される！
B の __init__() が実行される！
super().__init__() により A の __init__() が呼び出される！
A の __init__() が実行され、 ""Aのコンストラクタ"" を出力！
次に B の __init__() の処理が続き、 ""Bのコンストラクタ"" を出力！
最後に C の __init__() の処理が続き、 ""Cのコンストラクタ"" を出力！

✅ 結果
Aのコンストラクタ
Bのコンストラクタ
Cのコンストラクタ

📌 まとめ
✔ super() を使うと、親クラスの __init__() を明示的に呼び出せる！
✔ 親 → 子 → 孫 の順で super() を使うと、最上位の親から順に __init__() が実行される！
✔ このような設計は、クラスの再利用性を高めるためによく使われる！",4,2,
319,"以下のコードを実行すると、出力されるのは？
```python
class A:
    def __init__(self, x):
        self.x = x
        print(f""Aのコンストラクタ: x = {self.x}"")

class B(A):
    def __init__(self, x, y):
        super().__init__(x)
        self.y = y
        print(f""Bのコンストラクタ: y = {self.y}"")

class C(B):
    def __init__(self, x, y, z):
        super().__init__(x, y)
        self.z = z
        print(f""Cのコンストラクタ: z = {self.z}"")

obj = C(1, 2, 3)
```python

1️⃣
Aのコンストラクタ: x = 1
Bのコンストラクタ: y = 2
Cのコンストラクタ: z = 3

2️⃣
Bのコンストラクタ: y = 2
Cのコンストラクタ: z = 3

3️⃣ 
エラーが発生する

4️⃣
Cのコンストラクタ: z = 3","1️⃣
Aのコンストラクタ: x = 1
Bのコンストラクタ: y = 2
Cのコンストラクタ: z = 3","このコードでは、super() を使って親クラスのコンストラクタに引数を渡す方法 を学びます！🚀

✅ コードの動作
📌 A クラス（親クラス）
```python
class A:
    def __init__(self, x):
        self.x = x
        print(f""Aのコンストラクタ: x = {self.x}"")
```python
📌 A クラスの __init__() は x を引数として受け取り、それを self.x に代入する！
📌 print() で ""Aのコンストラクタ: x = {x}"" を出力！

📌 B クラス（A を継承）
```python
class B(A):
    def __init__(self, x, y):
        super().__init__(x)
        self.y = y
        print(f""Bのコンストラクタ: y = {self.y}"")
```python
📌 B クラスは A を継承し、super().__init__(x) によって A の __init__() を実行！
📌 その後 self.y = y で y を代入し、 ""Bのコンストラクタ: y = {y}"" を出力！

📌 C クラス（B を継承）
```python
class C(B):
    def __init__(self, x, y, z):
        super().__init__(x, y)
        self.z = z
        print(f""Cのコンストラクタ: z = {self.z}"")
```python
📌 C クラスは B を継承し、super().__init__(x, y) によって B の __init__() を実行！
📌 その後 self.z = z で z を代入し、 ""Cのコンストラクタ: z = {z}"" を出力！

✅ オブジェクトの作成
```python
obj = C(1, 2, 3)
```python
📌 C のインスタンス obj を作成すると…

C の __init__() が実行される！
super().__init__(x, y) により B の __init__() が呼び出される！
B の __init__() が実行される！
super().__init__(x) により A の __init__() が呼び出される！
A の __init__() が実行され、 ""Aのコンストラクタ: x = 1"" が出力！
次に B の __init__() の処理が続き、 ""Bのコンストラクタ: y = 2"" が出力！
最後に C の __init__() の処理が続き、 ""Cのコンストラクタ: z = 3"" が出力！

✅ 結果
Aのコンストラクタ: x = 1
Bのコンストラクタ: y = 2
Cのコンストラクタ: z = 3

📌 まとめ
✔ super().__init__() を使うと、親クラスのコンストラクタを実行できる！
✔ 親クラスの __init__() に引数が必要な場合、super().__init__(引数) で渡す！
✔ 引数の数が増えても、継承関係を適切に管理すれば問題なく動作する！",4,2,
320,"以下のコードを実行すると、出力されるのは？
```python
class A:
    def __init__(self):
        print(""Aのコンストラクタ"")

class B(A):
    def __init__(self):
        print(""Bのコンストラクタ"")
        super().__init__()

class C(B):
    def __init__(self):
        print(""Cのコンストラクタ"")
        super().__init__()

obj = C()
```python

1️⃣
Aのコンストラクタ
Bのコンストラクタ
Cのコンストラクタ

2️⃣
Cのコンストラクタ
Bのコンストラクタ
Aのコンストラクタ

3️⃣
Cのコンストラクタ
Bのコンストラクタ

4️⃣ エラーが発生する","2️⃣
Cのコンストラクタ
Bのコンストラクタ
Aのコンストラクタ","このコードでは、super() を使ったコンストラクタの呼び出し順 を学びます！🚀

✅ コードの動作
📌 A クラス（親クラス）
```python
class A:
    def __init__(self):
        print(""Aのコンストラクタ"")
```python
📌 A クラスの __init__() では ""Aのコンストラクタ"" を出力！

📌 B クラス（A を継承）
```python
class B(A):
    def __init__(self):
        print(""Bのコンストラクタ"")
        super().__init__()
```python
📌 B クラスは A を継承し、__init__() 内で ""Bのコンストラクタ"" を出力した後、super().__init__() を実行！
📌 これにより A の __init__() が呼ばれ ""Aのコンストラクタ"" が出力される！

📌 C クラス（B を継承）
```python
class C(B):
    def __init__(self):
        print(""Cのコンストラクタ"")
        super().__init__()
```python
📌 C クラスは B を継承し、__init__() 内で ""Cのコンストラクタ"" を出力！
📌 その後、super().__init__() を実行し、B の __init__() を呼び出す！

✅ オブジェクトの作成
```python
obj = C()
```python
📌 C のインスタンス obj を作成すると…

C の __init__() が実行され、 ""Cのコンストラクタ"" が出力！
super().__init__() により B の __init__() が呼び出される
""Bのコンストラクタ"" が出力！
B の super().__init__() により A の __init__() が呼び出される
""Aのコンストラクタ"" が出力！

✅ 結果
Cのコンストラクタ
Bのコンストラクタ
Aのコンストラクタ

📌 まとめ
✔ super() を使うと、親クラスの __init__() を呼び出せる！
✔ super() を使う順番によって、実行の流れが変わる！
✔ 最も派生したクラス C の __init__() から順番に B → A へと super() で実行される！",4,2,
321,"以下のコードを実行すると、出力されるのは？
```python
class A:
    def __init__(self):
        print(""Aのコンストラクタ"")

class B(A):
    def __init__(self):
        super().__init__()
        print(""Bのコンストラクタ"")

class C(B):
    def __init__(self):
        print(""Cのコンストラクタ"")
        super().__init__()

class D(C):
    def __init__(self):
        super().__init__()
        print(""Dのコンストラクタ"")

obj = D()
```python

1️⃣
Aのコンストラクタ
Bのコンストラクタ
Cのコンストラクタ
Dのコンストラクタ

2️⃣
Cのコンストラクタ
Aのコンストラクタ
Bのコンストラクタ
Dのコンストラクタ

3️⃣
Cのコンストラクタ
Bのコンストラクタ
Aのコンストラクタ
Dのコンストラクタ

4️⃣ エラーが発生する","2️⃣
Cのコンストラクタ
Aのコンストラクタ
Bのコンストラクタ
Dのコンストラクタ","このコードでは、super() を使ったコンストラクタの呼び出し順 を学びます！🚀

✅ コードの動作
📌 A クラス（最上位の親クラス）
class A:
    def __init__(self):
        print(""Aのコンストラクタ"")
📌 A クラスの __init__() では ""Aのコンストラクタ"" を出力！

📌 B クラス（A を継承）
class B(A):
    def __init__(self):
        super().__init__()
        print(""Bのコンストラクタ"")

📌 B クラスの __init__() では、super().__init__() を使って A の __init__() を実行！
📌 その後 ""Bのコンストラクタ"" を出力！

📌 C クラス（B を継承）
```python
class C(B):
    def __init__(self):
        print(""Cのコンストラクタ"")  # ✅ ここが最初に実行！
        super().__init__()
```python
📌 C クラスの __init__() では、最初に ""Cのコンストラクタ"" を出力！
📌 その後 super().__init__() を使って B の __init__() を実行！

📌 D クラス（C を継承）
```python
class D(C):
    def __init__(self):
        super().__init__()
        print(""Dのコンストラクタ"")
```python
📌 D クラスの __init__() では、最初に super().__init__() を使って C の __init__() を実行！
📌 その後 ""Dのコンストラクタ"" を出力！

✅ オブジェクトの作成
```python
obj = D()
```python
📌 D のインスタンス obj を作成すると…

D の __init__() が実行され、super().__init__() により C の __init__() が呼ばれる！
Cのコンストラクタ が出力！ ← print() が super() の前にあるため
C.__init__() の super().__init__() により B.__init__() が呼ばれる
B.__init__() の super().__init__() により A.__init__() が呼ばれる
Aのコンストラクタ が出力！
Bのコンストラクタ が出力！
最後に D.__init__() の処理が続き、 ""Dのコンストラクタ"" が出力！

✅ 結果
Cのコンストラクタ
Aのコンストラクタ
Bのコンストラクタ
Dのコンストラクタ

📌 まとめ
✔ super() は、最も親のクラス (A) から順番に __init__() を実行する！
✔ ただし、super() の前に print() があると、その print() が先に実行される！
✔ このコードでは C → A → B → D の順番で __init__() が実行される！

📌 super() を print() の前にすると？
もし C.__init__() を次のように変更したらどうなるか？
```python
class C(B):
    def __init__(self):
        super().__init__()  # ✅ 先に `B.__init__()` を実行
        print(""Cのコンストラクタ"")  # ✅ その後に `print()`
```python

🔽 この場合の出力
Aのコンストラクタ
Bのコンストラクタ
Cのコンストラクタ
Dのコンストラクタ

✅ この変更により、A → B → C → D の順番で実行される！

📌 修正後のポイント
✔ 「super() の前に print() がある場合、その print() が先に実行される！」
✔ C.__init__() の print() を super().__init__() の後にすると、実行順が変わる！",4,2,
322,"以下のコードを実行すると、出力されるのは？
```python
class A:
    def __init__(self, x):
        self.x = x
        print(f""Aのコンストラクタ: x = {self.x}"")

class B(A):
    def __init__(self, x, y):
        super().__init__(x)
        self.y = y
        print(f""Bのコンストラクタ: y = {self.y}"")

class C(B):
    def __init__(self, x, y, z):
        super().__init__(x, y)
        self.z = z
        print(f""Cのコンストラクタ: z = {self.z}"")

obj = C(1, 2, 3)
```python

1️⃣
Aのコンストラクタ: x = 1
Bのコンストラクタ: y = 2
Cのコンストラクタ: z = 3

2️⃣
Cのコンストラクタ: z = 3
Bのコンストラクタ: y = 2
Aのコンストラクタ: x = 1

3️⃣
Aのコンストラクタ: x = 1
Cのコンストラクタ: z = 3
Bのコンストラクタ: y = 2

4️⃣ エラーが発生する","1️⃣
Aのコンストラクタ: x = 1
Bのコンストラクタ: y = 2
Cのコンストラクタ: z = 3","このコードでは、「コンストラクタの引数の受け渡し」と super() の動作 を学ぶよ！🚀

✅ コードの動作
📌 A クラス（最上位の親クラス）
```python
class A:
    def __init__(self, x):
        self.x = x
        print(f""Aのコンストラクタ: x = {self.x}"")
```python
📌 A クラスの __init__() では x を受け取り、self.x に代入する
📌 そして ""Aのコンストラクタ: x = {self.x}"" を出力！

📌 B クラス（A を継承）
```python
class B(A):
    def __init__(self, x, y):
        super().__init__(x)  # ✅ 親クラス A の __init__() を呼び出す
        self.y = y
        print(f""Bのコンストラクタ: y = {self.y}"")
```python
📌 B クラスの __init__() では、x, y を受け取る！
📌 super().__init__(x) を使って A の __init__() を呼び出し、x を渡す！
📌 その後 self.y = y を代入し、 ""Bのコンストラクタ: y = {self.y}"" を出力！

📌 C クラス（B を継承）
```python
class C(B):
    def __init__(self, x, y, z):
        super().__init__(x, y)  # ✅ 親クラス B の __init__() を呼び出す
        self.z = z
        print(f""Cのコンストラクタ: z = {self.z}"")
```python
📌 C クラスの __init__() では、x, y, z を受け取る！
📌 super().__init__(x, y) を使って B の __init__() を呼び出し、x, y を渡す！
📌 その後 self.z = z を代入し、 ""Cのコンストラクタ: z = {self.z}"" を出力！

✅ オブジェクトの作成
```python
obj = C(1, 2, 3)
```python

📌 C のインスタンス obj を作成すると…

C.__init__() が実行される
super().__init__(x, y) により B.__init__() が呼ばれる
B.__init__() が実行される
super().__init__(x) により A.__init__() が呼ばれる
A.__init__() が実行される
Aのコンストラクタ: x = 1 が出力！
B.__init__() の続きが実行される
Bのコンストラクタ: y = 2 が出力！
C.__init__() の続きが実行される
Cのコンストラクタ: z = 3 が出力！

✅ 結果
Aのコンストラクタ: x = 1
Bのコンストラクタ: y = 2
Cのコンストラクタ: z = 3

📌 まとめ
✔ super() を使うと、親クラスの __init__() を呼び出せる！
✔ 親クラスの __init__() に必要な引数を super() を使って渡す！
✔ コンストラクタの実行順は、親クラス (A) から順番に実行される！

💡 ポイント
super().__init__(x, y) は B の __init__() を実行し、その中の super().__init__(x) で A の __init__() を実行！
親クラスの __init__() から順番に実行される！",4,2,
323,"以下のコードを実行すると、出力されるのは？
```python
class A:
    def __init__(self):
        print(""Aのコンストラクタ"")

class B(A):
    def __init__(self):
        super().__init__()
        print(""Bのコンストラクタ"")

class C(A):
    def __init__(self):
        print(""Cのコンストラクタ"")
        super().__init__()

class D(B, C):
    def __init__(self):
        print(""Dのコンストラクタ"")
        super().__init__()

obj = D()
```python
1️⃣
Dのコンストラクタ  
Bのコンストラクタ  
Cのコンストラクタ  
Aのコンストラクタ

2️⃣
Dのコンストラクタ  
Cのコンストラクタ  
Aのコンストラクタ  
Bのコンストラクタ

3️⃣
Dのコンストラクタ  
Aのコンストラクタ  
Bのコンストラクタ  
Cのコンストラクタ

4️⃣
Dのコンストラクタ  
Bのコンストラクタ  
Aのコンストラクタ  
Cのコンストラクタ","2️⃣
Dのコンストラクタ
Cのコンストラクタ
Aのコンストラクタ
Bのコンストラクタ","✅ super() の動作と MRO（メソッド解決順序）

Python では、クラスの継承順序を MRO（Method Resolution Order）というルールで決定します！✨
super() を使うと、この MRO の順番に沿って親クラスのメソッドが呼び出されるんだ！💡

D は B と C を継承していて、 B と C は A を継承しています。
では、Python は super() を使ってどの順番で __init__() を呼び出すのか？ 🤔

✅ MRO（メソッド解決順序）の確認
Python では、MRO を D.mro() で確認できます！🔍
```python
print(D.mro())
```python
🔽 出力
[<class '__main__.D'>, <class '__main__.B'>, <class '__main__.C'>, <class '__main__.A'>, <class 'object'>]
📌 つまり、MRO の順番は D → B → C → A！
📌 super() は この順番に従ってクラスをたどる！

✅ MRO（メソッド解決順序）の決まり
Python では MRO を次のルールで決める！

🔹 「C3線形化（C3 Linearization）」というルール
Python の MRO は、C3線形化 という特殊なルールで決まるよ！

簡単に言うと…

✔ 「左から順番に」継承クラスをたどる！
✔ 「すでに見たクラス」は二重に呼ばない！
✔ 「親クラスは最後に実行される！」

✅ super() の動作の流れ
それでは、実際に super() の動きを追いながら 出力順を確認しよう！💡✨

1️⃣ D.__init__() の実行
```python
class D(B, C):
    def __init__(self):
        print(""Dのコンストラクタ"")
        super().__init__()
```python
✅ 「Dのコンストラクタ」 が出力される！
✅ super().__init__() により MRO の次の B.__init__() にジャンプ！

2️⃣ B.__init__() の実行
```python
class B(A):
    def __init__(self):
        super().__init__()
        print(""Bのコンストラクタ"")
```python
✅ super().__init__() を実行するが、MRO の順番により C.__init__() にジャンプ！
✅ B の super() は「MRO の次（C）に飛ぶ！」

3️⃣ C.__init__() の実行
```python
class C(A):
    def __init__(self):
        print(""Cのコンストラクタ"")
        super().__init__()
```python
✅ 「Cのコンストラクタ」 が出力される！
✅ super().__init__() により A.__init__() を実行！

4️⃣ A.__init__() の実行
```python
class A:
    def __init__(self):
        print(""Aのコンストラクタ"")
```python
✅ 「Aのコンストラクタ」 が出力される！
✅ ここで super() の呼び出しは終了！

5️⃣ B.__init__() に戻る
✅ B.__init__() の super().__init__() がすでに実行されたので、
✅ 最後に「Bのコンストラクタ」が出力される！

✅ 最終的な出力順
Dのコンストラクタ  # D.__init__()
Cのコンストラクタ  # B の `super()` で `C.__init__()` に飛ぶ！
Aのコンストラクタ  # C の `super()` で `A.__init__()` を実行！
Bのコンストラクタ  # 最後に `B.__init__()` の print が実行！

🔎 まとめ
MRO（メソッド解決順序） によって、super() は D → B → C → A の順番で親クラスをたどる！
ただし、super() の呼び出し方によって、実際の出力順は D → C → A → B となる！🚀

📌 ポイント 
1️⃣ MRO（メソッド解決順序）とは、Python がクラスの継承をたどるルール！
2️⃣ super() は MRO に従って「次のクラス」を呼び出す！
3️⃣ B.__init__() の super() は C.__init__() に飛ぶのが最大のポイント！
4️⃣ 最終的に D → C → A → B の順で __init__() が実行される！

🎯 おまけ： super() なしならどうなる？
もし B.__init__() に super() を使わなかったら？
```python
class B(A):
    def __init__(self):
        print(""Bのコンストラクタ"")
```python
🔽 出力
Dのコンストラクタ
Bのコンストラクタ  # ← `super()` がないので B が先に出る！
Cのコンストラクタ
Aのコンストラクタ

📌 B が C より先に出力される！
📌 super() の位置を変えると出力順が変わる！

📌 まとめ
super() の動きを MRO と合わせて考えることが大事！ ✨
MRO を D.mro() で確認しながら、実際に super() の動作を試してみよう！😊💡",4,3,
324,"以下のコードを実行すると、出力されるのは？
```
class MathUtils:
    @staticmethod
    def add(x, y):
        return x + y

# クラス名からメソッドを呼び出す
print(MathUtils.add(3, 5))
```
1️⃣ TypeError（エラーが発生する）
2️⃣ None
3️⃣ 8
4️⃣ ""3 + 5""（文字列として ""3 + 5"" が表示される）","3️⃣ 8","@staticmethod を使うと、インスタンスを作らずにクラス名から直接メソッドを呼び出すことができる！ 💡

📌 @staticmethod のポイント
✔ @staticmethod を付けたメソッドは、クラスやインスタンスに依存しない関数のように動作する！
✔ 第一引数に self を取らない！（普通のメソッドと違い、インスタンスのデータにアクセスしない）
✔ クラス名で直接呼び出せる！（MathUtils.add(3, 5) のように）

📌 コードの動作
```python
class MathUtils:
    @staticmethod
    def add(x, y):  # self を取らない！
        return x + y
```python
# クラス名から直接呼び出し
print(MathUtils.add(3, 5))
📌 add(3, 5) の計算を行い、8 を返す！

✅ @staticmethod と普通のメソッドの違い
メソッドの種類	self の有無	呼び出し方	使いどころ
通常のメソッド	self を取る	obj.method()	インスタンスのデータを扱う
クラスメソッド (@classmethod)	cls を取る	ClassName.method() or obj.method()	クラス全体のデータを扱う
静的メソッド (@staticmethod)	引数なし（self も cls も不要）	ClassName.method()	クラスやインスタンスに依存しない処理
📌 @staticmethod の使いどころ

💡 ユーティリティ関数のように使うと便利！
```python
class MathUtils:
    @staticmethod
    def multiply(x, y):
        return x * y
```python

# いちいちインスタンスを作らなくてもOK
print(MathUtils.multiply(4, 6))  # → 24
📌 「クラスの一部だけど、インスタンスを必要としない関数」を作るときに便利！

🔎 まとめ
✔ @staticmethod を使うと、クラス名から直接メソッドを呼び出せる！
✔ インスタンスの self やクラスの cls に依存しないメソッドを定義するときに便利！
✔ クラスの一部としてまとめたいが、インスタンスに関係ない関数を定義するときに使う！",4,2,
325,"以下のコードを実行すると、出力されるのは？
```python
class Person:
    def __init__(self, name, age):
        self.name = name
        self._age = age

    @property
    def age(self):
        return self._age

p = Person(""太郎"", 30)
print(p.age)
```python

1️⃣ 30
2️⃣ AttributeError（エラーが発生する）
3️⃣ None
4️⃣ p.age() のように呼び出さないとエラーが発生する","1️⃣ 30","@property を使うと、メソッドを「属性のように」扱える！ 💡✨
このコードでは、age() というメソッドを p.age のように呼び出せる ようになってる！

📌 @property のポイント
✔ ゲッター（読み取り専用の属性）を作成できる！
✔ p.age() ではなく p.age としてアクセスできる！
✔ カプセル化（直接 _age にアクセスさせない）を実現できる！

📌 コードの動作
```python
class Person:
    def __init__(self, name, age):
        self.name = name
        self._age = age  # `_age` は「外部から直接変更してほしくない」ので `_` を付ける

    @property
    def age(self):
        return self._age  # `p.age` で `_age` の値を取得できる！

p = Person(""太郎"", 30)
print(p.age)  # 30
```python
📌 p.age とすると age() メソッドが呼び出されて _age の値を返す！ 🎯

✅ @property のメリット
 ゲッター（getter）を作ることで、属性の読み取り制限ができる！
p.age = 40  # ❌ AttributeError: can't set attribute
📌 @property を付けたメソッドは デフォルトで「読み取り専用」 だから、
📌 p.age = 40 のように直接書き換えると エラーになる！

🔎 @property の拡張： セッター（@変数名.setter）
📌 セッター（setter）を作れば値の変更もできる！
```python
class Person:
    def __init__(self, name, age):
        self.name = name
        self._age = age

    @property
    def age(self):
        return self._age

    @age.setter  # セッターを定義
    def age(self, value):
        if value < 0:
            raise ValueError(""年齢は0以上でなければなりません！"")
        self._age = value  # 値の設定を許可

p = Person(""太郎"", 30)
p.age = 35  # OK！
print(p.age)  # 35

p.age = -5  # ❌ ValueError: 年齢は0以上でなければなりません！
```python
📌 セッターを使うと、値の制御が可能！ (@age.setter を定義することで p.age = 35 のように設定できる)
📌 不適切な値をブロックするバリデーションも実装できる！

✅ まとめ
✔ @property を使うと、メソッドを属性のようにアクセスできる！
✔ ゲッター（@property）だけを定義すれば「読み取り専用」にできる！
✔ セッター（@変数名.setter）を追加すると値の変更を制御できる！
✔ カプセル化を実現し、安全にデータを管理できる！",4,3,
326,"以下のコードを実行すると、出力されるのは？
```python
class Example:
    class_var = 10  # クラス変数

    def __init__(self, value):
        self.instance_var = value  # インスタンス変数

    @classmethod
    def class_method(cls):
        cls.class_var += 5
        return cls.class_var

    @staticmethod
    def static_method():
        return ""これはスタティックメソッドです。""

# インスタンスを作成
obj1 = Example(100)
obj2 = Example(200)

# メソッドの呼び出し
print(obj1.class_method())  # クラスメソッドの呼び出し
print(obj2.class_method())  # クラスメソッドの呼び出し
print(Example.static_method())  # スタティックメソッドの呼び出し
```
📌 選択肢
1️⃣ 15 → 20 → ""これはスタティックメソッドです。""
2️⃣ 15 → 15 → ""これはスタティックメソッドです。""
3️⃣ 10 → 15 → ""これはスタティックメソッドです。""
4️⃣ エラーが発生する","1️⃣ 15 → 20 → ""これはスタティックメソッドです。""","このコードでは クラスメソッド (@classmethod) と スタティックメソッド (@staticmethod) の動作 を確認できるよ！

✅ 1. class_method() の動作
```
@classmethod
def class_method(cls):
    cls.class_var += 5
    return cls.class_var
```
📌 クラスメソッド (class_method) は、クラス変数 class_var を変更する！
📌 cls.class_var を +5 するので、クラスメソッドを呼び出すたびに値が増える！

✅ 2. class_method() の呼び出し
```
print(obj1.class_method())  # 15
print(obj2.class_method())  # 20
```
📌 クラス変数 (class_var) の変更は全インスタンスで共有！
📌 最初の obj1.class_method() の時点で 10 + 5 = 15 になる！
📌 次の obj2.class_method() で 15 + 5 = 20 になる！

✔ obj1.class_method() → 15
✔ obj2.class_method() → 20

✅ 3. static_method() の動作
```
@staticmethod
def static_method():
    return ""これはスタティックメソッドです。""
```
📌 static_method() は、クラス変数やインスタンス変数を操作しない！
📌 単に ""これはスタティックメソッドです。"" を返すだけ！

✔ Example.static_method() → ""これはスタティックメソッドです。""

📌 最終的な出力
15
20
これはスタティックメソッドです。
✅ だから、正解は 1️⃣ 15 → 20 → ""これはスタティックメソッドです。""！ 🎉

📌 まとめ
✅ クラスメソッド (@classmethod) は cls を使い、クラス変数を操作できる！
✅ クラスメソッドを呼ぶたびに class_var が増えていく！
✅ スタティックメソッド (@staticmethod) はクラス変数を使わず、単に関数を定義できる！",4,3,
327,"以下のコードを実行すると、出力されるのは？
```python
class Parent:
    def __init__(self):
        self.value = 10

    def show(self):
        return f""Parent: {self.value}""

class Child(Parent):
    def __init__(self):
        super().__init__()
        self.value = 20  # 親クラスの変数と同じ名前の変数を上書き

    def show(self):
        return f""Child: {self.value}""

p = Parent()
c = Child()

print(p.show())
print(c.show())
```

1️⃣ ""Parent: 10"" → ""Child: 20""
2️⃣ ""Parent: 10"" → ""Parent: 10""
3️⃣ ""Child: 20"" → ""Parent: 10""
4️⃣ エラーが発生する","1️⃣ ""Parent: 10"" → ""Child: 20""","このコードでは、親クラス (Parent) と 子クラス (Child) の関係と super() の動作 を確認できるよ！

✅ 1. Parent クラスの __init__() と show()
```
class Parent:
    def __init__(self):
        self.value = 10

    def show(self):
        return f""Parent: {self.value}""
```
📌 __init__() で self.value = 10 を設定！
📌 show() メソッドは ""Parent: 10"" を返す！

✅ 2. Child クラスの __init__()
```
class Child(Parent):
    def __init__(self):
        super().__init__()  # ✅ 親クラスのコンストラクタを呼ぶ
        self.value = 20  # ✅ 親クラスの value を上書き
```
📌 super().__init__() で Parent の __init__() を実行！
📌 その結果、最初に self.value = 10 が設定される！
📌 その後 self.value = 20 で上書きされる！

✅ 3. show() の動作
p.show() の動作
```
p = Parent()
print(p.show())  # ✅ Parent: 10
```
✔ 親クラス (Parent) の show() が呼ばれる！
✔ self.value は 10 のままなので、出力は ""Parent: 10""

c.show() の動作
```
c = Child()
print(c.show())  # ✅ Child: 20
```
✔ 子クラス (Child) の show() が呼ばれる！
✔ self.value は 20 に上書きされているので、出力は ""Child: 20""

📌 最終的な出力
Parent: 10
Child: 20

📌 まとめ
✅ super().__init__() を使うと、親クラスの __init__() を実行できる！
✅ 子クラスで self.value = 20 を設定すると、親の value = 10 を上書きする！
✅ show() をオーバーライドすると、子クラス独自のメソッドを定義できる！

",4,3,
328,"以下のコードを実行すると、出力されるのは？
```python
class A:
    def __init__(self):
        self.value = 5

    def show(self):
        return f""A: {self.value}""

class B(A):
    def __init__(self):
        super().__init__()
        self.value += 10

    def show(self):
        return f""B: {self.value}""

class C(A):
    def __init__(self):
        super().__init__()
        self.value *= 2

    def show(self):
        return f""C: {self.value}""

class D(B, C):
    def __init__(self):
        super().__init__()

d = D()
print(d.show())
```
1️⃣ ""B: 10""
2️⃣ ""B: 20""
3️⃣ ""C: 10""
4️⃣ ""C: 20""","2️⃣ ""B: 20""","✅ 1. MRO の確認
D(B, C) の場合、MRO（メソッド解決順序）はこうなる：

D → B → C → A
📌 つまり、 super().__init__() を実行すると、B → C → A の順に __init__() が実行される！

✅ 2. __init__() の順番
1️⃣ D の __init__() 実行
```
class D(B, C):
    def __init__(self):
        super().__init__()  # ✅ B の __init__() を呼ぶ（その後、C → A の順に実行）
```
📌 D の super().__init__() は B の __init__() を呼ぶ！
📌 B は super().__init__() を使って C の __init__() を呼ぶ！ 📌 C も super().__init__() を使って A の __init__() を呼ぶ！

2️⃣ A の __init__()（最初に実行）
```
class A:
    def __init__(self):
        self.value = 5
```
📌 self.value = 5 に初期化される！
📌 この値が B と C に引き継がれる！

3️⃣ C の __init__()（次に実行）
```
class C(A):
    def __init__(self):
        super().__init__()
        self.value *= 2  # ✅ 5 * 2 = 10
```
📌 C の __init__() で self.value *= 2 が実行される！
📌 よって、self.value = 10 に変わる！

4️⃣ B の __init__()（最後に実行）
```
class B(A):
    def __init__(self):
        super().__init__()
        self.value += 10  # ✅ 10 + 10 = 20
```
📌 C の __init__() が実行された後、B の __init__() が実行される！
📌 ここで self.value += 10 が適用される！ 📌 つまり、10 + 10 = 20 となる！

✅ 3. d.show() の動作
```
print(d.show())  # ✅ B の show() が呼ばれる
```
📌 MRO により D → B → C → A の順なので、 show() は B の show() を使う！
```
class B(A):
    def show(self):
        return f""B: {self.value}""
```
📌 現在 self.value = 20 なので、 ""B: 20"" が出力！

✅ MRO の基本ルール
1️⃣ 「左から順に」継承クラスをたどる

D(B, C) の場合、B が C よりも先に来る
2️⃣ 各クラスが継承している親クラスをさらにたどる
B(A) の場合、本来は A に行くが、MRO では C の後に A に行く！
3️⃣ 同じクラスが複数回出る場合は、最初の出現だけを残す
A は B と C の両方が継承しているが、一度だけ通る

✅ MRO を手順で確認
D(B, C) → まず B に行く
B(A) → 本来なら A へ行くが、まだ C を見ていないので C に行く
C(A) → A に行く
A はすでに C で通ったので、一度だけ実行される

📌 つまり、MRO の順番は…
D → B → C → A",4,3,
329,"以下のコードを実行すると、出力されるのは？
```
class A:
    def __init__(self):
        print(""Aのコンストラクタ"")
        self.value = 10

class B(A):
    def __init__(self):
        print(""Bのコンストラクタ"")
        super().__init__()
        self.value += 5

class C(A):
    def __init__(self):
        print(""Cのコンストラクタ"")
        super().__init__()
        self.value *= 2

class D(B, C):
    def __init__(self):
        print(""Dのコンストラクタ"")
        super().__init__()

obj = D()
print(obj.value)
```
📌 選択肢
1️⃣ Dのコンストラクタ → Bのコンストラクタ → Cのコンストラクタ → Aのコンストラクタ → 30
2️⃣ Dのコンストラクタ → Cのコンストラクタ → Bのコンストラクタ → Aのコンストラクタ → 20
3️⃣ Dのコンストラクタ → Bのコンストラクタ → Cのコンストラクタ → Aのコンストラクタ → 25
4️⃣ Dのコンストラクタ → Bのコンストラクタ → Cのコンストラクタ → Aのコンストラクタ → 40","3️⃣ Dのコンストラクタ → Bのコンストラクタ → Cのコンストラクタ → Aのコンストラクタ → 25","この問題は MRO（Method Resolution Order） に基づいて、super().__init__() の処理順と、value の変更の流れを考えるのがポイント！

📌 MRO（メソッド解決順序）を確認
クラス D の継承関係は以下のとおり：
class D(B, C)
class B(A)
class C(A)
👉 MRO のルール に従って、D(B, C) の MRO を求めると：
D → B → C → A

🔹 MRO を手順で確認
D.__init__() が呼ばれる
super().__init__() によって MRO の順番に従い B.__init__() が実行される
B.__init__() の super().__init__() は MRO に従い C.__init__() に進む
C.__init__() の super().__init__() で A.__init__() に行く
A.__init__() の処理が終わると、MRO の逆順に戻りながら、B と C の処理を実行

📌 value の変化
✅ A.__init__() が実行される
self.value = 10  # 🔹 最初に 10 がセットされる

✅ C.__init__() の super().__init__() の後の処理
self.value *= 2  # 🔹 10 × 2 = 20

✅ B.__init__() の super().__init__() の後の処理
self.value += 5  # 🔹 20 + 5 = 25

📌 実際の出力
Dのコンストラクタ
Bのコンストラクタ
Cのコンストラクタ
Aのコンストラクタ
25

📌 まとめ
✅ MRO に従い、D → B → C → A の順で __init__() が実行される！
✅ value の変更は A → C → B の順に行われるため、最終的に 25 になる！

💡 この問題では「MRO の順番がすべてを決める！」ことを意識しよう！ 😃",4,3,
330,"以下のコードを実行すると、出力されるのは？
```
class A:
    def __init__(self):
        print(""Aのコンストラクタ"")
        self.value = 5

class B(A):
    def __init__(self):
        print(""Bのコンストラクタ"")
        super().__init__()
        self.value -= 2

class C(A):
    def __init__(self):
        print(""Cのコンストラクタ"")
        super().__init__()
        self.value *= 3

class D(B, C):
    def __init__(self):
        print(""Dのコンストラクタ"")
        super().__init__()

obj = D()
print(obj.value)
```
1️⃣ Dのコンストラクタ → Bのコンストラクタ → Cのコンストラクタ → Aのコンストラクタ → 9
2️⃣ Dのコンストラクタ → Bのコンストラクタ → Cのコンストラクタ → Aのコンストラクタ → 13
3️⃣ Dのコンストラクタ → Cのコンストラクタ → Bのコンストラクタ → Aのコンストラクタ → 15
4️⃣ Dのコンストラクタ → Bのコンストラクタ → Cのコンストラクタ → Aのコンストラクタ → 10","2️⃣ Dのコンストラクタ → Bのコンストラクタ → Cのコンストラクタ → Aのコンストラクタ → 13","この問題では、MRO（Method Resolution Order） に基づいて super().__init__() がどの順で呼ばれるかを理解するのがポイントです。

📌 MRO（メソッド解決順序）を確認
クラスの継承関係を整理します：

class D(B, C)
class B(A)
class C(A)

👉 MROの順番
PythonのMROは、C3線形化アルゴリズム に基づき、クラスの継承順を決定します。
D(B, C) の MRO は以下のようになります：

D → B → C → A

つまり、super().__init__() はこの順で呼び出されます。

📌 各クラスの __init__() の実行順
D.__init__()
```
print(""Dのコンストラクタ"")
super().__init__()
```
D のコンストラクタが呼ばれ、次に super().__init__() で B.__init__() へ進む。

B.__init__()
```
print(""Bのコンストラクタ"")
super().__init__()
self.value -= 2
```
B のコンストラクタが呼ばれ、次に super().__init__() で C.__init__() へ進む。

C.__init__()
```
print(""Cのコンストラクタ"")
super().__init__()
self.value *= 3
```
C のコンストラクタが呼ばれ、次に super().__init__() で A.__init__() へ進む。

A.__init__()
```
print(""Aのコンストラクタ"")
self.value = 5
```
A のコンストラクタが呼ばれ、self.value に 5 をセット。
📌 value の変化
A.__init__()

self.value = 5
C.__init__()

self.value *= 3 → 5 × 3 = 15
B.__init__()

self.value -= 2 → 15 - 2 = 13

📌 実際の出力
Dのコンストラクタ
Bのコンストラクタ
Cのコンストラクタ
Aのコンストラクタ
13

📌 まとめ
MRO に従い、D → B → C → A の順で __init__() が実行される！
value の変更は A → C → B の順で行われ、最終的に 13 となる！
💡 この問題では、MRO の順序と super() の挙動を正しく理解することが重要です！ 😊",4,3,
331,"以下のコードを実行すると、出力されるのは？
```
class A:
    def __init__(self):
        print(""Aのコンストラクタ"")
        self.value = 2

class B(A):
    def __init__(self):
        print(""Bのコンストラクタ"")
        super().__init__()
        self.value **= 3  # value を 3乗する

class C(A):
    def __init__(self):
        print(""Cのコンストラクタ"")
        super().__init__()
        self.value += 5  # value に 5 を加算

class D(B, C):
    def __init__(self):
        print(""Dのコンストラクタ"")
        super().__init__()

obj = D()
print(obj.value)
```
1️⃣ Dのコンストラクタ → Bのコンストラクタ → Cのコンストラクタ → Aのコンストラクタ → 7
2️⃣ Dのコンストラクタ → Bのコンストラクタ → Cのコンストラクタ → Aのコンストラクタ → 512
3️⃣ Dのコンストラクタ → Bのコンストラクタ → Cのコンストラクタ → Aのコンストラクタ → 343
4️⃣ Dのコンストラクタ → Cのコンストラクタ → Bのコンストラクタ → Aのコンストラクタ → 49","3️⃣ Dのコンストラクタ → Bのコンストラクタ → Cのコンストラクタ → Aのコンストラクタ → 343","この問題では、MRO（Method Resolution Order） に基づいて super().__init__() がどの順で呼ばれるかを理解し、value の変化を追うことがポイントです。

📌 MRO（メソッド解決順序）を確認
クラスの継承関係：

class D(B, C)
class B(A)
class C(A)

👉 MROの順番
PythonのMROは、C3線形化アルゴリズム に基づき、クラスの継承順を決定します。
D(B, C) の MRO は以下のようになります：

D → B → C → A
つまり、super().__init__() はこの順で呼び出されます。

📌 各クラスの __init__() の実行順
D.__init__()
```
print(""Dのコンストラクタ"")
super().__init__()
D のコンストラクタが呼ばれ、次に super().__init__() で B.__init__() へ進む。
B.__init__()

print(""Bのコンストラクタ"")
super().__init__()
self.value **= 3
```
B のコンストラクタが呼ばれ、次に super().__init__() で C.__init__() へ進む。

C.__init__()
```
print(""Cのコンストラクタ"")
super().__init__()
self.value += 5
```
C のコンストラクタが呼ばれ、次に super().__init__() で A.__init__() へ進む。

A.__init__()
```
print(""Aのコンストラクタ"")
self.value = 2
```
A のコンストラクタが呼ばれ、self.value に 2 をセット。

📌 value の変化
A.__init__()
```
self.value = 2
```
C.__init__()
```
self.value += 5 → 2 + 5 = 7
```
B.__init__()
```
self.value **= 3 → 7³ = 343
```
📌 実際の出力
Dのコンストラクタ
Bのコンストラクタ
Cのコンストラクタ
Aのコンストラクタ
343

📌 まとめ
MRO に従い、D → B → C → A の順で __init__() が実行される！
value の変更は A → C → B の順で行われ、最終的に 343 となる！
💡 MRO の順番と super() の処理順をしっかり意識しよう！ 😃",4,3,
332,"以下のコードを実行すると、出力されるのは？
```
class A:
    def __init__(self):
        print(""Aのコンストラクタ"")
        self.value = 10

    def show(self):
        print(f""A: {self.value}"")

class B(A):
    def __init__(self):
        print(""Bのコンストラクタ"")
        super().__init__()
        self.value += 5

    def show(self):
        print(f""B: {self.value}"")

class C(A):
    def __init__(self):
        print(""Cのコンストラクタ"")
        super().__init__()
        self.value *= 2

    def show(self):
        print(f""C: {self.value}"")

class D(B, C):
    def __init__(self):
        print(""Dのコンストラクタ"")
        super().__init__()

obj = D()
obj.show()
```
1️⃣ Dのコンストラクタ → Bのコンストラクタ → Cのコンストラクタ → Aのコンストラクタ → B: 25
2️⃣ Dのコンストラクタ → Bのコンストラクタ → Cのコンストラクタ → Aのコンストラクタ → B: 20
3️⃣ Dのコンストラクタ → Bのコンストラクタ → Cのコンストラクタ → Aのコンストラクタ → C: 30
4️⃣ Dのコンストラクタ → Bのコンストラクタ → Cのコンストラクタ → Aのコンストラクタ → C: 40","1️⃣ Dのコンストラクタ → Bのコンストラクタ → Cのコンストラクタ → Aのコンストラクタ → B: 25","この問題のポイントは、MRO（Method Resolution Order） に基づく super().__init__() の実行順と、value の変更がどのように影響するかを理解することです。

📌 MRO（メソッド解決順序）を確認
クラスの継承関係：
class D(B, C)
class B(A)
class C(A)

👉 MROの順番
Pythonの C3線形化アルゴリズム に基づく MRO は以下のようになります：
D → B → C → A

つまり、super().__init__() はこの順で呼び出されます。

📌 各クラスの __init__() の実行順
D.__init__()
```
print(""Dのコンストラクタ"")
super().__init__()
```
D のコンストラクタが呼ばれ、super().__init__() で B.__init__() へ進む。

B.__init__()
```
print(""Bのコンストラクタ"")
super().__init__()
self.value += 5
```
B のコンストラクタが呼ばれ、super().__init__() で C.__init__() へ進む。

C.__init__()
```
print(""Cのコンストラクタ"")
super().__init__()
self.value *= 2
```
C のコンストラクタが呼ばれ、super().__init__() で A.__init__() へ進む。

A.__init__()
```
print(""Aのコンストラクタ"")
self.value = 10
```
A のコンストラクタが呼ばれ、self.value に 10 をセット。

📌 value の変化
A.__init__()
self.value = 10

C.__init__()
self.value *= 2 → 10 × 2 = 20

B.__init__()
self.value += 5 → 20 + 5 = 25

📌 obj.show() の動作
obj.show() は D に show() がないため、B から継承されたメソッドを実行
B.show() が呼ばれ、""B: 25"" が出力される
📌 実際の出力
Dのコンストラクタ
Bのコンストラクタ
Cのコンストラクタ
Aのコンストラクタ
B: 25

📌 まとめ
MRO に従い、D → B → C → A の順で __init__() が実行される！
value の変更は A → C → B の順で行われ、最終的に 25 となる！
メソッド解決順序により B.show() が呼ばれるため、B: 25 が表示される！

💡 MRO の順番と super() の処理順をしっかり意識しよう！ 😃",4,3,
333,"以下のコードを実行すると、出力されるのは？
```python
class A:
    def __init__(self):
        print(""Aのコンストラクタ"")
        self.value = 100

    def show(self):
        print(f""A: {self.value}"")

class B(A):
    def __init__(self):
        print(""Bのコンストラクタ"")
        super().__init__()
        self.value -= 30

    def show(self):
        print(f""B: {self.value}"")

class C(A):
    def __init__(self):
        print(""Cのコンストラクタ"")
        super().__init__()
        self.value //= 2

    def show(self):
        print(f""C: {self.value}"")

class D(B, C):
    def __init__(self):
        print(""Dのコンストラクタ"")
        super().__init__()

    def show(self):
        print(f""D: {self.value}"")

obj = D()
obj.show()

1️⃣ `Dのコンストラクタ → Bのコンストラクタ → Cのコンストラクタ → Aのコンストラクタ → D: 35`  
2️⃣ `Dのコンストラクタ → Bのコンストラクタ → Cのコンストラクタ → Aのコンストラクタ → D: 50`  
3️⃣ Dのコンストラクタ → Bのコンストラクタ → Cのコンストラクタ → Aのコンストラクタ → D: 20
4️⃣ `Dのコンストラクタ → Bのコンストラクタ → Cのコンストラクタ → Aのコンストラクタ → D: 100`  ","3️⃣ Dのコンストラクタ → Bのコンストラクタ → Cのコンストラクタ → Aのコンストラクタ → D: 20","📌 MRO（メソッド解決順序）を確認
クラスの継承関係：
class D(B, C)
class B(A)
class C(A)

👉 MRO（メソッド解決順序）
D → B → C → A
つまり、super().__init__() の呼び出し順は D → B → C → A となる。

📌 value の変化を確認
A.__init__()
```
self.value = 100
```
C.__init__()
```
self.value //= 2 → 100 // 2 = 50
```
B.__init__()
```
self.value -= 30 → 50 - 30 = 20
```
📌 obj.show() の動作
obj.show() は D.show() を実行するため、""D: 20"" が出力される。

📌 実際の出力
Dのコンストラクタ
Bのコンストラクタ
Cのコンストラクタ
Aのコンストラクタ
D: 20

📌 正しい選択肢
正解は Dのコンストラクタ → Bのコンストラクタ → Cのコンストラクタ → Aのコンストラクタ → D: 20
が、選択肢にない！！😱💦

📌 修正後の選択肢
1️⃣ Dのコンストラクタ → Bのコンストラクタ → Cのコンストラクタ → Aのコンストラクタ → D: 35
2️⃣ Dのコンストラクタ → Bのコンストラクタ → Cのコンストラクタ → Aのコンストラクタ → D: 50
3️⃣ Dのコンストラクタ → Bのコンストラクタ → Cのコンストラクタ → Aのコンストラクタ → D: 20 ✅ （これが正解！）
4️⃣ Dのコンストラクタ → Bのコンストラクタ → Cのコンストラクタ → Aのコンストラクタ → D: 100

📌 まとめ
💡 MRO の順番をしっかり理解し、値がどのように変化するかを追うことがポイント！",4,3,
334,"以下のコードを実行すると、出力されるのは？
```
class A:
    def __init__(self):
        print(""Aのコンストラクタ"")
        self.value = 5

    def show(self):
        print(f""A: {self.value}"")

class B(A):
    def __init__(self):
        print(""Bのコンストラクタ"")
        super().__init__()
        self.value *= 3

    def show(self):
        print(f""B: {self.value}"")

class C(A):
    def __init__(self):
        print(""Cのコンストラクタ"")
        super().__init__()
        self.value += 7

    def show(self):
        print(f""C: {self.value}"")

class D(B, C):
    def __init__(self):
        print(""Dのコンストラクタ"")
        super().__init__()

    def show(self):
        print(f""D: {self.value}"")

obj = D()
obj.show()
```
1️⃣ Dのコンストラクタ → Bのコンストラクタ → Cのコンストラクタ → Aのコンストラクタ → D: 12
2️⃣ Dのコンストラクタ → Bのコンストラクタ → Cのコンストラクタ → Aのコンストラクタ → D: 36
3️⃣ Dのコンストラクタ → Bのコンストラクタ → Cのコンストラクタ → Aのコンストラクタ → D: 18
4️⃣ Dのコンストラクタ → Bのコンストラクタ → Cのコンストラクタ → Aのコンストラクタ → D: 42","2️⃣ Dのコンストラクタ → Bのコンストラクタ → Cのコンストラクタ → Aのコンストラクタ → D: 36","この問題のポイントも MRO（メソッド解決順序） に従う super().__init__() の動作と、
value の変更がどのように影響するかを理解することです。

📌 MRO（メソッド解決順序）を確認
クラスの継承関係：
class D(B, C)
class B(A)
class C(A)

👉 MRO（メソッド解決順序）
D → B → C → A
つまり、super().__init__() の呼び出し順は D → B → C → A となる。

📌 value の変化を確認
A.__init__()
```
self.value = 5
```
C.__init__()
```
self.value += 7 → 5 + 7 = 12
```
B.__init__()
```
self.value *= 3 → 12 × 3 = 36
```
📌 obj.show() の動作
obj.show() は D.show() を実行するため、""D: 36"" が出力される。

📌 実際の出力
Dのコンストラクタ
Bのコンストラクタ
Cのコンストラクタ
Aのコンストラクタ
D: 36

📌 まとめ
MRO に従い、D → B → C → A の順で __init__() が実行される！
value の変更は A → C → B の順で行われ、最終的に 36 となる！
メソッド解決順序により D.show() が呼ばれ、D: 36 が表示される！",4,3,
335,"以下のコードを実行すると、出力されるのは？
```
def greet():
    return ""こんにちは！""

print(greet())
```
1️⃣ こんにちは！（画面に表示されるそのままの形）
2️⃣ 'こんにちは！'（シングルクォート付き）
3️⃣ ""こんにちは！""（ダブルクォート付き）
4️⃣ None

💡 まずはシンプルな関数の基本から！✨","1️⃣ こんにちは！（画面に表示されるそのままの形）","この問題は、関数の return と print() の動作の違い を理解するのがポイント！💡

📌 コードの動作
```
def greet():
    return ""こんにちは！""

print(greet())
```
1.関数 greet() を定義

return ""こんにちは！"" により、 ""こんにちは！"" を返す関数になる。
print(greet()) を実行

2.greet() が ""こんにちは！"" を返す。
print() により ""こんにちは！"" のクォートが 省略されて こんにちは！ と画面に表示される。

📌 選択肢の解説
1️⃣ ✅ こんにちは！ → 正解！ print() によって クォートなしの形で表示される。
2️⃣ ❌ 'こんにちは！'（シングルクォート付き） → 間違い！ Python の print() はクォートを表示しない。
3️⃣ ❌ ""こんにちは！""（ダブルクォート付き） → 間違い！ Python の print() の出力とは異なる表記。
4️⃣ ❌ None → 間違い！ return ""こんにちは！"" により、None にはならない。

📌 まとめ
✔ return は 関数の結果を返す
✔ print() を使うと、return の値が クォートなし で画面に表示される
✔ 出力される値の表記に注意！ (こんにちは！ と ""こんにちは！"" の違い)

",3,1,
336,"以下のコードを実行すると、出力されるのは？
```
def add(a, b):
    return a + b

print(add(3, 5))
```
1️⃣ 3 + 5
2️⃣ 35
3️⃣ 8
4️⃣ エラーが発生する","3️⃣ 8","この問題は、関数の引数と return の動作 を理解するのがポイント！💡

📌 コードの動作
```
def add(a, b):
    return a + b

print(add(3, 5))
```
1.関数 add(a, b) を定義

a と b の 2つの引数 を受け取る。
return a + b により、a と b の和を返す。
print(add(3, 5)) を実行

2.add(3, 5) を呼び出すと、3 + 5 が計算されて 8 になる。

3.print(8) により、画面に 8 が表示される。

📌 選択肢の解説
1️⃣ ❌ 3 + 5 → 間違い！ return は計算結果の 値 を返すため、3 + 5 という計算式のまま出力はされない。
2️⃣ ❌ 35 → 間違い！ これは 文字列の連結 の場合に起こる（""3"" + ""5"" → ""35""）。このコードでは int 型の加算なので発生しない。
3️⃣ ✅ 8 → 正解！ 3 + 5 の結果が return され、print() で表示される。
4️⃣ ❌ エラーが発生する → 間違い！ 正しい構文で書かれているため、エラーは発生しない。

📌 まとめ
✔ 関数の引数 は () の中に指定する。
✔ return は計算結果の値を返す（式ではなく、実際の数値が返る！）。
✔ print() で return の結果を表示 する。",3,1,
337,"以下のコードを実行すると、出力されるのは？
```
def multiply(x, y=2):
    return x * y

print(multiply(4))
```
1️⃣ 4
2️⃣ 8
3️⃣ エラーが発生する
4️⃣ None","2️⃣ 8","この問題は、デフォルト引数の動作 を理解するのがポイント！💡

📌 コードの動作
```
def multiply(x, y=2):
    return x * y

print(multiply(4))
```
1.関数 multiply(x, y=2) を定義

x は 必須引数（指定しないとエラーになる）。
y=2 は デフォルト引数（値が指定されなかった場合に 2 を使う）。
multiply(4) を実行

2.y の値を指定していないため、デフォルトの y=2 が適用される。
4 * 2 を計算し、8 を return する。

3.print(8) により、画面に 8 が表示される。

📌 選択肢の解説
1️⃣ ❌ 4 → 間違い！ x=4, y=2 なので 4 * 2 = 8 になる。
2️⃣ ✅ 8 → 正解！ multiply(4) は 4 * 2 となり、8 が出力される。
3️⃣ ❌ エラーが発生する → 間違い！ y はデフォルト引数があるため、エラーにならない。
4️⃣ ❌ None → 間違い！ return で計算結果を返しているので None にはならない。

📌 まとめ
✔ デフォルト引数は、値を指定しなかった場合に適用される！
✔ 関数を呼び出すときにデフォルト引数を省略できる！
✔ デフォルト引数がある場合、関数をより柔軟に使える！",3,1,
338,"以下のコードを実行すると、出力されるのは？
```
def greet(name, message=""こんにちは""):
    return f""{message}, {name}!""

print(greet(""太郎""))
```
1️⃣ ""こんにちは, 太郎!""
2️⃣ ""太郎, こんにちは!""
3️⃣ ""エラーが発生する""
4️⃣ ""None""","1️⃣ ""こんにちは, 太郎!""","この問題は、デフォルト引数の動作 を理解するのがポイント！💡

📌 コードの動作
```
def greet(name, message=""こんにちは""):
    return f""{message}, {name}!""

print(greet(""太郎""))
```
1.関数 greet(name, message=""こんにちは"") を定義
 name は 必須引数（省略不可）。
 message=""こんにちは"" は デフォルト引数（省略時は ""こんにちは"" を使う）。

2. greet(""太郎"") を実行
 message は指定されていないので、デフォルトの ""こんにちは"" が適用される。
 return f""{message}, {name}!"" のため、""こんにちは, 太郎!"" を返す。

3.print(""こんにちは, 太郎!"") により、画面に ""こんにちは, 太郎!"" が表示される。

📌 選択肢の解説
1️⃣ ✅ ""こんにちは, 太郎!"" → 正解！ message のデフォルト値 ""こんにちは"" が適用される。
2️⃣ ❌ ""太郎, こんにちは!"" → 間違い！ {message}, {name}! の順番なので、""こんにちは, 太郎!"" になる。
3️⃣ ❌ ""エラーが発生する"" → 間違い！ name は指定されているのでエラーにならない。
4️⃣ ❌ ""None"" → 間違い！ return により ""こんにちは, 太郎!"" を返しているので None にはならない。

📌 まとめ
✔ デフォルト引数は、省略されたときに自動で適用される！
✔ デフォルト引数を使うと、関数の使い勝手が向上する！
✔ f""{message}, {name}!"" のフォーマットを理解しよう！",3,1,
339,"以下のコードを実行すると、出力されるのは？
```
def power(base, exponent=2):
    return base ** exponent

print(power(3))
```
1️⃣ 6
2️⃣ 9
3️⃣ エラーが発生する
4️⃣ None","2️⃣ 9","この問題は、デフォルト引数とべき乗（累乗）演算 ** を理解するのがポイント！💡

📌 コードの動作
```
def power(base, exponent=2):
    return base ** exponent

print(power(3))
```
1.関数 power(base, exponent=2) を定義
  base は 必須引数（省略不可）。
  exponent=2 は デフォルト引数（省略時は 2 を使う）。
  return base ** exponent により base を exponent 乗する。

2.power(3) を実行
  exponent を指定していないため、デフォルト値 2 が適用される。

3 ** 2（3の2乗）を計算し、9 を return する。
print(9) により、画面に 9 が表示される。

📌 選択肢の解説
1️⃣ ❌ 6 → 間違い！ ** は累乗演算子なので 3 ** 2 = 9 となる。掛け算 3 * 2 ではない。
2️⃣ ✅ 9 → 正解！ power(3) は 3 ** 2 となり、9 が出力される。
3️⃣ ❌ エラーが発生する → 間違い！ exponent にはデフォルト値 2 があるため、エラーは発生しない。
4️⃣ ❌ None → 間違い！ return により 9 を返しているので None にはならない。

📌 まとめ
✔ デフォルト引数は、省略されたときに適用される！
✔ 累乗（べき乗）演算子 ** を理解しよう！（x ** y は x の y 乗を計算）
✔ power(3, 4) のように引数を渡せば、任意のべき乗計算が可能！",3,1,
340,"以下のコードを実行すると、出力されるのは？
```
def divide(a, b=2):
    return a / b

print(divide(10))
```
1️⃣ 5.0
2️⃣ 5
3️⃣ エラーが発生する
4️⃣ None","1️⃣ 5.0","この問題は、デフォルト引数と除算 / の動作 を理解するのがポイント！💡

📌 コードの動作
```
def divide(a, b=2):
    return a / b

print(divide(10))
```
1.関数 divide(a, b=2) を定義
  a は 必須引数（省略不可）。
  b=2 は デフォルト引数（省略時は 2 を使う）。
  return a / b により、a を b で割る。

2.divide(10) を実行
  b を指定していないため、デフォルト値 2 が適用される。
  10 / 2 を計算し、結果は 5.0（浮動小数点数）。

3.print(5.0) により、画面に 5.0 が表示される。

📌 選択肢の解説
1️⃣ ✅ 5.0 → 正解！ Python の 除算 / は必ず float 型 (5.0) を返す。
2️⃣ ❌ 5 → 間違い！ 10 / 2 の結果は 5.0（小数）であり、5（整数）にはならない。
3️⃣ ❌ エラーが発生する → 間違い！ b のデフォルト値があるのでエラーは発生しない。
4️⃣ ❌ None → 間違い！ return により 5.0 を返しているので None にはならない。

📌 まとめ
✔ Python の除算 / は、結果が整数でも float 型を返す！
✔ 整数の割り算で整数が欲しい場合は //（切り捨て除算）を使う！
✔ デフォルト引数を使うと、関数の使い勝手が向上する！",3,1,
341,"以下のコードを実行すると、出力されるのは？
```
def repeat_string(s, n=3):
    return s * n

print(repeat_string(""Python""))
```
1️⃣ ""PythonPythonPython""
2️⃣ ""Python 3""
3️⃣ エラーが発生する
4️⃣ None","1️⃣ ""PythonPythonPython""","この問題は、デフォルト引数と文字列の繰り返し演算 * を理解するのがポイント！💡

📌 コードの動作
```
def repeat_string(s, n=3):
    return s * n

print(repeat_string(""Python""))
```
1.関数 repeat_string(s, n=3) を定義
  s は 必須引数（省略不可）。
  n=3 は デフォルト引数（省略時は 3 を使う）。
  return s * n により、文字列 s を n 回繰り返す。

2.repeat_string(""Python"") を実行
  n を指定していないため、デフォルト値 3 が適用される。
 ""Python"" * 3 となり、""PythonPythonPython"" を return する。

3.print(""PythonPythonPython"") により、画面に ""PythonPythonPython"" が表示される。

📌 選択肢の解説
1️⃣ ✅ ""PythonPythonPython"" → 正解！ ""Python"" が 3 回繰り返される。
2️⃣ ❌ ""Python 3"" → 間違い！ n=3 は文字列と結合されるのではなく、繰り返し回数 を意味する。
3️⃣ ❌ エラーが発生する → 間違い！ s は必須引数として渡されており、デフォルト引数 n=3 も有効なのでエラーにはならない。
4️⃣ ❌ None → 間違い！ return により ""PythonPythonPython"" を返しているので None にはならない。

📌 まとめ
✔ 文字列 * 数値 で、文字列を指定回数繰り返せる！
✔ デフォルト引数を使うと、省略時に適用される値を設定できる！
✔ 文字列と数値を + で結合するとエラーになるが、* なら繰り返し演算ができる！",3,1,
342,"以下のコードを実行すると、出力されるのは？
```
def add_numbers(a, b=5, c=10):
    return a + b + c

print(add_numbers(2))
```
1️⃣ 17
2️⃣ 15
3️⃣ エラーが発生する
4️⃣ None","1️⃣ 17","この問題は、デフォルト引数の動作 を理解するのがポイント！💡

📌 コードの動作
```
def add_numbers(a, b=5, c=10):
    return a + b + c

print(add_numbers(2))
```
1.関数 add_numbers(a, b=5, c=10) を定義
  a は 必須引数（省略不可）。
  b=5 と c=10 は デフォルト引数（省略時は 5 と 10 が使われる）。
  return a + b + c で 3 つの値を加算して返す。

2.add_numbers(2) を実行
  a=2（引数として指定）。
  b は省略されたのでデフォルト値 5 が適用される。
  c も省略されたのでデフォルト値 10 が適用される。
  2 + 5 + 10 = 17 となる。

3.print(17) により、画面に 17 が表示される。

📌 選択肢の解説
1️⃣ ✅ 17 → 正解！ 2 + 5 + 10 = 17
2️⃣ ❌ 15 → 間違い！ b=5、c=10 のデフォルト引数を考慮しないといけない。
3️⃣ ❌ エラーが発生する → 間違い！ デフォルト引数があるため、エラーにはならない。
4️⃣ ❌ None → 間違い！ return により 17 を返しているので None にはならない。

📌 まとめ
✔ デフォルト引数を指定すると、引数を省略しても関数が動作する！
✔ デフォルト引数は左から順に適用される！
✔ 明示的に値を渡せば、デフォルト値を上書きできる！",3,1,
343,"以下のコードを実行すると、出力されるのは？
```
def multiply(a, b=2):
    return a * b

print(multiply(4, 3))
```
1️⃣ 6
2️⃣ 8
3️⃣ 12
4️⃣ エラーが発生する","3️⃣ 12","この問題は、デフォルト引数の動作と明示的な引数の優先度 を理解するのがポイント！💡

📌 コードの動作
```
def multiply(a, b=2):
    return a * b

print(multiply(4, 3))
```
1.関数 multiply(a, b=2) を定義
  a は 必須引数（省略不可）。
  b=2 は デフォルト引数（省略時は 2 が使われる）。
  return a * b で 2 つの値を掛け算する。

2.multiply(4, 3) を実行
  a=4（引数として指定）。
  b=3（明示的に指定されたため、デフォルト値 2 は無視される）。
  4 * 3 = 12 となる。

3.print(12) により、画面に 12 が表示される。

📌 選択肢の解説
1️⃣ ❌ 6 → 間違い！ 2 * 3 ではなく、4 * 3 なので 6 にはならない。
2️⃣ ❌ 8 → 間違い！ b の値は 3 なので、4 * 2 ではない。
3️⃣ ✅ 12 → 正解！ 4 * 3 = 12
4️⃣ ❌ エラーが発生する → 間違い！ 引数が正しく渡されているため、エラーにはならない。

📌 まとめ
✔ デフォルト引数は、省略時に適用されるが、明示的に指定するとその値が優先される！
✔ デフォルト引数を設定しておくと、省略可能な引数を作ることができる！
✔ デフォルト値が使われるかどうかは、関数を呼び出す際の引数の指定に依存する！",3,1,
344,"以下のコードを実行すると、出力されるのは？
```
def divide(a, b=2):
    return a / b

print(divide(10))
```
1️⃣ 5.0
2️⃣ 5
3️⃣ エラーが発生する
4️⃣ None","1️⃣ 5.0","この問題では、デフォルト引数を使った割り算 の動作を理解するのがポイント！💡

📌 コードの動作
```
def divide(a, b=2):
    return a / b

print(divide(10))
```
1.関数 divide(a, b=2) を定義
  a は 必須引数（省略不可）。
  b=2 は デフォルト引数（省略時は 2 が使われる）。
  return a / b で a を b で割った値を返す。

2.divide(10) を実行
  a=10（引数として指定）。
  b は省略されたのでデフォルト値 2 が適用される。
  10 / 2 = 5.0 となる。

3.print(5.0) により、画面に 5.0 が表示される。

📌 選択肢の解説
1️⃣ ✅ 5.0 → 正解！ 10 / 2 = 5.0
2️⃣ ❌ 5 → 間違い！ /（除算） の結果は float（浮動小数点数）になるため、5.0 で出力される。
3️⃣ ❌ エラーが発生する → 間違い！ b にはデフォルト値 2 があるのでエラーにはならない。
4️⃣ ❌ None → 間違い！ return により 5.0 を返しているので None にはならない。

📌 まとめ
✔ デフォルト引数は、省略時に適用されるが、明示的に指定するとその値が優先される！
✔ Python の /（除算） は、整数同士の計算でも float（浮動小数点数） になる！
✔ 整数の商を求めたい場合は //（整数除算） を使う！",3,1,
345,"以下のコードを実行すると、出力されるのは？
```
def add_numbers(a, b=5, c=10):
    return a + b + c

print(add_numbers(3, c=7))
```
1️⃣ 15
2️⃣ 20
3️⃣ 25
4️⃣ エラーが発生する","1️⃣ 15","この問題では、デフォルト引数とキーワード引数の動作 を理解するのがポイント！💡

📌 コードの動作
```
def add_numbers(a, b=5, c=10):
    return a + b + c

print(add_numbers(3, c=7))
```
1.関数 add_numbers(a, b=5, c=10) を定義
 a は 必須引数（省略不可）。
 b=5、c=10 は デフォルト引数（省略時はこの値が適用される）。
 return a + b + c で 3 つの数値を加算して返す。

2.add_numbers(3, c=7) を実行
 a=3（引数として指定）。
 c=7（キーワード引数として明示的に指定）。
 b は省略されているのでデフォルト値 5 が適用される。
 3 + 5 + 7 = 15 となる。

3.print(15) により、画面に 15 が表示される。

📌 選択肢の解説
1️⃣ ✅ 15 → 正解！ 3 + 5 + 7 = 15
2️⃣ ❌ 20 → 間違い！ b=5 が適用されるため、b=10 ではない。
3️⃣ ❌ 25 → 間違い！ b の値は 5 なので 3 + 10 + 7 ではない。
4️⃣ ❌ エラーが発生する → 間違い！ b は省略可能なデフォルト引数なのでエラーにならない。

📌 まとめ
✔ デフォルト引数は、省略時に適用されるが、キーワード引数を指定するとその値が優先される！
✔ キーワード引数を使うと、引数の順番を変えて指定することが可能！
✔ デフォルト引数の適用ルールを理解すると、柔軟な関数を作成できる！",3,1,
346,"以下のコードを実行すると、出力されるのは？
```
def sum_numbers(*args):
    return sum(args)

print(sum_numbers(1, 2, 3, 4, 5))
```
1️⃣ 15
2️⃣ [1, 2, 3, 4, 5]
3️⃣ (1, 2, 3, 4, 5)
4️⃣ エラーが発生する","1️⃣ 15","この問題では、可変長引数 *args の動作 を理解するのがポイント！💡

📌 コードの動作
```
def sum_numbers(*args):
    return sum(args)

print(sum_numbers(1, 2, 3, 4, 5))
```
1.sum_numbers(*args) を定義
*args を使うことで、引数の数に制限なく値を受け取れるようになる。
sum(args) により、渡されたすべての値を合計して返す。

2.sum_numbers(1, 2, 3, 4, 5) を実行
args には (1, 2, 3, 4, 5) という タプル が渡される。
sum(args) によって 1 + 2 + 3 + 4 + 5 = 15 となる。

3.print(15) により、画面に 15 が表示される。

📌 選択肢の解説
1️⃣ ✅ 15 → 正解！ sum(args) により、合計が計算される。
2️⃣ ❌ [1, 2, 3, 4, 5] → 間違い！ args はリストではなく、タプルとして渡される。
3️⃣ ❌ (1, 2, 3, 4, 5) → 間違い！ args はタプルだが、そのまま返されるわけではない。
4️⃣ ❌ エラーが発生する → 間違い！ *args は正しく処理され、エラーは発生しない。

📌 まとめ
✔ *args は可変長引数で、複数の引数をタプルとして受け取る！
✔ sum(args) でタプル内のすべての数値を合計できる！
✔ 可変長引数を使うと、引数の数を気にせずに関数を設計できる！",3,2,
347,"以下のコードを実行すると、出力されるのは？
```
def greet(**kwargs):
    return f""こんにちは、{kwargs['name']} さん！""

print(greet(name=""太郎""))
```
1️⃣ ""こんにちは、太郎 さん！""
2️⃣ {""name"": ""太郎""}
3️⃣ (""name"", ""太郎"")
4️⃣ エラーが発生する","1️⃣ ""こんにちは、太郎 さん！""","この問題では、キーワード可変長引数 **kwargs の動作 を理解するのがポイント！💡

📌 コードの動作
```
def greet(**kwargs):
    return f""こんにちは、{kwargs['name']} さん！""

print(greet(name=""太郎""))
```
1.greet(**kwargs) を定義
  **kwargs はキーワード引数を辞書として受け取る仕組み。
  kwargs['name'] により、辞書のキー ""name"" に対応する値を取得できる。

2.greet(name=""太郎"") を実行
  kwargs = {""name"": ""太郎""} のように辞書として渡される。
  return f""こんにちは、{kwargs['name']} さん！"" により、""こんにちは、太郎 さん！"" が返される。
3.print(""こんにちは、太郎 さん！"") により、画面に ""こんにちは、太郎 さん！"" が表示される。

📌 選択肢の解説
1️⃣ ✅ ""こんにちは、太郎 さん！"" → 正解！ キーワード引数の値を取得して正しく動作する。
2️⃣ ❌ {""name"": ""太郎""} → 間違い！ kwargs は辞書だが、関数の戻り値は f-string を使った文字列。
3️⃣ ❌ (""name"", ""太郎"") → 間違い！ **kwargs は辞書型であり、タプルにはならない。
4️⃣ ❌ エラーが発生する → 間違い！ kwargs['name'] で正しく値を取得できるため、エラーにはならない。

📌 まとめ
✔ **kwargs はキーワード引数を辞書として受け取る！
✔ kwargs['キー名'] を使うと、対応する値を取得できる！
✔ 柔軟な関数設計が可能になり、実務でもよく使われる！",3,2,
348,"以下のコードを実行すると、出力されるのは？
```
def func(a, b=5, *args, c=10, **kwargs):
    return a + b + sum(args) + c + sum(kwargs.values())

print(func(1, 2, 3, 4, c=5, d=6, e=7))
```
1️⃣ 33
2️⃣ 28
3️⃣ 30
4️⃣ エラーが発生する","2️⃣ 28","この問題では、引数の順番と *args, **kwargs の動作 を理解するのがポイント！💡

📌 コードの動作
```
def func(a, b=5, *args, c=10, **kwargs):
    return a + b + sum(args) + c + sum(kwargs.values())

print(func(1, 2, 3, 4, c=5, d=6, e=7))
```
✅ 1. 引数の分類
関数 func の引数は次のように分類される：
  a → 通常の引数（必須）
  b=5 → デフォルト値を持つ引数
  *args → 可変長引数（タプル）
  c=10 → デフォルト値を持つキーワード引数
  **kwargs → キーワード可変長引数（辞書）
✅ 2. func(1, 2, 3, 4, c=5, d=6, e=7) を実行すると
渡された引数はこのように分類される：
 a = 1
 b = 2（デフォルト 5 ではなく、渡された 2 が使われる）
 *args = (3, 4)（タプルに入る）
 c = 5（デフォルト 10 ではなく、指定された 5 が使われる）
 **kwargs = {""d"": 6, ""e"": 7}（辞書として渡される）
✅ 3. 計算をする
a + b + sum(args) + c + sum(kwargs.values())
に値を代入すると：

1 + 2 + (3 + 4) + 5 + (6 + 7)
= 1 + 2 + 7 + 5 + 13
= 28

よって 28 が出力される！

📌 選択肢の解説
1️⃣ ❌ 33 → 間違い！ sum(kwargs.values()) の計算を誤ると 33 になるかも。
2️⃣ ✅ 28 → 正解！ 1 + 2 + 7 + 5 + 13 = 28 になる。
3️⃣ ❌ 30 → 間違い！ c の値を 10 として計算すると 30 になるが、今回は 5 に変更されている。
4️⃣ ❌ エラーが発生する → 間違い！ 正しく引数が処理されるため、エラーは発生しない。

📌 まとめ
✔ *args は通常の引数の後に、タプルとしてすべて受け取る！
✔ **kwargs はキーワード引数を辞書として受け取る！
✔ 引数の順番を正しく理解し、デフォルト値との組み合わせを考えることが重要！",3,2,
349,"以下のコードを実行したときの出力を選択してください。
```
def outer(x):
    def inner(y):
        nonlocal x
        x += y
        return x
    return inner

closure = outer(5)
print(closure(3))
print(closure(2))
```
1️⃣ 8 → 10
2️⃣ 8 → 7
3️⃣ 3 → 5
4️⃣ Error（エラーが発生する）

","1️⃣ 8 → 10","このコードでは、クロージャ（closure） の仕組みと nonlocal キーワード の動作を確認する問題です。

📝 コードの流れ
```
def outer(x):
    def inner(y):
        nonlocal x  # `outer` のスコープの `x` を変更可能にする
        x += y  # `x` に `y` を加算
        return x
    return inner  # `inner` 関数を返す
```
1.outer(5) を呼び出すと、x = 5 を持つ inner 関数を返す。
2.closure = outer(5) なので、closure は inner 関数を指す。
3.closure(3) を実行すると:
 ・x は 5 だったが、x += 3 により 8 になる。
 ・return x で 8 を返す。
4.closure(2) を実行すると:
 ・x の値は保持されたまま（nonlocal により outer の x を変更している）。
 ・x += 2 により 10 になる。
 ・return x で 10 を返す。

💡 ポイント
✅ クロージャとは？
　関数 inner は outer のスコープ内の変数 x を参照し続ける。
　そのため、closure を使うと x の値が維持される。

✅ nonlocal x の役割
　inner の x は通常 inner 内のローカル変数として扱われるが、
　nonlocal x を使うことで outer の x を更新可能 になる。",3,3,
350,"以下のコードを実行したときの出力を選択してください。
```
def func(a, b, c):
    return a + b + c

args = (2, 3)
kwargs = {'c': 4}

print(func(*args, **kwargs))
```

1️⃣ 9
2️⃣ TypeError（エラーが発生する）
3️⃣ (2, 3) {'c': 4}
4️⃣ None","1️⃣ 9","このコードでは、引数のアンパック（*args と **kwargs） の動作を確認する問題です。

📝 コードの流れ
```
def func(a, b, c):
    return a + b + c
```
1.func は 3 つの引数 a, b, c を受け取る関数。
```
args = (2, 3)  # タプル
kwargs = {'c': 4}  # 辞書
```

2.args には (2, 3) が入っている。
 kwargs には {'c': 4} が入っている。
```
print(func(*args, **kwargs))
```

3.func(*args, **kwargs) の実行：
 *args はタプルを 展開 して渡す → func(2, 3, c=4)
 **kwargs は辞書を キーワード引数として展開 → c=4
 つまり、func(2, 3, 4) と同じ意味になる。

4.func(2, 3, 4) の計算：

return 2 + 3 + 4  # → 9
したがって、正解は 1️⃣ 9 でした！ 🎯

💡 ポイント
✅ *args の役割
　タプルやリストの要素を個別の引数として展開する。
✅ **kwargs の役割
　辞書のキーと値をキーワード引数として展開する。
✅ 組み合わせて使うと…
　関数の柔軟性を高められる！（引数の数が決まっていなくても渡せる）",3,3,
351,"以下のコードを実行したときの出力を選択してください。
```
def counter(start):
    def increment():
        nonlocal start
        start += 1
        return start
    return increment

count = counter(10)
print(count())
print(count())
print(count())
```
1️⃣ 10 → 11 → 12
2️⃣ 11 → 12 → 13
3️⃣ 10 → 10 → 10
4️⃣ Error（エラーが発生する）","2️⃣ 11 → 12 → 13","このコードは、クロージャ（closure） の動作と nonlocal キーワード の影響を理解する問題です。

📝 コードの流れ
```
def counter(start):
    def increment():
        nonlocal start  # 外側の関数 `counter` の `start` を変更可能にする
        start += 1
        return start
    return increment
```
1.counter(10) を呼び出すと、変数 start を 10 として持つ increment 関数 を返す。
2.count = counter(10) により、count は increment を指す。
```
print(count())  # 1回目の呼び出し
```
3.count() を実行すると:
・nonlocal start により counter の start を更新できる。
・start = 10 から start += 1 で 11 になる。
・return start で 11 を出力。
```
print(count())  # 2回目の呼び出し
```
4.count() をもう一度実行すると:
・start = 11 から start += 1 で 12 になる。
・return start で 12 を出力。
```
print(count())  # 3回目の呼び出し
```
5.count() をさらに実行すると:
・start = 12 から start += 1 で 13 になる。
・return start で 13 を出力。

💡 ポイント
✅ クロージャとは？
　関数 increment は counter のスコープ内の変数 start を参照し続ける。
　そのため、count() を呼ぶたびに start の値が更新される。

✅ nonlocal start の役割
　increment の start は通常 increment 内のローカル変数として扱われるが、
　nonlocal start を使うことで counter の start を更新可能 になる。",3,3,
352,"以下のコードを実行したときの出力を選択してください。
```
def modify_list(lst):
    lst.append(4)
    lst = [1, 2, 3]
    return lst

my_list = [10, 20, 30]
result = modify_list(my_list)

print(my_list)
print(result)
```
1️⃣ [10, 20, 30, 4] → [1, 2, 3]
2️⃣ [10, 20, 30] → [1, 2, 3]
3️⃣ [10, 20, 30, 4] → [10, 20, 30, 4]
4️⃣ [1, 2, 3] → [1, 2, 3]","1️⃣ [10, 20, 30, 4] → [1, 2, 3]","このコードでは、ミュータブル（変更可能）なリストの動作とローカル変数の影響を確認します。

📝 コードの流れ
```
def modify_list(lst):
    lst.append(4)  # 🟢 `lst` に `4` を追加（元のリストが変更される）
    lst = [1, 2, 3]  # 🔴 `lst` を新しいリストに置き換え（元のリストとは無関係になる）
    return lst  # `lst` は新しいリスト `[1, 2, 3]` なので、これを返す
```
1.modify_list(my_list) を実行すると:
 lst.append(4) により my_list が [10, 20, 30, 4] に変更 される。
 lst = [1, 2, 3] の代入により、lst は新しいリストを指す。
 return lst により、新しいリスト [1, 2, 3] を返す。
```
my_list = [10, 20, 30]  # 🟢 `my_list` を定義
result = modify_list(my_list)  # 🟢 `modify_list` を実行
```
2.result には modify_list の戻り値 [1, 2, 3] が入る。
```
print(my_list)  # `my_list` の中身は？
```
3.my_list は [10, 20, 30, 4] になる（append(4) による影響）。
```
print(result)  # `result` の中身は？
```
4.result は [1, 2, 3]（関数の return lst の値）。

💡 ポイント
✅ リスト（ミュータブル）の append() は元のリストを変更する
　→ lst.append(4) により my_list も変更される。
✅ ローカル変数 lst に新しいリストを代入しても、元の my_list には影響しない
　→ lst = [1, 2, 3] は lst を新しいリストに置き換えただけ。
　→ my_list の参照は変更されない。",3,3,
353,"以下のコードを実行したときの出力を選択してください。
```
with open(""test.txt"", ""w"", encoding=""utf-8"") as file:
    file.write(""Hello\nWorld"")

with open(""test.txt"", ""r"", encoding=""utf-8"") as file:
    file.seek(6)
    print(file.read(5))  

```
1️⃣ ""World""
2️⃣ ""Hello""
3️⃣ ""Worl""
4️⃣ Error（エラーが発生する）","3️⃣ ""Worl""","このコードでは、ファイルの読み書きと seek() の動作 を確認します。

📝 コードの流れ
1️⃣ ファイルを書き込み
```
with open(""test.txt"", ""w"") as file:
    file.write(""Hello\nWorld"")
```
・""test.txt"" を 書き込みモード（w） で開く。
・file.write(""Hello\nWorld"") を実行
・""Hello\nWorld"" という内容がファイルに保存される。
・\n は 改行文字（LF） なので、ファイルの中身は：
```
Hello
World
```
2️⃣ ファイルを読み込み
```
with open(""test.txt"", ""r"") as file:
    file.seek(6)
    print(file.read(5))
```
・""test.txt"" を 読み込みモード（r） で開く。
・file.seek(6) により、ファイル内の6バイト目の位置に移動 する。

🔹 file.seek(6) の動作
```
Hello\nWorld
```
文字	H	e	l	l	o	\n	W	o	r	l	d
位置	0	1	2	3	4	5	6	7	8	9	10
→ seek(6) なので、""W"" の位置から読み取りを開始。

3️⃣ file.read(5) の動作
現在の位置：6（""W"" の位置）
5バイト読み込む
```
Worl
```
→ ""World"" のうち、5バイトは ""Worl"" で止まる。
したがって、正解は 3️⃣ ""Worl"" ！ 🎯

💡 ポイント
✅ seek(n) はファイル内の位置を n バイト目に移動する。
✅ 改行（\n）も1バイトとしてカウントされる。
✅ read(n) は n バイト分だけ文字を読み取る。",6,3,
354,"以下のコードを実行したときの出力を選択してください。
```
with open(""example.txt"", ""w"") as file:
    file.writelines([""apple\n"", ""banana\n"", ""cherry\n""])

with open(""example.txt"", ""r"") as file:
    print(file.readline().strip())
    file.seek(0)
    print(file.readline().strip())
```
1️⃣ ""apple"" → ""banana""
2️⃣ ""apple"" → ""apple""
3️⃣ ""banana"" → ""apple""
4️⃣ Error（エラーが発生する）","2️⃣ ""apple"" → ""apple""","📝 コードの流れ
1️⃣ ファイルにデータを書き込み
```
with open(""example.txt"", ""w"") as file:
    file.writelines([""apple\n"", ""banana\n"", ""cherry\n""])
""example.txt"" を 書き込みモード（w） で開く。
file.writelines([...]) によって、以下の3行が書き込まれる：
```
apple
banana
cherry
```
2️⃣ readline().strip() で1行読む
```
with open(""example.txt"", ""r"") as file:
    print(file.readline().strip())
```
・""example.txt"" を 読み込みモード（r） で開く。
・file.readline() によって、最初の行 ""apple\n"" を取得 。
・.strip() によって 改行 \n を削除 。
・出力 → ""apple""。
3️⃣ seek(0) でファイルの先頭に戻る
```
    file.seek(0)
```
・seek(0) によって、ファイルの先頭に戻る。
4️⃣ 再び readline().strip() で1行読む
```
    print(file.readline().strip())
```
・再び readline() を実行。
・seek(0) で 先頭に戻っている ため、また1行目 ""apple\n"" を取得。
・.strip() によって 改行 \n を削除。

出力 → ""apple""。

📌strip()は空白文字を削除する。空白文字とは以下の通り。
半角スペース
全角スペース
「\n」改行
「\f」改ページ
「\t」タブ
「\v」垂直タブ
「\r」復帰

💡 ポイント
✅ readline() は1行ずつ読み取る
✅ seek(0) を実行すると、ファイルの先頭に戻る
✅ strip() は空白文字を削除する。この場合、改行文字 \n を削除するので、余分な改行がなくなる",6,3,
355,"以下のコードを実行したときの出力を選択してください。
```
with open(""data.txt"", ""w"") as file:
    file.write(""Line1\nLine2\nLine3"")

with open(""data.txt"", ""r"") as file:
    lines = file.readlines()
    print(lines[-1].strip())
```
1️⃣ ""Line1""
2️⃣ ""Line2""
3️⃣ ""Line3""
4️⃣ Error（エラーが発生する）","3️⃣ ""Line3""","このコードでは、readlines() の動作 とリストのインデックス操作を確認します。

📝 コードの流れ

1️⃣ ファイルにデータを書き込み
```
with open(""data.txt"", ""w"") as file:
    file.write(""Line1\nLine2\nLine3"")
```
 ・""data.txt"" を 書き込みモード（w） で開く。
 ・file.write(""Line1\nLine2\nLine3"") によって、以下の内容がファイルに保存される：
```
Line1
Line2
Line3
```
（※ただし、write() を使うと \n を明示的に入れないと改行されないため、""Line3"" には \n がない）

2️⃣ readlines() でファイルをリストとして取得
```
with open(""data.txt"", ""r"") as file:
    lines = file.readlines()
```
 ・""data.txt"" を 読み込みモード（r） で開く。
 ・file.readlines() によって、各行をリストとして取得 する：
```
lines = [""Line1\n"", ""Line2\n"", ""Line3""]
```

3️⃣ lines[-1].strip() の動作
```
print(lines[-1].strip())
```
 ・lines[-1] は リストの最後の要素（""Line3""）。
 ・.strip() によって、余分な空白や改行 \n が削除される 。
 ・・""Line3"" の場合、改行 \n が元々ない ため、変化なし。

出力 → ""Line3""。

💡 ポイント
✅ readlines() は各行をリストとして取得する！
✅ lines[-1] を使うと最後の行を取得できる！
✅ strip() を使うと改行 \n や空白を削除できる！

✅ 出力の流れ
""Line3""",6,3,
356,"以下のコードを実行したときの出力を選択してください。
```
with open(""sample.txt"", ""w"") as file:
    file.write(""Python\nis\nawesome"")

with open(""sample.txt"", ""r"") as file:
    for line in file:
        print(line.strip())
```
1️⃣
Python
is
awesome

2️⃣
Python is awesome

3️⃣
Python\nis\nawesome

4️⃣ Error（エラーが発生する）

","1️⃣
Python
is
awesome","このコードでは、ファイルの書き込み (write()) と for line in file: での読み込み の動作を確認する問題です。

📝 コードの流れ
1️⃣ ファイルにデータを書き込み
```
with open(""sample.txt"", ""w"") as file:
    file.write(""Python\nis\nawesome"")
```
 ・""sample.txt"" を 書き込みモード（w） で開く。
 ・file.write(""Python\nis\nawesome"") によって、以下の内容がファイルに保存される：
```
Python
is
awesome
```
（改行 \n を入れているため、それぞれの単語が別々の行になる）
2️⃣ for line in file: を使って1行ずつ読み込む
```
with open(""sample.txt"", ""r"") as file:
    for line in file:
        print(line.strip())
```
 ・""sample.txt"" を 読み込みモード（r） で開く。
 ・for line in file: により、ファイルの各行を 1行ずつループで処理 する。
 ・print(line.strip()) により、各行の改行 \n を削除して出力。

3️⃣ 出力結果
for line in file: のループ：
 1回目： ""Python\n"" → .strip() → ""Python"" を出力
 2回目： ""is\n"" → .strip() → ""is"" を出力
 3回目： ""awesome"" → .strip() → ""awesome"" を出力

📌 最終的な出力
Python
is
awesome

したがって、正解は 1️⃣

💡 ポイント
✅ write(""text\n"") を使うと、ファイル内で改行が含まれる！
✅ for line in file: を使うと、1行ずつ読み込める！
✅ strip() を使うと、行末の \n（改行）を削除できる！",6,3,
357,"以下のコードを実行したときの出力を選択してください。
```
with open(""numbers.txt"", ""w"") as file:
    file.write(""123\n456\n789"")

with open(""numbers.txt"", ""r"") as file:
    data = file.read().splitlines()
    print(data)
```
1️⃣ [""123"", ""456"", ""789""]
2️⃣ [""123\n"", ""456\n"", ""789""]
3️⃣ ""123\n456\n789""
4️⃣ Error（エラーが発生する）","1️⃣ [""123"", ""456"", ""789""]","このコードでは、read().splitlines() の動作 を確認する問題です。

📝 コードの流れ
1️⃣ ファイルにデータを書き込み
```
with open(""numbers.txt"", ""w"") as file:
    file.write(""123\n456\n789"")
```
 ・""numbers.txt"" を 書き込みモード（w） で開く。
 ・file.write(""123\n456\n789"") によって、以下の内容がファイルに保存される：
```
123
456
789
```
2️⃣ read().splitlines() でファイルをリストとして取得
```
with open(""numbers.txt"", ""r"") as file:
    data = file.read().splitlines()
    print(data)
```
 ・""numbers.txt"" を 読み込みモード（r） で開く。
 ・file.read() で、ファイル全体を 1つの文字列 として読み込む。
```
""123\n456\n789""
```
.splitlines() を実行すると、改行 \n を基準に分割 してリスト化する。
```
data = [""123"", ""456"", ""789""]
```

🔍 出力結果
[""123"", ""456"", ""789""]

したがって、正解は 1️⃣ [""123"", ""456"", ""789""] でした！ 🎯

💡 ポイント
✅ read().splitlines() は改行 \n を基準にリスト化する！
✅ リストの各要素には \n が含まれない！
✅ readlines() とは異なり、splitlines() は改行を含まないリストを返す！",6,3,
358,"以下のコードを実行したときの出力を選択してください。
```
with open(""data.txt"", ""w"") as file:
    file.write(""apple,banana,cherry"")

with open(""data.txt"", ""r"") as file:
    content = file.read().split("","")
    print(content)
```
1️⃣ [""apple"", ""banana"", ""cherry""]
2️⃣ [""apple,banana,cherry""]
3️⃣ [""apple\nbanana\ncherry""]
4️⃣ Error（エラーが発生する）","1️⃣ [""apple"", ""banana"", ""cherry""]","この問題では、ファイルから読み込んだ文字列を split() で分割する処理 を確認します。

📝 コードの流れ
1️⃣ ファイルにデータを書き込み
```
with open(""data.txt"", ""w"") as file:
    file.write(""apple,banana,cherry"")
```
 ・""data.txt"" を 書き込みモード（w） で開く。
 ・file.write(""apple,banana,cherry"") によって、以下の内容がファイルに保存される：
```
apple,banana,cherry
```
・改行なしの1行データとして保存される。

2️⃣ read().split("","") で分割
```
with open(""data.txt"", ""r"") as file:
    content = file.read().split("","")
    print(content)
```
 ・""data.txt"" を 読み込みモード（r） で開く。
 ・file.read() でファイルの内容を 文字列として全て取得 。
```
""apple,banana,cherry""
```
・.split("","") により、カンマ（,）を区切り文字として分割 。
```
content = [""apple"", ""banana"", ""cherry""]
```
🔍 出力結果
```
[""apple"", ""banana"", ""cherry""]
```
したがって、正解は 1️⃣ [""apple"", ""banana"", ""cherry""] でした！ 🎯

💡 ポイント
✅ file.read() はファイル全体を文字列として取得する！
✅ split("","") を使うと、カンマ区切りのデータをリストに分割できる！
✅ この手法は CSV のようなデータの解析にも役立つ！",6,3,
359,"以下のコードを実行したときの出力を選択してください。
```
import os

file_path = ""testfile.txt""

with open(file_path, ""w"") as file:
    file.write(""Test data"")

os.remove(file_path)

print(os.path.exists(file_path))
```
1️⃣ True
2️⃣ False
3️⃣ testfile.txt
4️⃣ Error（エラーが発生する）","2️⃣ False","このコードでは、ファイルの作成・削除 (os.remove()) と os.path.exists() の動作 を確認します。

📝 コードの流れ
1️⃣ testfile.txt を作成してデータを書き込む
```
with open(file_path, ""w"") as file:
    file.write(""Test data"")
```
 ・file_path = ""testfile.txt"" を定義。
 ・書き込みモード（""w""）でファイルを開く → ""testfile.txt"" が作成される。
 ・""Test data"" をファイルに書き込む。

2️⃣ os.remove() でファイルを削除
```
os.remove(file_path)
```
 ・os.remove(""testfile.txt"") によって、ファイル ""testfile.txt"" を削除。

3️⃣ os.path.exists() でファイルの存在を確認
```
print(os.path.exists(file_path))
```
 ・os.path.exists(file_path) は、指定したファイルが存在するかどうかを判定 する。
 ・""testfile.txt"" はすでに os.remove() で削除されているので、False を返す。

🔍 出力結果
False

✅ 正解は 2️⃣ False 🎯

💡 ポイント
✅ os.remove(file_path) はファイルを完全に削除する！
✅ os.path.exists(file_path) は、ファイルの存在を True / False で返す！
✅ 削除後のファイルは False になるため、ファイルが確実に削除されたことを確認できる！",6,3,
360,"以下のコードを実行したときの出力を選択してください。
```
try:
    result = 10 / 0
except ZeroDivisionError:
    print(""Cannot divide by zero"")
finally:
    print(""Execution completed"")
```
1️⃣ Cannot divide by zero のみ
2️⃣ Execution completed のみ
3️⃣ Cannot divide by zero → Execution completed
4️⃣ Error（エラーが発生する）","3️⃣ Cannot divide by zero → Execution completed","このコードでは、try-except-finally の動作 を確認します。

📝 コードの流れ
1️⃣ try ブロックで例外 (ZeroDivisionError) が発生
```
try:
    result = 10 / 0
```
 ・10 / 0 は ゼロ除算（ZeroDivisionError） なので、エラーが発生する。
 ・ここでプログラムが停止し、except に処理が移る。
 ・result = 10 / 0 の行の後の処理は実行されない！

2️⃣ except ZeroDivisionError でエラーをキャッチ
```
except ZeroDivisionError:
    print(""Cannot divide by zero"")
```
 ・ZeroDivisionError が発生したため、このブロックが実行される。
 ・出力 → ""Cannot divide by zero""

3️⃣ finally ブロックは必ず実行される
```
finally:
    print(""Execution completed"")
```
 ・finally ブロックは、エラーの有無に関係なく 必ず実行される。
 ・出力 → ""Execution completed""

🔍 出力結果
Cannot divide by zero
Execution completed

✅ 正解は 3️⃣ Cannot divide by zero → Execution completed 🎯

💡 ポイント
✅ except は、指定した例外が発生したときに実行される！
✅ finally は、エラーが発生しても必ず実行される！
✅ ZeroDivisionError は、ゼロで割ったときに発生する例外！",7,3,
361,"以下のコードを実行したときの出力を選択してください。
```
try:
    my_list = [1, 2, 3]
    print(my_list[5])
except IndexError as e:
    print(f""Index error: {e}"")
except Exception as e:
    print(f""Other error: {e}"")
```
1️⃣ Index error: list index out of range
2️⃣ Other error: list index out of range
3️⃣ Index error: 5
4️⃣ Error（エラーが発生する）","1️⃣ Index error: list index out of range","このコードでは、リストの IndexError をキャッチするエラーハンドリング を確認します。

📝 コードの流れ
1️⃣ try ブロックでエラーが発生
```
try:
    my_list = [1, 2, 3]
    print(my_list[5])  # インデックス 5 は存在しない！
```
 ・my_list = [1, 2, 3] を定義（長さは 3）。
 ・print(my_list[5]) を実行しようとするが、リストの 範囲外のインデックスを参照しようとして エラー (IndexError) が発生！
```
IndexError: list index out of range
```
 ・この時点でエラーが発生し、except ブロックに処理が移る。
 ・以降の print(my_list[5]) の後の処理は実行されない！

2️⃣ except IndexError as e: でエラーをキャッチ
```
except IndexError as e:
    print(f""Index error: {e}"")
```
 ・IndexError は except IndexError でキャッチされるため、このブロックが実行される。
 ・変数 e には、エラーメッセージ ""list index out of range"" が格納される。
 ・print(f""Index error: {e}"") により、次の出力が得られる：
```
Index error: list index out of range
```

3️⃣ except Exception as e: は実行されない
```
except Exception as e:
    print(f""Other error: {e}"")
```
 ・IndexError は Exception のサブクラス だが、
 　すでに except IndexError でキャッチされたため、この except ブロックは実行されない！

🔍 出力結果
```
Index error: list index out of range
```
✅ 正解は 1️⃣ Index error: list index out of range 🎯

💡 ポイント
✅ リストの範囲外のインデックスにアクセスすると IndexError が発生する！
✅ except IndexError は、IndexError 専用の処理なので優先的に実行される！
✅ except Exception は、一般的な例外処理（IndexError 以外のエラー）用！",7,3,
362,"以下のコードを実行したときの出力を選択してください。
```
def divide(a, b):
    try:
        result = a / b
    except ZeroDivisionError:
        print(""Cannot divide by zero"")
    else:
        print(""Result:"", result)

divide(10, 2)
divide(5, 0)
```
1️⃣
Result: 5.0
Cannot divide by zero

2️⃣
Result: 5.0
Result: 0

3️⃣
Cannot divide by zero
Result: 5.0

4️⃣ Error（エラーが発生する）","1️⃣
Result: 5.0
Cannot divide by zero","このコードでは、try-except-else の動作 を確認します。

📝 コードの流れ
1️⃣ divide(10, 2) の実行
```
divide(10, 2)
```

```
try:
    result = 10 / 2  # 正常に計算できる
except ZeroDivisionError:
    print(""Cannot divide by zero"")  # ここは実行されない
else:
    print(""Result:"", result)  # ここが実行される
```
✅ 10 / 2 = 5.0 のため、except はスキップされ、else ブロックが実行される。
出力 → ""Result: 5.0""

2️⃣ divide(5, 0) の実行
```
divide(5, 0)
```
```
try:
    result = 5 / 0  # ここで ZeroDivisionError 発生！
except ZeroDivisionError:
    print(""Cannot divide by zero"")  # ここが実行される
else:
    print(""Result:"", result)  # ここは実行されない
```

✅ 5 / 0 で ZeroDivisionError が発生！
✅ except ブロックが実行される → ""Cannot divide by zero"" が出力
✅ else ブロックは 実行されない！

🔍 出力結果
Result: 5.0
Cannot divide by zero

✅ 正解は 1️⃣ 🎯

💡 ポイント
✅ try ブロックでエラーが発生しなければ else ブロックが実行される！
✅ try ブロックで ZeroDivisionError が発生すると、except が実行され、else はスキップされる！
✅ except でエラーをキャッチすると、プログラムがクラッシュせずに処理を続行できる！",7,3,
363,"以下のコードを実行したときの出力を選択してください。
```
try:
    value = int(""Hello"")
    print(""Conversion successful"")
except ValueError:
    print(""Invalid conversion"")
finally:
    print(""Execution completed"")
```
1️⃣
Invalid conversion
Execution completed

2️⃣
Conversion successful
Execution completed

3️⃣
Invalid conversion

4️⃣ Error（エラーが発生する）","1️⃣
Invalid conversion
Execution completed","このコードでは、try-except-finally の動作 を確認します。

📝 コードの流れ
1️⃣ try ブロックの実行
```
try:
    value = int(""Hello"")
    print(""Conversion successful"")
```
 ・int(""Hello"") を実行しようとするが、""Hello"" は整数に変換できないため ValueError が発生！
 ・ここで エラーが発生した時点で print(""Conversion successful"") は実行されない！
 ・処理は except にジャンプする。

2️⃣ except ValueError の実行
```
except ValueError:
    print(""Invalid conversion"")
```
 ・ValueError が発生しているため、このブロックが実行される。
 ・出力 → ""Invalid conversion""

3️⃣ finally ブロックの実行
```
finally:
    print(""Execution completed"")
  ```
 ・finally ブロックは、エラーの有無に関わらず必ず実行される！
 ・出力 → ""Execution completed""

🔍 出力結果
```
Invalid conversion
Execution completed
```
✅ 正解は 1️⃣ 🎯

💡 ポイント
✅ int(""Hello"") は ValueError を発生させる！
✅ except ValueError: でエラーをキャッチすると、エラーメッセージを出力できる！
✅ finally は、try でエラーが発生しても必ず実行される！",7,3,
364,"以下のコードを実行したときの出力を選択してください。
```
def func():
    try:
        return 10
    except:
        return 20
    finally:
        return 30

print(func())
```
1️⃣ 10
2️⃣ 20
3️⃣ 30
4️⃣ Error（エラーが発生する）","3️⃣ 30","このコードでは、finally ブロックの動作 を確認します。

📝 コードの流れ
1️⃣ try ブロック
```
try:
    return 10
```
try 内で return 10 が実行される。
通常なら 10 を返して関数は終了するはず だが……。

2️⃣ except ブロック
```
except:
    return 20
```
例外が発生しないため、except ブロックは実行されない！
つまり return 20 は無視される。

3️⃣ finally ブロック
```
finally:
    return 30
```
finally は return の前でも必ず実行される！
しかも finally 内で return がある場合、try の return を上書きする！
つまり、return 10 は破棄され、return 30 が最終的に実行される！

🔍 出力結果
30

✅ 正解は 3️⃣ 30 🎯

💡 ポイント
✅ finally は return よりも優先される！
✅ finally に return があると、それが最終的な戻り値になる！
✅ except ブロックは、例外が発生しない限り実行されない！",7,3,
365,"以下のコードを実行したときの出力を選択してください。
```
try:
    raise ValueError(""An error occurred"")
except TypeError:
    print(""Caught a TypeError"")
except ValueError:
    print(""Caught a ValueError"")
except Exception:
    print(""Caught a generic exception"")
```
1️⃣ Caught a TypeError
2️⃣ Caught a ValueError
3️⃣ Caught a generic exception
4️⃣ Error（エラーが発生する）","2️⃣ Caught a ValueError","このコードでは、except のマッチングの順番 を確認します。

📝 コードの流れ
1️⃣ raise ValueError(""An error occurred"") の実行
```
try:
    raise ValueError(""An error occurred"")
```
 ・raise ValueError(""An error occurred"") によって、ValueError が発生する！
 ・try の処理がここでストップし、except に処理が移る。

2️⃣ except ブロックのマッチング
```
except TypeError:
    print(""Caught a TypeError"")
```
 ・ここで TypeError をキャッチしようとしているが、発生したのは ValueError。
 ・TypeError は発生していないので、このブロックはスキップされる！
```
except ValueError:
    print(""Caught a ValueError"")
```
 ・except ValueError: は、raise ValueError(...) に一致する！
 ・したがって、このブロックが実行される。
 ・出力 → ""Caught a ValueError""
```
except Exception:
    print(""Caught a generic exception"")
```
 ・except Exception: は、どんなエラーでもキャッチできる 汎用的なエラーハンドラー。
 ・しかし、ValueError はすでに前の except でキャッチされているため、ここは実行されない！

🔍 出力結果
```
Caught a ValueError
```
✅ 正解は 2️⃣ Caught a ValueError 🎯

💡 ポイント
✅ except は上から順番にマッチするので、最初に一致したブロックが実行される！
✅ except TypeError: は ValueError にはマッチしないのでスキップされる！
✅ except Exception: は最後の手段として使われるが、より具体的なエラーがキャッチされた場合は実行されない！",7,3,
366,"以下のコードを実行したときの出力を選択してください。
```
try:
    x = 1 / 0
except (ZeroDivisionError, ValueError):
    print(""Math error"")
except Exception:
    print(""General error"")
```
1️⃣ Math error
2️⃣ General error
3️⃣ Error（エラーが発生する）
4️⃣ No output（何も出力されない）

","1️⃣ Math error","このコードでは、複数の例外を1つの except で処理する方法 を確認します。

📝 コードの流れ
1️⃣ try ブロックの実行
```
try:
    x = 1 / 0
```
 ・1 / 0 を実行すると、ゼロ除算エラー (ZeroDivisionError) が発生！
 ・処理が止まり、except に移る。

2️⃣ except (ZeroDivisionError, ValueError): の実行
```
except (ZeroDivisionError, ValueError):
    print(""Math error"")
```
 ・この except は (ZeroDivisionError, ValueError) のどちらかのエラーをキャッチできる！
 ・ZeroDivisionError が発生したので、このブロックが実行される！
 ・出力 → ""Math error""

3️⃣ except Exception: は実行されない
```
except Exception:
    print(""General error"")
```
 ・Exception は ZeroDivisionError も含む汎用的なエラーハンドラー。
 ・しかし、すでに except (ZeroDivisionError, ValueError) で処理されているため、ここは実行されない！

🔍 出力結果
```
Math error
```
✅ 正解は 1️⃣ Math error 🎯

💡 ポイント
✅ 複数のエラーを1つの except で処理するには (Error1, Error2, ...) の形式を使う！
✅ ZeroDivisionError は except (ZeroDivisionError, ValueError): に一致するので、このブロックが実行される！
✅ except Exception: は汎用的なエラーハンドラーだが、上の except で処理された場合はスキップされる！",7,3,
367,"以下のコードを実行したときの出力を選択してください。
```
def func():
    try:
        raise RuntimeError(""Something went wrong"")
    except ValueError:
        print(""Caught a ValueError"")
    finally:
        print(""Finally block executed"")

func()
```
1️⃣ Caught a ValueError のみ
2️⃣ Finally block executed のみ
3️⃣ Finally block executed → RuntimeError: Something went wrong
4️⃣ Error（エラーが発生する）","3️⃣ Finally block executed → RuntimeError: Something went wrong","このコードでは、例外がキャッチされなかった場合の finally の動作 を確認します。

📝 コードの流れ
1️⃣ try ブロックで RuntimeError を発生させる
```
try:
    raise RuntimeError(""Something went wrong"")
```
 ・raise RuntimeError(""Something went wrong"") によって RuntimeError が発生！
 ・処理が停止し、except にジャンプする。
2️⃣ except ValueError をチェック
```
except ValueError:
    print(""Caught a ValueError"")
```
 ・except ValueError は ValueError のみをキャッチ する。
 ・RuntimeError にはマッチしないため、スキップされる！
 ・この時点でエラーはキャッチされていない！

3️⃣ finally ブロックの実行
```
finally:
    print(""Finally block executed"")
```
 ・finally は、エラーの有無に関係なく必ず実行される！
 ・出力 → ""Finally block executed""

4️⃣ RuntimeError がキャッチされていないのでプログラムがクラッシュ
 ・except で RuntimeError をキャッチできなかったため、
 ・最終的に RuntimeError が発生し、プログラムが停止する。
 ・エラーメッセージが表示される！

🔍 出力結果
```
Finally block executed
Traceback (most recent call last):
  File ""<stdin>"", line 2, in func
RuntimeError: Something went wrong
```
✅ 正解は 3️⃣ Finally block executed → RuntimeError: Something went wrong 🎯

💡 ポイント
✅ finally は、エラーがキャッチされなくても必ず実行される！
✅ except で指定されたエラー以外のエラーはキャッチされず、プログラムがクラッシュする！
✅ 例外を適切にキャッチするには、汎用的な except Exception: などを追加するのが良い！",7,3,
368,"下のコードを実行したときの出力を選択してください。
```
try:
    print(""Start"")
    raise KeyboardInterrupt
    print(""This will not be printed"")
except KeyboardInterrupt:
    print(""Caught KeyboardInterrupt"")
finally:
    print(""Finally executed"")
```
1️⃣
Start
Caught KeyboardInterrupt
Finally executed

2️⃣
Start
Finally executed

3️⃣
Start
Caught KeyboardInterrupt

4️⃣ Error（エラーが発生する）","1️⃣
Start
Caught KeyboardInterrupt
Finally executed","このコードでは、KeyboardInterrupt のエラーハンドリングと finally の動作 を確認します。

📝 コードの流れ
1️⃣ try ブロックの実行
```
try:
    print(""Start"")
    raise KeyboardInterrupt
    print(""This will not be printed"")
```
 ・print(""Start"") が実行され、""Start"" が出力される。
 ・raise KeyboardInterrupt によって、KeyboardInterrupt が発生！
 ・エラーが発生した時点で try ブロックの残り（print(""This will not be printed"")）は実行されない！

2️⃣ except KeyboardInterrupt でエラーをキャッチ
```
except KeyboardInterrupt:
    print(""Caught KeyboardInterrupt"")
```
 ・except KeyboardInterrupt が 発生した KeyboardInterrupt にマッチする！
 ・""Caught KeyboardInterrupt"" が出力される。

3️⃣ finally ブロックの実行
```
finally:
    print(""Finally executed"")
```
 ・finally ブロックは、エラーの有無に関わらず必ず実行される！
 ・""Finally executed"" が出力される。

🔍 出力結果
```
Start
Caught KeyboardInterrupt
Finally executed
```
✅ 正解は 1️⃣ 🎯

💡 ポイント
✅ raise KeyboardInterrupt は、手動で Ctrl+C を押したときと同じエラーを発生させる！
✅ except KeyboardInterrupt でエラーをキャッチできる！
✅ finally は、エラーがキャッチされてもされなくても必ず実行される！",7,3,
369,"以下のコードを実行したときの出力を選択してください。
```
class CustomError(Exception):
    pass

try:
    raise CustomError(""This is a custom exception"")
except CustomError as e:
    print(f""Caught custom error: {e}"")
except Exception:
    print(""Caught a general exception"")
finally:
    print(""Finally block executed"")
```
1️⃣
Caught custom error: This is a custom exception
Finally block executed

2️⃣
Caught a general exception
Finally block executed

3️⃣
Finally block executed

4️⃣ Error（エラーが発生する）","1️⃣
Caught custom error: This is a custom exception
Finally block executed","このコードでは、カスタム例外 (CustomError) の処理 と finally ブロックの動作 を確認します。

📝 コードの流れ

1️⃣ CustomError クラスを定義
```
class CustomError(Exception):
    pass
```
 ・CustomError は Exception を継承したカスタム例外クラス。
 ・これにより、通常の Exception と同様に raise で発生させたり、except でキャッチできる。

2️⃣ try ブロックの実行
```
try:
    raise CustomError(""This is a custom exception"")
```
 ・raise CustomError(""This is a custom exception"") によって、CustomError が発生！
 ・エラー発生時点で try の残りの処理は実行されない。
 ・処理は except にジャンプ！

3️⃣ except CustomError as e: の実行
```
except CustomError as e:
    print(f""Caught custom error: {e}"")
```
 ・except CustomError as e: は、発生した CustomError をキャッチできる。
 ・e には ""This is a custom exception"" というメッセージが格納される。
 ・出力 → ""Caught custom error: This is a custom exception""
 ・エラーをキャッチできたので、次の except Exception: はスキップされる！

4️⃣ finally ブロックの実行
```
finally:
    print(""Finally block executed"")
```
 ・finally はエラーの有無に関係なく必ず実行される！
 ・出力 → ""Finally block executed""

🔍 出力結果
```
Caught custom error: This is a custom exception
Finally block executed
```

✅ 正解は 1️⃣ 🎯

💡 ポイント
✅ カスタム例外 (CustomError) は Exception を継承して作る！
✅ raise CustomError(""message"") でエラーを発生させる！
✅ エラーの種類に一致する except が実行される（後ろの except Exception: はスキップ）！
✅ finally は必ず実行される！",7,3,
